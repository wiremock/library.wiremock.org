{
  "openapi" : "3.0.0",
  "servers" : [ {
    "url" : "https://cloudsearch.googleapis.com/"
  } ],
  "info" : {
    "contact" : {
      "name" : "Google",
      "url" : "https://google.com",
      "x-twitter" : "youtube"
    },
    "description" : "Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.",
    "license" : {
      "name" : "Creative Commons Attribution 3.0",
      "url" : "http://creativecommons.org/licenses/by/3.0/"
    },
    "termsOfService" : "https://developers.google.com/terms/",
    "title" : "Cloud Search API",
    "version" : "v1",
    "x-apisguru-categories" : [ "analytics", "media" ],
    "x-logo" : {
      "url" : "https://api.apis.guru/v2/cache/logo/https_upload.wikimedia.org_wikipedia_commons_e_e1_YouTube_play_buttom_icon_%282013-2017%29.svg"
    },
    "x-origin" : [ {
      "converter" : {
        "url" : "https://github.com/mermade/oas-kit",
        "version" : "7.0.4"
      },
      "format" : "google",
      "url" : "https://cloudsearch.googleapis.com/$discovery/rest?version=v1",
      "version" : "v1"
    } ],
    "x-providerName" : "googleapis.com",
    "x-serviceName" : "cloudsearch"
  },
  "externalDocs" : {
    "url" : "https://developers.google.com/cloud-search/docs/guides/"
  },
  "tags" : [ {
    "name" : "debug"
  }, {
    "name" : "indexing"
  }, {
    "name" : "media"
  }, {
    "name" : "operations"
  }, {
    "name" : "query"
  }, {
    "name" : "settings"
  }, {
    "name" : "stats"
  }, {
    "name" : "v1"
  } ],
  "paths" : {
    "/v1/debug/{name}/items:searchByViewUrl" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Fetches the item whose viewUrl exactly matches that of the URL provided in the request. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.debug.datasources.items.searchByViewUrl",
        "parameters" : [ {
          "description" : "Source name, format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SearchItemsByViewUrlRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SearchItemsByViewUrlResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.debug" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.debug" ]
        } ],
        "tags" : [ "debug" ]
      }
    },
    "/v1/debug/{name}:checkAccess" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Checks whether an item is accessible by specified principal. Principal must be a user; groups and domain values aren't supported. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.debug.datasources.items.checkAccess",
        "parameters" : [ {
          "description" : "Item name, format: datasources/{source_id}/items/{item_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/Principal"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CheckAccessResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.debug" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.debug" ]
        } ],
        "tags" : [ "debug" ]
      }
    },
    "/v1/debug/{parent}/items:forunmappedidentity" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Lists names of items associated with an unmapped identity. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.debug.identitysources.items.listForunmappedidentity",
        "parameters" : [ {
          "description" : "The name of the identity source, in the following format: identitysources/{source_id}}",
          "in" : "path",
          "name" : "parent",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "in" : "query",
          "name" : "groupResourceName",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Maximum number of items to fetch in a request. Defaults to 100.",
          "in" : "query",
          "name" : "pageSize",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "The next_page_token value returned from a previous List request, if any.",
          "in" : "query",
          "name" : "pageToken",
          "schema" : {
            "type" : "string"
          }
        }, {
          "in" : "query",
          "name" : "userResourceName",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ListItemNamesForUnmappedIdentityResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.debug" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.debug" ]
        } ],
        "tags" : [ "debug" ]
      }
    },
    "/v1/debug/{parent}/unmappedids" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Lists unmapped user identities for an identity source. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.debug.identitysources.unmappedids.list",
        "parameters" : [ {
          "description" : "The name of the identity source, in the following format: identitysources/{source_id}",
          "in" : "path",
          "name" : "parent",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Maximum number of items to fetch in a request. Defaults to 100.",
          "in" : "query",
          "name" : "pageSize",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "The next_page_token value returned from a previous List request, if any.",
          "in" : "query",
          "name" : "pageToken",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit users selection to this status.",
          "in" : "query",
          "name" : "resolutionStatusCode",
          "schema" : {
            "enum" : [ "CODE_UNSPECIFIED", "NOT_FOUND", "IDENTITY_SOURCE_NOT_FOUND", "IDENTITY_SOURCE_MISCONFIGURED", "TOO_MANY_MAPPINGS_FOUND", "INTERNAL_ERROR" ],
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ListUnmappedIdentitiesResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.debug" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.debug" ]
        } ],
        "tags" : [ "debug" ]
      }
    },
    "/v1/indexing/{name}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "delete" : {
        "description" : "Deletes Item resource for the specified resource name. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.delete",
        "parameters" : [ {
          "description" : "Required. The name of the item to delete. Format: datasources/{source_id}/items/{item_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
          "in" : "query",
          "name" : "connectorName",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Required. The RequestMode for this request.",
          "in" : "query",
          "name" : "mode",
          "schema" : {
            "enum" : [ "UNSPECIFIED", "SYNCHRONOUS", "ASYNCHRONOUS" ],
            "type" : "string"
          }
        }, {
          "description" : "Required. The incremented version of the item to delete from the index. The indexing system stores the version from the datasource as a byte string and compares the Item version in the index to the version of the queued Item using lexical ordering. Cloud Search Indexing won't delete any queued item with a version value that is less than or equal to the version of the currently indexed item. The maximum length for this field is 1024 bytes. For information on how item version affects the deletion process, refer to [Handle revisions after manual deletes](https://developers.google.com/cloud-search/docs/guides/operations).",
          "in" : "query",
          "name" : "version",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      },
      "get" : {
        "description" : "Gets Item resource by item name. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.get",
        "parameters" : [ {
          "description" : "The name of the item to get info. Format: datasources/{source_id}/items/{item_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
          "in" : "query",
          "name" : "connectorName",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Item"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}/items" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Lists all or a subset of Item resources. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.list",
        "parameters" : [ {
          "description" : "The name of the Data Source to list Items. Format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "When set to true, the indexing system only populates the following fields: name, version, queue. metadata.hash, metadata.title, metadata.sourceRepositoryURL, metadata.objectType, metadata.createTime, metadata.updateTime, metadata.contentLanguage, metadata.mimeType, structured_data.hash, content.hash, itemType, itemStatus.code, itemStatus.processingError.code, itemStatus.repositoryError.type, If this value is false, then all the fields are populated in Item.",
          "in" : "query",
          "name" : "brief",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
          "in" : "query",
          "name" : "connectorName",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Maximum number of items to fetch in a request. The max value is 1000 when brief is true. The max value is 10 if brief is false. The default value is 10",
          "in" : "query",
          "name" : "pageSize",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "The next_page_token value returned from a previous List request, if any.",
          "in" : "query",
          "name" : "pageToken",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ListItemsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}/items:deleteQueueItems" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Deletes all items in a queue. This method is useful for deleting stale items. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.deleteQueueItems",
        "parameters" : [ {
          "description" : "The name of the Data Source to delete items in a queue. Format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteQueueItemsRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}/items:poll" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Polls for unreserved items from the indexing queue and marks a set as reserved, starting with items that have the oldest timestamp from the highest priority ItemStatus. The priority order is as follows: ERROR MODIFIED NEW_ITEM ACCEPTED Reserving items ensures that polling from other threads cannot create overlapping sets. After handling the reserved items, the client should put items back into the unreserved state, either by calling index, or by calling push with the type REQUEUE. Items automatically become available (unreserved) after 4 hours even if no update or push method is called. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.poll",
        "parameters" : [ {
          "description" : "The name of the Data Source to poll items. Format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PollItemsRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PollItemsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}/items:unreserve" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Unreserves all items from a queue, making them all eligible to be polled. This method is useful for resetting the indexing queue after a connector has been restarted. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.unreserve",
        "parameters" : [ {
          "description" : "The name of the Data Source to unreserve all items. Format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UnreserveItemsRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}/schema" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "delete" : {
        "description" : "Deletes the schema of a data source. **Note:** This API requires an admin or service account to execute.",
        "operationId" : "cloudsearch.indexing.datasources.deleteSchema",
        "parameters" : [ {
          "description" : "The name of the data source to delete Schema. Format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      },
      "get" : {
        "description" : "Gets the schema of a data source. **Note:** This API requires an admin or service account to execute.",
        "operationId" : "cloudsearch.indexing.datasources.getSchema",
        "parameters" : [ {
          "description" : "The name of the data source to get Schema. Format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Schema"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      },
      "put" : {
        "description" : "Updates the schema of a data source. This method does not perform incremental updates to the schema. Instead, this method updates the schema by overwriting the entire schema. **Note:** This API requires an admin or service account to execute.",
        "operationId" : "cloudsearch.indexing.datasources.updateSchema",
        "parameters" : [ {
          "description" : "The name of the data source to update Schema. Format: datasources/{source_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UpdateSchemaRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}:index" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Updates Item ACL, metadata, and content. It will insert the Item if it does not exist. This method does not support partial updates. Fields with no provided values are cleared out in the Cloud Search index. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.index",
        "parameters" : [ {
          "description" : "The name of the Item. Format: datasources/{source_id}/items/{item_id} This is a required field. The maximum length is 1536 characters.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IndexItemRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}:push" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Pushes an item onto a queue for later polling and updating. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.push",
        "parameters" : [ {
          "description" : "The name of the item to push into the indexing queue. Format: datasources/{source_id}/items/{ID} This is a required field. The maximum length is 1536 characters.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PushItemRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Item"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/indexing/{name}:upload" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Creates an upload session for uploading item content. For items smaller than 100 KB, it's easier to embed the content inline within an index request. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source.",
        "operationId" : "cloudsearch.indexing.datasources.items.upload",
        "parameters" : [ {
          "description" : "The name of the Item to start a resumable upload. Format: datasources/{source_id}/items/{item_id}. The maximum length is 1536 bytes.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/StartUploadItemRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/UploadItemRef"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "indexing" ]
      }
    },
    "/v1/media/{resourceName}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Uploads media for indexing. The upload endpoint supports direct and resumable upload protocols and is intended for large items that can not be [inlined during index requests](https://developers.google.com/cloud-search/docs/reference/rest/v1/indexing.datasources.items#itemcontent). To index large content: 1. Call indexing.datasources.items.upload with the item name to begin an upload session and retrieve the UploadItemRef. 1. Call media.upload to upload the content, as a streaming request, using the same resource name from the UploadItemRef from step 1. 1. Call indexing.datasources.items.index to index the item. Populate the [ItemContent](/cloud-search/docs/reference/rest/v1/indexing.datasources.items#ItemContent) with the UploadItemRef from step 1. For additional information, see [Create a content connector using the REST API](https://developers.google.com/cloud-search/docs/guides/content-connector#rest). **Note:** This API requires a service account to execute.",
        "operationId" : "cloudsearch.media.upload",
        "parameters" : [ {
          "description" : "Name of the media that is being downloaded. See ReadRequest.resource_name.",
          "in" : "path",
          "name" : "resourceName",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/octet-stream" : {
              "schema" : {
                "$ref" : "#/components/schemas/Media"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Media"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        } ],
        "tags" : [ "media" ]
      }
    },
    "/v1/query/search" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "The Cloud Search Query API provides the search method, which returns the most relevant results from a user query. The results can come from Google Workspace apps, such as Gmail or Google Drive, or they can come from data that you have indexed from a third party. **Note:** This API requires a standard end user account to execute. A service account can't perform Query API requests directly; to use a service account to perform queries, set up [Google Workspace domain-wide delegation of authority](https://developers.google.com/cloud-search/docs/guides/delegation/).",
        "operationId" : "cloudsearch.query.search",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SearchRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SearchResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.query" ]
        } ],
        "tags" : [ "query" ]
      }
    },
    "/v1/query/sources" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Returns list of sources that user can use for Search and Suggest APIs. **Note:** This API requires a standard end user account to execute. A service account can't perform Query API requests directly; to use a service account to perform queries, set up [Google Workspace domain-wide delegation of authority](https://developers.google.com/cloud-search/docs/guides/delegation/).",
        "operationId" : "cloudsearch.query.sources.list",
        "parameters" : [ {
          "description" : "Number of sources to return in the response.",
          "in" : "query",
          "name" : "pageToken",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "requestOptions.debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "The BCP-47 language code, such as \"en-US\" or \"sr-Latn\". For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. For translations. Set this field using the language set in browser or for the page. In the event that the user's language preference is known, set this field to the known user language. When specified, the documents in search results are biased towards the specified language. From Suggest API perspective, for 3p suggest this is used as a hint while making predictions to add language boosting.",
          "in" : "query",
          "name" : "requestOptions.languageCode",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The ID generated when you create a search application using the [admin console](https://support.google.com/a/answer/9043922).",
          "in" : "query",
          "name" : "requestOptions.searchApplicationId",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Current user's time zone id, such as \"America/Los_Angeles\" or \"Australia/Sydney\". These IDs are defined by [Unicode Common Locale Data Repository (CLDR)](http://cldr.unicode.org/) project, and currently available in the file [timezone.xml](http://unicode.org/repos/cldr/trunk/common/bcp47/timezone.xml). This field is used to correctly interpret date and time queries. If this field is not specified, the default time zone (UTC) is used.",
          "in" : "query",
          "name" : "requestOptions.timeZone",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ListQuerySourcesResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.query" ]
        } ],
        "tags" : [ "query" ]
      }
    },
    "/v1/query/suggest" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Provides suggestions for autocompleting the query. **Note:** This API requires a standard end user account to execute. A service account can't perform Query API requests directly; to use a service account to perform queries, set up [Google Workspace domain-wide delegation of authority](https://developers.google.com/cloud-search/docs/guides/delegation/).",
        "operationId" : "cloudsearch.query.suggest",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SuggestRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SuggestResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.query" ]
        } ],
        "tags" : [ "query" ]
      }
    },
    "/v1/settings/customer" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get customer settings. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.getCustomer",
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CustomerSettings"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "settings" ]
      },
      "patch" : {
        "description" : "Update customer settings. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.updateCustomer",
        "parameters" : [ {
          "description" : "Update mask to control which fields get updated. If you specify a field in the update_mask but don't specify its value here, that field will be cleared. If the mask is not present or empty, all fields will be updated. Currently supported field paths: vpc_settings and audit_logging_settings",
          "in" : "query",
          "name" : "updateMask",
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CustomerSettings"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "settings" ]
      }
    },
    "/v1/settings/datasources" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Lists datasources. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.datasources.list",
        "parameters" : [ {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Maximum number of datasources to fetch in a request. The max value is 1000. The default value is 1000.",
          "in" : "query",
          "name" : "pageSize",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Starting index of the results.",
          "in" : "query",
          "name" : "pageToken",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ListDataSourceResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "settings" ]
      },
      "post" : {
        "description" : "Creates a datasource. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.datasources.create",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DataSource"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "settings" ]
      }
    },
    "/v1/settings/searchapplications" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Lists all search applications. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.searchapplications.list",
        "parameters" : [ {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "The maximum number of items to return.",
          "in" : "query",
          "name" : "pageSize",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "The next_page_token value returned from a previous List request, if any. The default value is 10",
          "in" : "query",
          "name" : "pageToken",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ListSearchApplicationsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "settings" ]
      },
      "post" : {
        "description" : "Creates a search application. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.searchapplications.create",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SearchApplication"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "settings" ]
      }
    },
    "/v1/settings/{name}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "delete" : {
        "description" : "Deletes a search application. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.searchapplications.delete",
        "parameters" : [ {
          "description" : "The name of the search application to be deleted. Format: applications/{application_id}.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "settings" ]
      },
      "get" : {
        "description" : "Gets the specified search application. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.searchapplications.get",
        "parameters" : [ {
          "description" : "The name of the search application. Format: searchapplications/{application_id}.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
          "in" : "query",
          "name" : "debugOptions.enableDebugging",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SearchApplication"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "settings" ]
      },
      "patch" : {
        "description" : "Updates a search application. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.searchapplications.patch",
        "parameters" : [ {
          "description" : "The name of the Search Application. Format: searchapplications/{application_id}.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Only applies to [`settings.searchapplications.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.searchapplications/patch). Update mask to control which fields to update. Example field paths: `search_application.name`, `search_application.displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don't specify its value in the `search_application`, then that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated.",
          "in" : "query",
          "name" : "updateMask",
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SearchApplication"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "settings" ]
      },
      "put" : {
        "description" : "Updates a search application. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.searchapplications.update",
        "parameters" : [ {
          "description" : "The name of the Search Application. Format: searchapplications/{application_id}.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Only applies to [`settings.searchapplications.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.searchapplications/patch). Update mask to control which fields to update. Example field paths: `search_application.name`, `search_application.displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don't specify its value in the `search_application`, then that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated.",
          "in" : "query",
          "name" : "updateMask",
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SearchApplication"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "settings" ]
      }
    },
    "/v1/settings/{name}:reset" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Resets a search application to default settings. This will return an empty response. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.settings.searchapplications.reset",
        "parameters" : [ {
          "description" : "The name of the search application to be reset. Format: applications/{application_id}.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ResetSearchApplicationRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "settings" ]
      }
    },
    "/v1/stats/index" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Gets indexed item statistics aggreggated across all data sources. This API only returns statistics for previous dates; it doesn't return statistics for the current day. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.getIndex",
        "parameters" : [ {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetCustomerIndexStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/index/{name}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Gets indexed item statistics for a single data source. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.index.datasources.get",
        "parameters" : [ {
          "description" : "The resource id of the data source to retrieve statistics for, in the following format: \"datasources/{source_id}\"",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetDataSourceIndexStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/query" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get the query statistics for customer. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.getQuery",
        "parameters" : [ {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetCustomerQueryStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/query/{name}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get the query statistics for search application. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.query.searchapplications.get",
        "parameters" : [ {
          "description" : "The resource id of the search application query stats, in the following format: searchapplications/{application_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetSearchApplicationQueryStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/searchapplication" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get search application stats for customer. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.getSearchapplication",
        "parameters" : [ {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "endDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "endDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "endDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "startDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "startDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "startDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetCustomerSearchApplicationStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/session" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get the # of search sessions, % of successful sessions with a click query statistics for customer. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.getSession",
        "parameters" : [ {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetCustomerSessionStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/session/{name}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get the # of search sessions, % of successful sessions with a click query statistics for search application. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.session.searchapplications.get",
        "parameters" : [ {
          "description" : "The resource id of the search application session stats, in the following format: searchapplications/{application_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetSearchApplicationSessionStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/user" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get the users statistics for customer. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.getUser",
        "parameters" : [ {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetCustomerUserStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/stats/user/{name}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Get the users statistics for search application. **Note:** This API requires a standard end user account to execute.",
        "operationId" : "cloudsearch.stats.user.searchapplications.get",
        "parameters" : [ {
          "description" : "The resource id of the search application session stats, in the following format: searchapplications/{application_id}",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "fromDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "fromDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "fromDate.year",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
          "in" : "query",
          "name" : "toDate.day",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Month of date. Must be from 1 to 12.",
          "in" : "query",
          "name" : "toDate.month",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "Year of date. Must be from 1 to 9999.",
          "in" : "query",
          "name" : "toDate.year",
          "schema" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GetSearchApplicationUserStatsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.stats.indexing" ]
        } ],
        "tags" : [ "stats" ]
      }
    },
    "/v1/{name}" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service.",
        "operationId" : "cloudsearch.operations.get",
        "parameters" : [ {
          "description" : "The name of the operation resource.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.debug" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.debug" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "operations" ]
      }
    },
    "/v1/{name}/lro" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "get" : {
        "description" : "Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.",
        "operationId" : "cloudsearch.operations.lro.list",
        "parameters" : [ {
          "description" : "The name of the operation's parent resource.",
          "in" : "path",
          "name" : "name",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The standard list filter.",
          "in" : "query",
          "name" : "filter",
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The standard list page size.",
          "in" : "query",
          "name" : "pageSize",
          "schema" : {
            "type" : "integer"
          }
        }, {
          "description" : "The standard list page token.",
          "in" : "query",
          "name" : "pageToken",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ListOperationsResponse"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.debug" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.debug" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.indexing" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.query" ]
        } ],
        "tags" : [ "operations" ]
      }
    },
    "/v1:initializeCustomer" : {
      "parameters" : [ {
        "$ref" : "#/components/parameters/_.xgafv"
      }, {
        "$ref" : "#/components/parameters/access_token"
      }, {
        "$ref" : "#/components/parameters/alt"
      }, {
        "$ref" : "#/components/parameters/callback"
      }, {
        "$ref" : "#/components/parameters/fields"
      }, {
        "$ref" : "#/components/parameters/key"
      }, {
        "$ref" : "#/components/parameters/oauth_token"
      }, {
        "$ref" : "#/components/parameters/prettyPrint"
      }, {
        "$ref" : "#/components/parameters/quotaUser"
      }, {
        "$ref" : "#/components/parameters/upload_protocol"
      }, {
        "$ref" : "#/components/parameters/uploadType"
      } ],
      "post" : {
        "description" : "Enables `third party` support in Google Cloud Search. **Note:** This API requires an admin account to execute.",
        "operationId" : "cloudsearch.initializeCustomer",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/InitializeCustomerRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Operation"
                }
              }
            },
            "description" : "Successful response"
          }
        },
        "security" : [ {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings" ]
        }, {
          "Oauth2" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ],
          "Oauth2c" : [ "https://www.googleapis.com/auth/cloud_search.settings.indexing" ]
        } ],
        "tags" : [ "v1" ]
      }
    }
  },
  "components" : {
    "parameters" : {
      "_.xgafv" : {
        "description" : "V1 error format.",
        "in" : "query",
        "name" : "$.xgafv",
        "schema" : {
          "enum" : [ "1", "2" ],
          "type" : "string"
        }
      },
      "access_token" : {
        "description" : "OAuth access token.",
        "in" : "query",
        "name" : "access_token",
        "schema" : {
          "type" : "string"
        }
      },
      "alt" : {
        "description" : "Data format for response.",
        "in" : "query",
        "name" : "alt",
        "schema" : {
          "enum" : [ "json", "media", "proto" ],
          "type" : "string"
        }
      },
      "callback" : {
        "description" : "JSONP",
        "in" : "query",
        "name" : "callback",
        "schema" : {
          "type" : "string"
        }
      },
      "fields" : {
        "description" : "Selector specifying which fields to include in a partial response.",
        "in" : "query",
        "name" : "fields",
        "schema" : {
          "type" : "string"
        }
      },
      "key" : {
        "description" : "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.",
        "in" : "query",
        "name" : "key",
        "schema" : {
          "type" : "string"
        }
      },
      "oauth_token" : {
        "description" : "OAuth 2.0 token for the current user.",
        "in" : "query",
        "name" : "oauth_token",
        "schema" : {
          "type" : "string"
        }
      },
      "prettyPrint" : {
        "description" : "Returns response with indentations and line breaks.",
        "in" : "query",
        "name" : "prettyPrint",
        "schema" : {
          "type" : "boolean"
        }
      },
      "quotaUser" : {
        "description" : "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.",
        "in" : "query",
        "name" : "quotaUser",
        "schema" : {
          "type" : "string"
        }
      },
      "uploadType" : {
        "description" : "Legacy upload protocol for media (e.g. \"media\", \"multipart\").",
        "in" : "query",
        "name" : "uploadType",
        "schema" : {
          "type" : "string"
        }
      },
      "upload_protocol" : {
        "description" : "Upload protocol for media (e.g. \"raw\", \"multipart\").",
        "in" : "query",
        "name" : "upload_protocol",
        "schema" : {
          "type" : "string"
        }
      }
    },
    "schemas" : {
      "AbuseReportingConfig" : {
        "description" : "Abuse reporting configuration outlining what is supported in this conference.",
        "properties" : {
          "recordingAllowed" : {
            "description" : "Whether the current call may include video recordings in its abuse reports.",
            "type" : "boolean"
          },
          "writtenUgcAllowed" : {
            "description" : "Whether the current call may include user generated content (chat, polls, Q&A...) in its abuse reports.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "AckInfo" : {
        "description" : "Information about how devices in a meeting have acked for a session/operation.",
        "properties" : {
          "unackedDeviceCount" : {
            "description" : "Output only. Number of meeting devices that have not acked yet.",
            "format" : "int32",
            "readOnly" : true,
            "type" : "integer"
          },
          "unackedDeviceIds" : {
            "description" : "Output only. IDs of meeting devices (at most ten are provided) that have not acked yet.",
            "items" : {
              "type" : "string"
            },
            "readOnly" : true,
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AclFixRequest" : {
        "description" : "The request set by clients to instruct Backend how the user intend to fix the ACL. Technically it's not a request to ACL Fixer, because Backend uses /DriveService.Share to modify Drive ACLs.",
        "properties" : {
          "recipientEmails" : {
            "description" : "For Spaces messages: This field is ignored. For DMs messages: The list of email addresses that should be added to the Drive item's ACL. In general, the list should not be empty when the boolean \"should_fix\" field is set; otherwise, the list should be empty. During transition - when clients do not specify this field but the \"should_fix\" is true, we follow the legacy behavior: share to all users in the DM regardless of emails. This behavior is being phased out.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "role" : {
            "enum" : [ "UNKNOWN", "READER", "COMMENTER", "WRITER" ],
            "type" : "string"
          },
          "shouldFix" : {
            "description" : "Whether to attempt to fix the ACL by adding the room or DM members to the Drive file's ACL.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "AclFixStatus" : {
        "description" : "The message reconstructed based on information in the response of /PermissionFixOptionsService.Query (or the Apiary API that wraps it). Indicates the ability of the requester to change the access to the Drive file for the room roster or the DM members. Used in GetMessagePreviewMetadataResponse only.",
        "properties" : {
          "fixability" : {
            "enum" : [ "UNKNOWN", "ALREADY_ACCESSIBLE", "CAN_FIX", "CANNOT_FIX", "ACL_FIXER_ERROR" ],
            "type" : "string"
          },
          "fixableEmailAddress" : {
            "description" : "List of recipient email addresses for which access can be granted. This field contains the same email addresses from the GetMessagePreviewMetadata request if all recipients can be successfully added to the ACL as determined by Drive ACL Fixer. For now, the field is non-empty if and only if the \"fixability\" value is \"CAN_FIX\".",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "outOfDomainWarningEmailAddress" : {
            "description" : "List of recipient email addresses for which an out-of-domain-sharing warning must be shown, stating that these email addresses are not in the Google Apps organization that the requested item belong to. Empty if all recipients are in the same Google Apps organization.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AclInfo" : {
        "description" : "Next tag: 4",
        "properties" : {
          "groupsCount" : {
            "description" : "Number of groups which have at least read access to the document.",
            "format" : "int32",
            "type" : "integer"
          },
          "scope" : {
            "description" : "The scope to which the content was shared.",
            "enum" : [ "LIMITED", "DASHER_DOMAIN_WITH_LINK", "DASHER_DOMAIN", "PUBLIC_WITH_LINK", "PUBLIC", "TEAM_DRIVE" ],
            "type" : "string"
          },
          "usersCount" : {
            "description" : "Number of users which have at least read access to the document.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "ActionParameter" : {
        "description" : "List of string parameters that developers can specify when the above action method (in apps script) is invoked. An example use case is for 3 snooze buttons: snooze now, snooze 1 day, snooze next week. Developers can have action method = snooze() and pass the snooze type and snooze time in list of string parameters.",
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "value" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AddonComposeUiActionMarkup" : {
        "properties" : {
          "type" : {
            "enum" : [ "UNSPECIFIED", "DISMISS" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AffectedMembership" : {
        "description" : "Earlier we used to populate just the affected_members list and inferred the new membership state (roles didn't exist back then) from the Type. go/dynamite-finra required backend to know the previous membership state to reconstruct membership history. The proper solution involved cleaning up up Type enum, but it was used in many, many places. This was added as a stop-gap solution to unblock FINRA without breaking everything. Later role update and target audience update started relying on this to communicate information to clients about what transition happened. So this is now required to be populated and should be in sync with affected_members for new messages.",
        "properties" : {
          "affectedMember" : {
            "$ref" : "#/components/schemas/MemberId"
          },
          "priorMembershipRole" : {
            "enum" : [ "ROLE_UNKNOWN", "ROLE_NONE", "ROLE_INVITEE", "ROLE_MEMBER", "ROLE_OWNER" ],
            "type" : "string"
          },
          "priorMembershipState" : {
            "enum" : [ "MEMBER_UNKNOWN", "MEMBER_INVITED", "MEMBER_JOINED", "MEMBER_NOT_A_MEMBER", "MEMBER_FAILED" ],
            "type" : "string"
          },
          "targetMembershipRole" : {
            "enum" : [ "ROLE_UNKNOWN", "ROLE_NONE", "ROLE_INVITEE", "ROLE_MEMBER", "ROLE_OWNER" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AllAuthenticatedUsersProto" : {
        "description" : "Represents a principal who has authenticated as any kind of user which the application understands. This is typically used for \"wiki-like\" security, where anyone is allowed access so long as they can be held accountable for that access. Since the purpose is knowing whom to blame, it is up to the application to decide what kinds of users it knows how to blame. For example, an application might choose to include GAIA users in \"all authenticated users\", but not include MDB users. Nothing here.",
        "type" : "object"
      },
      "Annotation" : {
        "description" : "NOTE WHEN ADDING NEW PROTO FIELDS: Be sure to add datapol annotations to new fields with potential PII, so they get scrubbed when logging protos for errors. NEXT TAG: 31",
        "properties" : {
          "babelPlaceholderMetadata" : {
            "$ref" : "#/components/schemas/BabelPlaceholderMetadata"
          },
          "cardCapabilityMetadata" : {
            "$ref" : "#/components/schemas/CardCapabilityMetadata"
          },
          "chipRenderType" : {
            "description" : "Whether the annotation should be rendered as a preview chip. If this is missing or unspecified, fallback to should_not_render on the metadata.",
            "enum" : [ "CHIP_RENDER_TYPE_UNSPECIFIED", "RENDER", "RENDER_IF_POSSIBLE", "DO_NOT_RENDER" ],
            "type" : "string"
          },
          "consentedAppUnfurlMetadata" : {
            "$ref" : "#/components/schemas/ConsentedAppUnfurlMetadata"
          },
          "customEmojiMetadata" : {
            "$ref" : "#/components/schemas/CustomEmojiMetadata"
          },
          "dataLossPreventionMetadata" : {
            "$ref" : "#/components/schemas/DataLossPreventionMetadata"
          },
          "driveMetadata" : {
            "$ref" : "#/components/schemas/DriveMetadata"
          },
          "formatMetadata" : {
            "$ref" : "#/components/schemas/FormatMetadata"
          },
          "groupRetentionSettingsUpdated" : {
            "$ref" : "#/components/schemas/GroupRetentionSettingsUpdatedMetaData"
          },
          "gsuiteIntegrationMetadata" : {
            "$ref" : "#/components/schemas/GsuiteIntegrationMetadata"
          },
          "incomingWebhookChangedMetadata" : {
            "$ref" : "#/components/schemas/IncomingWebhookChangedMetadata"
          },
          "inlineRenderFormat" : {
            "description" : "The inline render format of this annotation. go/drive-smart-chips-chat-v2.",
            "enum" : [ "INLINE_RENDER_FORMAT_UNSPECIFIED", "SMART_CHIP" ],
            "type" : "string"
          },
          "integrationConfigUpdated" : {
            "$ref" : "#/components/schemas/IntegrationConfigUpdatedMetadata"
          },
          "interactionData" : {
            "$ref" : "#/components/schemas/InteractionData"
          },
          "length" : {
            "description" : "Length of the text_body substring beginning from start_index the Annotation corresponds to.",
            "format" : "int32",
            "type" : "integer"
          },
          "localId" : {
            "description" : "* A client-assigned ID for this annotation. This is helpful in matching the back-filled annotations to the original annotations on client side, without having to re-parse the message. There is no guarantee an annotation has a local_id, it's a purely client used and controlled field with no guarantee of uniqueness.",
            "type" : "string"
          },
          "membershipChanged" : {
            "$ref" : "#/components/schemas/MembershipChangedMetadata"
          },
          "readReceiptsSettingsMetadata" : {
            "$ref" : "#/components/schemas/ReadReceiptsSettingsUpdatedMetadata"
          },
          "requiredMessageFeaturesMetadata" : {
            "$ref" : "#/components/schemas/RequiredMessageFeaturesMetadata"
          },
          "roomUpdated" : {
            "$ref" : "#/components/schemas/RoomUpdatedMetadata"
          },
          "serverInvalidated" : {
            "description" : "Whether or not the annotation is invalidated by the server. Example of situations for invalidation include: when the URL is malformed, or when Drive item ID is rejected by Drive Service.",
            "type" : "boolean"
          },
          "slashCommandMetadata" : {
            "$ref" : "#/components/schemas/SlashCommandMetadata"
          },
          "startIndex" : {
            "description" : "Start index (0-indexed) of the Message text the Annotation corresponds to, inclusive.",
            "format" : "int32",
            "type" : "integer"
          },
          "type" : {
            "description" : "Type of the Annotation.",
            "enum" : [ "TYPE_UNSPECIFIED", "URL", "DRIVE_FILE", "DRIVE_DOC", "DRIVE_SHEET", "DRIVE_SLIDE", "DRIVE_FORM", "USER_MENTION", "SLASH_COMMAND", "CONSENTED_APP_UNFURL", "VIDEO", "FORMAT_DATA", "IMAGE", "PDF", "VIDEO_CALL", "UPLOAD_METADATA", "GSUITE_INTEGRATION", "CUSTOM_EMOJI", "CARD_CAPABILITY", "DATA_LOSS_PREVENTION", "REQUIRED_MESSAGE_FEATURES_METADATA", "MEMBERSHIP_CHANGED", "ROOM_UPDATED", "GROUP_RETENTION_SETTINGS_UPDATED", "BABEL_PLACEHOLDER", "READ_RECEIPTS_SETTINGS_UPDATED", "INCOMING_WEBHOOK_CHANGED", "INTEGRATION_CONFIG_UPDATED", "INVITATION" ],
            "type" : "string"
          },
          "uniqueId" : {
            "description" : "* A unique server-assigned ID for this annotation. This is helpful in matching annotation objects when fetched from service. All uploads should have a unique_id after the message they are attached to is successfully sent. Url annotations that originally were uploads (i.e. policy violations) will have a unique_id after the message they are attached to is successfully sent. No other url annotations should have a unique_id. All drive annotations should have a unique_id after the message they are attached to is successfully sent.",
            "type" : "string"
          },
          "uploadMetadata" : {
            "$ref" : "#/components/schemas/UploadMetadata"
          },
          "urlMetadata" : {
            "$ref" : "#/components/schemas/UrlMetadata"
          },
          "userMentionMetadata" : {
            "$ref" : "#/components/schemas/UserMentionMetadata"
          },
          "videoCallMetadata" : {
            "$ref" : "#/components/schemas/VideoCallMetadata"
          },
          "youtubeMetadata" : {
            "$ref" : "#/components/schemas/YoutubeMetadata"
          }
        },
        "type" : "object"
      },
      "AppId" : {
        "description" : "Identifier of an App.",
        "properties" : {
          "appType" : {
            "description" : "Enum indicating the type of App this is.",
            "enum" : [ "APP_TYPE_UNSPECIFIED", "APP", "GSUITE_APP", "INCOMING_WEBHOOK" ],
            "type" : "string"
          },
          "gsuiteAppType" : {
            "description" : "Enum indicating which 1P App this is when app_type is GSUITE_APP. Determined & set by the 1P API as a convenience for all users of this identifier(Eg. clients, chime, backend etc.) to map to 1P properties.",
            "enum" : [ "GSUITE_APP_TYPE_UNSPECIFIED", "TASKS_APP", "CALENDAR_APP", "DOCS_APP", "SHEETS_APP", "SLIDES_APP", "MEET_APP", "ASSISTIVE_SUGGESTION_APP", "CONTACTS_APP", "ACTIVITY_FEED_APP", "DRIVE_APP", "CHAT_IN_MEET_APP" ],
            "type" : "string"
          },
          "id" : {
            "description" : "Numeric identifier of the App. Set to Project number for 1/3P Apps. For Webhook, this is WebhookId. Determined & set by the 1P API from App credentials on the side channel.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedActivityFeedAnnotationData" : {
        "description" : "Next Id: 7",
        "properties" : {
          "activityFeedMessageCreateTime" : {
            "description" : "Timestamp of when the Activity Feed message that contains this annotation was created. This is roughly when the activity happened, such as when a reaction happened, but will have at least some small delay, since the Activity Feed message is created asynchronously after. This timestamp should only be used for display when the activity create time is not available in the Chat UI, like the time of a reaction.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "activityFeedMessageId" : {
            "$ref" : "#/components/schemas/MessageId"
          },
          "chatItem" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedChatItem"
          },
          "sharedUserInfo" : {
            "$ref" : "#/components/schemas/UserInfo"
          },
          "userInfo" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedActivityFeedAnnotationDataUserInfo"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedActivityFeedAnnotationDataUserInfo" : {
        "description" : "UserId of the AF item updater to show and the updater count to show.",
        "properties" : {
          "updaterCountDisplayType" : {
            "description" : "Describes how updater_count_to_show should be used.",
            "enum" : [ "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED", "EXACT_COUNT", "NONZERO_COUNT" ],
            "type" : "string"
          },
          "updaterCountToShow" : {
            "description" : "The number of updaters for clients to show, currently set to the total number of updaters minus the one set in updater_to_show.",
            "format" : "int32",
            "type" : "integer"
          },
          "updaterToShow" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAppProfile" : {
        "description" : "Optional field for apps overriding display info",
        "properties" : {
          "avatarEmoji" : {
            "description" : "Displayed user avatar emoji.",
            "type" : "string"
          },
          "avatarUrl" : {
            "description" : "Displayed user avatar url.",
            "type" : "string"
          },
          "name" : {
            "description" : "Displayed user name.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAssistantAnnotationData" : {
        "description" : "This is the internal version of the API proto at google3/google/chat/v1/gsuite_message_integration.proto Data used to render Assistant suggestions. See go/bullseye-rendering.",
        "properties" : {
          "suggestion" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAssistantSuggestion"
          },
          "unfulfillable" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAssistantUnfulfillableRequest"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAssistantDebugContext" : {
        "description" : "Represents info regarding suggestion debug information.",
        "properties" : {
          "query" : {
            "description" : "The query that triggered the resulting suggestion.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAssistantFeedbackContext" : {
        "description" : "Data needed to render feedback on the Assistant card",
        "properties" : {
          "feedbackChips" : {
            "description" : "Specifies a list of feedback chips to show",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteSharedAssistantFeedbackContextFeedbackChip"
            },
            "type" : "array"
          },
          "thumbsFeedback" : {
            "description" : "Whether the thumbs feedback is provided",
            "enum" : [ "THUMBS_FEEDBACK_UNSPECIFIED", "NONE_SELECTED", "UP", "DOWN" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAssistantFeedbackContextFeedbackChip" : {
        "description" : "Suggestion chips for users to indicate positive or negative feedback",
        "properties" : {
          "feedbackChipType" : {
            "description" : "What type of chip to display",
            "enum" : [ "FEEDBACK_CHIP_TYPE_UNSPECIFIED", "WRONG_TRIGGER", "WRONG_FILE", "CORRECT_TRIGGER", "CORRECT_FILE", "DISRUPTIVE", "OTHER" ],
            "type" : "string"
          },
          "state" : {
            "description" : "Whether the chip has been selected",
            "enum" : [ "FEEDBACK_CHIP_STATE_UNSPECIFIED", "SELECTED", "UNSELECTED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAssistantSessionContext" : {
        "description" : "Session context specific for Assistant suggestions.",
        "properties" : {
          "contextualSessionId" : {
            "description" : "Unique identifier populated by the contextual request handler for each vertical (Ex: File Suggestions, Smart Scheduling, etc.) that can be used to track sessions end-to-end. May span multiple users (sender-specific).",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAssistantSuggestion" : {
        "description" : "Data for an Assistant suggestion.",
        "properties" : {
          "debugContext" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAssistantDebugContext"
          },
          "feedbackContext" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAssistantFeedbackContext"
          },
          "findDocumentSuggestion" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedFindDocumentSuggestion"
          },
          "serializedSuggestions" : {
            "description" : "String representation of the suggestions provided.",
            "type" : "string"
          },
          "sessionContext" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAssistantSessionContext"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedAssistantUnfulfillableRequest" : {
        "description" : "Data for a response to an unfulfillable request.",
        "type" : "object"
      },
      "AppsDynamiteSharedAvatarInfo" : {
        "properties" : {
          "emoji" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedEmoji"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedBackendUploadMetadata" : {
        "description" : "Metadata used only in Dynamite backend for uploaded attachments.",
        "properties" : {
          "blobPath" : {
            "description" : "Blobstore path for the uploaded attachment",
            "type" : "string"
          },
          "contentName" : {
            "description" : "The original file name for the content, not the full path.",
            "type" : "string"
          },
          "contentSize" : {
            "description" : "Scotty reported content size by default. http://google3/uploader/agent/scotty_agent.proto?l=101&rcl=140889785",
            "format" : "int64",
            "type" : "string"
          },
          "contentType" : {
            "description" : "Type is from Scotty's best_guess by default: http://google3/uploader/agent/scotty_agent.proto?l=51&rcl=140889785",
            "type" : "string"
          },
          "dlpScanOutcome" : {
            "description" : "The results of the Data Loss Prevention (DLP) scan of the attachment. DEPRECATED: use dlp_scan_summary instead.",
            "enum" : [ "SCAN_UNKNOWN_OUTCOME", "SCAN_SUCCEEDED_NO_VIOLATION", "SCAN_SUCCEEDED_BLOCK", "SCAN_SUCCEEDED_WARN", "SCAN_SUCCEEDED_AUDIT_ONLY", "SCAN_FAILURE_EXCEPTION", "SCAN_FAILURE_RULE_FETCH_FAILED", "SCAN_FAILURE_TIMEOUT", "SCAN_FAILURE_ALL_RULES_FAILED", "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS", "SCAN_SKIPPED_EXPERIMENT_DISABLED", "SCAN_SKIPPED_CONSUMER", "SCAN_SKIPPED_NON_HUMAN_USER", "SCAN_SKIPPED_NO_MESSAGE", "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING", "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN", "SCAN_SKIPPED_MESSAGE_SENT_DURING_SPACE_MIGRATION", "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND", "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS", "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER", "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR", "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE", "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE", "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION", "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK", "SCAN_SUCCEEDED_WITH_FAILURES_WARN", "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" ],
            "type" : "string"
          },
          "dlpScanSummary" : {
            "$ref" : "#/components/schemas/DlpScanSummary"
          },
          "groupId" : {
            "$ref" : "#/components/schemas/GroupId"
          },
          "isClientSideTranscodedVideo" : {
            "description" : "If the uploaded file is a video that has been transcoded on the client side Next tag: 18",
            "type" : "boolean"
          },
          "originalDimension" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedDimension"
          },
          "quoteReplyMessageId" : {
            "$ref" : "#/components/schemas/MessageId"
          },
          "sha256" : {
            "description" : "The SHA256 hash of the attachment bytes.",
            "format" : "byte",
            "type" : "string"
          },
          "uploadIp" : {
            "description" : "User IP address at upload time. Ex. \"123.1.2.3\". Used by Ares abuse scanning.",
            "type" : "string"
          },
          "uploadTimestampUsec" : {
            "description" : "Timestamp of when user finished uploading the content.",
            "format" : "int64",
            "type" : "string"
          },
          "videoId" : {
            "description" : "VideoID of the video attachments. This ID shall meets the Youtube ID format of 16 hex characters. For example, '4c14b8825af6059b' is a valid ID.",
            "type" : "string"
          },
          "videoThumbnailBlobId" : {
            "description" : "Full Blobstore ID for the video thumbnail.",
            "type" : "string"
          },
          "virusScanResult" : {
            "description" : "Result for a virus scan.",
            "enum" : [ "UNKNOWN_VIRUS_SCAN_RESULT", "CLEAN", "INFECTED", "ERROR", "POLICY_VIOLATION" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedCalendarEventAnnotationData" : {
        "properties" : {
          "calendarEvent" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent"
          },
          "eventCreation" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCalendarEventAnnotationDataEventCreation"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent" : {
        "properties" : {
          "endTime" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime"
          },
          "eventId" : {
            "description" : "ID of the event.",
            "type" : "string"
          },
          "startTime" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime"
          },
          "title" : {
            "description" : "Title of the event (at the time the message was generated).",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime" : {
        "properties" : {
          "allDay" : {
            "$ref" : "#/components/schemas/Date"
          },
          "timed" : {
            "description" : "Non all day event.",
            "format" : "google-datetime",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedCalendarEventAnnotationDataEventCreation" : {
        "description" : "Creation of an event (no extra data for now).",
        "type" : "object"
      },
      "AppsDynamiteSharedCallAnnotationData" : {
        "description" : "Data used to render Meet or Google Voice chips in Chat. See go/dynamite-calling-artifacts-in-chat.",
        "properties" : {
          "callEndedTimestamp" : {
            "description" : "Timestamp when the call ended. Used to render the call ended system message.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "callMetadata" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCallMetadata"
          },
          "callStatus" : {
            "description" : "Required. Indicates the call status for the space. Used to determine the chip's state.",
            "enum" : [ "CALL_STATUS_UNSPECIFIED", "CALL_STARTED", "CALL_MISSED", "CALL_ENDED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedCallMetadata" : {
        "description" : "Metadata required to generate call artifacts. This can either be the metadata for a Meet or, in the future, Google Voice call.",
        "properties" : {
          "meetMetadata" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedMeetMetadata"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedCardClickSuggestion" : {
        "description" : "Card click which identifies one suggestion provided by the app/bot.",
        "properties" : {
          "actionId" : {
            "description" : "Identify the button/action that created the suggestion. A simple example would be a card button within the stream, or the id which can identify a specific suggestion.",
            "type" : "string"
          },
          "suggestionMessageId" : {
            "$ref" : "#/components/schemas/MessageId"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedChatItem" : {
        "description" : "Next Id: 5",
        "properties" : {
          "activityInfo" : {
            "description" : "Information needed to render the specific type of feed item.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteSharedChatItemActivityInfo"
            },
            "type" : "array"
          },
          "groupInfo" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedChatItemGroupInfo"
          },
          "messageInfo" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedMessageInfo"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedChatItemActivityInfo" : {
        "properties" : {
          "feedItemNudge" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedChatItemActivityInfoFeedItemNudge"
          },
          "feedItemReactions" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedChatItemActivityInfoFeedItemReactions"
          },
          "feedItemThreadReply" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply"
          },
          "feedItemUserMention" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedChatItemActivityInfoFeedItemNudge" : {
        "description" : "Existence of this attribute indicates that the AF item is for a message nudge item.",
        "properties" : {
          "nudgeType" : {
            "description" : "Nudge type of the nudge feed item.",
            "enum" : [ "UNDEFINED", "REPLY", "FOLLOW_UP" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedChatItemActivityInfoFeedItemReactions" : {
        "description" : "Existence of this attribute indicates that the AF item is for message reactions, but it is intentionally left empty since the list of reactions can be found in the top-level Message.Reactions.",
        "type" : "object"
      },
      "AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply" : {
        "description" : "Existence of this attribute indicates that the AF item is for thread reply.",
        "properties" : {
          "replyType" : {
            "description" : "Reply type of the thread reply feed item. The field is not persisted in storage. It's populated when constructing Activity Feed payload.",
            "enum" : [ "UNSPECIFIED", "ROOT", "FOLLOWER" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention" : {
        "description" : "Existence of this attribute indicates that the AF item is for a user mention item.",
        "properties" : {
          "type" : {
            "description" : "User mention type",
            "enum" : [ "TYPE_UNSPECIFIED", "DIRECT", "ALL" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedChatItemGroupInfo" : {
        "description" : "Information about the space that the item originated from. This will be used to display Activity Feed items from rooms, and only contain the necessary information, such as the space name and group attributes. NEXT TAG: 6",
        "properties" : {
          "attributeCheckerGroupType" : {
            "description" : "This is needed to determine what type of group the source message came from to support click-to-source.",
            "enum" : [ "ATTRIBUTE_CHECKER_GROUP_TYPE_UNSPECIFIED", "ONE_TO_ONE_HUMAN_DM", "ONE_TO_ONE_BOT_DM", "IMMUTABLE_MEMBERSHIP_GROUP_DM", "FLAT_ROOM", "THREADED_ROOM", "IMMUTABLE_MEMBERSHIP_HUMAN_DM", "POST_ROOM", "ACTIVITY_FEED" ],
            "type" : "string"
          },
          "groupName" : {
            "type" : "string"
          },
          "groupReadTimeUsec" : {
            "description" : "Timestamp of when the group containing the message has been read by the user.",
            "format" : "int64",
            "type" : "string"
          },
          "inlineThreadingEnabled" : {
            "description" : "Indicates whether the group has inline replies enabled. If enabled, clients will render the space with inline replies.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedContentReportType" : {
        "description" : "Denotes a type of content report a user can send.",
        "properties" : {
          "systemViolation" : {
            "description" : "Required. Google-defined system violation, covering the most common violations.",
            "enum" : [ "VIOLATION_UNSPECIFIED", "HARASSMENT", "DISCRIMINATION", "EXPLICIT_CONTENT", "SPAM", "CONFIDENTIAL_INFORMATION", "SENSITIVE_INFORMATION", "FRAUD", "MALWARE", "ILLEGAL_ACTIVITIES", "OTHER" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedCustomEmoji" : {
        "description" : "Proto representation of a custom emoji. May be used in both APIs and in Spanner, but certain fields should be restricted to one or the other. See the per-field documentation for details. NEXT_TAG: 14",
        "properties" : {
          "blobId" : {
            "description" : "ID for the underlying image data in Blobstore. This field should *only* be present in Spanner or within the server, but should not be exposed in public APIs.",
            "type" : "string"
          },
          "contentType" : {
            "description" : "Content type of the file used to upload the emoji. Used for takeout. Written to Spanner when the emoji is created.",
            "type" : "string"
          },
          "createTimeMicros" : {
            "description" : "Time when the Emoji was created, in microseconds. This field may be present in Spanner, within the server, or in public APIs.",
            "format" : "int64",
            "type" : "string"
          },
          "creatorUserId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "deleteTimeMicros" : {
            "description" : "Time when the emoji was deleted, in microseconds. This field may be present in Spanner, within the server, or in public APIs. Only present if the emoji has been deleted.",
            "format" : "int64",
            "type" : "string"
          },
          "ephemeralUrl" : {
            "description" : "Output only. A short-lived URL clients can use for directly accessing a custom emoji image. This field is intended for API consumption, and should *never* be persisted to Spanner.",
            "readOnly" : true,
            "type" : "string"
          },
          "ownerCustomerId" : {
            "$ref" : "#/components/schemas/CustomerId"
          },
          "readToken" : {
            "description" : "Opaque token that clients use to construct the URL for accessing the custom emoji’s image data. This field is intended for API consumption, and should *never* be persisted to Spanner.",
            "type" : "string"
          },
          "shortcode" : {
            "description" : "User-provided, human-readable ID for the custom emoji. Users are expected to observe this field in the UI instead of the UUID. This shortcode should be unique within an organization, but has no global uniqueness guarantees, unlike the UUID. This field should *never* be persisted to Spanner.",
            "type" : "string"
          },
          "state" : {
            "description" : "Snapshot of the current state of the emoji, which may differ from the source-of-truth in the CustomEmojis table. This field should *never* be persisted to Spanner.",
            "enum" : [ "EMOJI_STATE_UNSPECIFIED", "EMOJI_ENABLED", "EMOJI_SYSTEM_DISABLED", "EMOJI_HIDDEN", "EMOJI_DELETED" ],
            "type" : "string"
          },
          "updateTimeMicros" : {
            "format" : "int64",
            "type" : "string"
          },
          "uuid" : {
            "description" : "Unique key for a custom emoji resource. Required. This field is *always* populated.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedDimension" : {
        "description" : "Dimension for the uploaded attachments.",
        "properties" : {
          "height" : {
            "format" : "int32",
            "type" : "integer"
          },
          "width" : {
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedDlpMetricsMetadata" : {
        "description" : "LINT.IfChange",
        "properties" : {
          "dlpStatus" : {
            "description" : "[required] Describes the DLP status of message send and attachment upload events.",
            "enum" : [ "DLP_STATUS_UNKNOWN", "DLP_DISABLED", "DLP_ENABLED_NO_RULE_FETCH", "DLP_ENABLED_RULES_FETCHED_NO_RULES", "DLP_ENABLED_RULES_FETCHED_NO_APPLICABLE_RULES", "DLP_ENABLED_RULES_FETCHED_AND_EVALUATED", "DLP_ENABLED_SCAN_TIMEOUT", "DLP_ENABLED_SCAN_FAILED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedDocument" : {
        "description" : "Data for rendering a document.",
        "properties" : {
          "fileId" : {
            "description" : "Unique file ID.",
            "type" : "string"
          },
          "justification" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedJustification"
          },
          "lastModifiedTime" : {
            "description" : "Time the document was last modified.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "mimeType" : {
            "description" : "Used to determine which icon to render (e.g. docs, slides, sheets)",
            "type" : "string"
          },
          "title" : {
            "description" : "Title of the document.",
            "type" : "string"
          },
          "url" : {
            "description" : "URL of the document.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedEmoji" : {
        "properties" : {
          "customEmoji" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCustomEmoji"
          },
          "unicode" : {
            "description" : "A basic emoji represented by a unicode string.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedFindDocumentSuggestion" : {
        "description" : "Data for a FindDocument suggestion type.",
        "properties" : {
          "documentSuggestions" : {
            "description" : "List of documents to render as suggestions.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteSharedDocument"
            },
            "type" : "array"
          },
          "showActionButtons" : {
            "description" : "Whether to show the action buttons in the card for the suggestions.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedGroupDetails" : {
        "description" : "NEXT TAG: 3 A GroupDetails proto will store the information pertaining to single Group.",
        "properties" : {
          "description" : {
            "description" : "A simple text that describes the purpose of a single Group, the general theme of the topics to be posted and/or the denominator of the Group participants.",
            "type" : "string"
          },
          "guidelines" : {
            "description" : "A simple text describing the rules and expectations from members when participating in conversation.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedGroupVisibility" : {
        "properties" : {
          "state" : {
            "enum" : [ "UNKNOWN", "PRIVATE", "PUBLIC" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedJustification" : {
        "description" : "Data for rendering a justification for a document.",
        "properties" : {
          "actionTime" : {
            "description" : "Time the action took place.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "actionType" : {
            "description" : "Type of action performed on the document.",
            "enum" : [ "ACTION_TYPE_UNSPECIFIED", "COMMENTED", "CREATED", "EDITED", "PRESENTED", "SHARED", "VIEWED", "COMMENT_RESOLVED", "SENT" ],
            "type" : "string"
          },
          "documentOwner" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedJustificationPerson"
          },
          "topics" : {
            "description" : "Words or phrases from the user's query that describes the document content. (Ex: Users query is \"Can you share the document about Bullseye?\" the extracted topic would be \"Bullseye\").",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedJustificationPerson" : {
        "description" : "Data for rendering a person associated with a document.",
        "properties" : {
          "isRecipient" : {
            "description" : "Whether the person is the recipient of the suggestions.",
            "type" : "boolean"
          },
          "user" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedMeetMetadata" : {
        "description" : "Metadata specific for a Meet call that are required to generate call artifacts.",
        "properties" : {
          "meetingCode" : {
            "description" : "Required. A globally unique code (e.g. \"cxv-zbgj-wzw\") that points to a meeting space. Note: Meeting codes may be regenerated, which will cause old meeting codes to become invalid.",
            "type" : "string"
          },
          "meetingUrl" : {
            "description" : "Required. A URL, in the format \"https://meet.google.com/*\" (e.g. https://meet.google.com/cxv-zbgj-wzw), to identify and access the meeting space.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedMessageInfo" : {
        "description" : "Information that references a Dynamite chat message. This is only used for Activity Feed messages.",
        "properties" : {
          "messageId" : {
            "$ref" : "#/components/schemas/MessageId"
          },
          "messageType" : {
            "description" : "The type of the source chat message.",
            "enum" : [ "MESSAGE_TYPE_UNSPECIFIED", "INLINE_REPLY" ],
            "type" : "string"
          },
          "topicReadTimeUsec" : {
            "description" : "Timestamp of when the topic containing the message has been read by the user. This is populated if the message references an inline reply, in which case the space may be marked as read but the topic still has unread messages.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedMessageIntegrationPayload" : {
        "description" : "The payload(restricted to 1P applications) to be stored with a specific message.",
        "properties" : {
          "projectNumber" : {
            "description" : "Pantheon project number used to identify the calling app.",
            "format" : "int64",
            "type" : "string"
          },
          "tasksMessageIntegrationPayload" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksMessageIntegrationPayload"
          },
          "type" : {
            "description" : "An enum indicating which 1P application's payload this is. This field is required to add 1P payload.",
            "enum" : [ "PAYLOAD_TYPE_UNSPECIFIED", "TASKS" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedOrganizationInfo" : {
        "description" : "Contains info about the entity that something is, or is owned by.",
        "properties" : {
          "consumerInfo" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedOrganizationInfoConsumerInfo"
          },
          "customerInfo" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedOrganizationInfoCustomerInfo"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedOrganizationInfoConsumerInfo" : {
        "description" : "Intentionally empty. Used to disambiguate consumer and customer use cases in oneof below.",
        "type" : "object"
      },
      "AppsDynamiteSharedOrganizationInfoCustomerInfo" : {
        "properties" : {
          "customerId" : {
            "$ref" : "#/components/schemas/CustomerId"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedOriginAppSuggestion" : {
        "description" : "Stores the suggestion provided by apps/bots.",
        "properties" : {
          "appId" : {
            "$ref" : "#/components/schemas/AppId"
          },
          "cardClickSuggestion" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCardClickSuggestion"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedPhoneNumber" : {
        "properties" : {
          "type" : {
            "description" : "The phone number type, e.g., work, mobile, etc.",
            "type" : "string"
          },
          "value" : {
            "description" : "The actual phone number.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedReaction" : {
        "properties" : {
          "count" : {
            "description" : "The total number of users who have reacted.",
            "format" : "int32",
            "type" : "integer"
          },
          "createTimestamp" : {
            "description" : "When the first emoji of this type was added.",
            "format" : "int64",
            "type" : "string"
          },
          "currentUserParticipated" : {
            "description" : "Whether the current user reacted using this emoji. Note: Unlike most properties of messages, this is different per-user.",
            "type" : "boolean"
          },
          "emoji" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedEmoji"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedRetentionSettings" : {
        "description" : "The settings of retention period of a message or topic.",
        "properties" : {
          "expiryTimestamp" : {
            "description" : "The timestamp after which the message/topic should be removed, in microseconds since the epoch, when state == EPHEMERAL_ONE_DAY. The value should not be set in other cases.",
            "format" : "int64",
            "type" : "string"
          },
          "state" : {
            "description" : "The retention state.",
            "enum" : [ "UNKNOWN_RETENTION_STATE", "PERMANENT", "EPHEMERAL_ONE_DAY" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedSegmentedMembershipCount" : {
        "description" : "Contains info on membership count for member types: HUMAN_USER, APP_USER & ROSTER_MEMBER different states: INVITED, JOINED",
        "properties" : {
          "memberType" : {
            "enum" : [ "MEMBER_TYPE_UNSPECIFIED", "HUMAN_USER", "ROSTER_MEMBER" ],
            "type" : "string"
          },
          "membershipCount" : {
            "description" : "count of members with given type and state",
            "format" : "int32",
            "type" : "integer"
          },
          "membershipState" : {
            "enum" : [ "MEMBER_UNKNOWN", "MEMBER_INVITED", "MEMBER_JOINED", "MEMBER_NOT_A_MEMBER", "MEMBER_FAILED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedSegmentedMembershipCounts" : {
        "properties" : {
          "value" : {
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteSharedSegmentedMembershipCount"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedSpaceInfo" : {
        "description" : "Defines the representation of a single matching space.",
        "properties" : {
          "avatarInfo" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAvatarInfo"
          },
          "avatarUrl" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "groupId" : {
            "$ref" : "#/components/schemas/GroupId"
          },
          "inviterEmail" : {
            "description" : "The email address of the user that invited the calling user to the room, if available. This field will only be populated for direct invites, it will be empty if the user was indirectly invited to the group.",
            "type" : "string"
          },
          "isExternal" : {
            "description" : "Whether this is a space that enables guest access",
            "type" : "boolean"
          },
          "name" : {
            "type" : "string"
          },
          "numMembers" : {
            "description" : "Deprecated. Use segmented_membership_counts instead which also includes other counts such as rosters.",
            "format" : "int32",
            "type" : "integer"
          },
          "segmentedMembershipCounts" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedSegmentedMembershipCounts"
          },
          "userMembershipState" : {
            "description" : "searching user's membership state in this space",
            "enum" : [ "MEMBER_UNKNOWN", "MEMBER_INVITED", "MEMBER_JOINED", "MEMBER_NOT_A_MEMBER", "MEMBER_FAILED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedTasksAnnotationData" : {
        "description" : "This is the internal version of the API proto at google3/google/chat/v1/gsuite_message_integration.proto",
        "properties" : {
          "assigneeChange" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksAnnotationDataAssigneeChange"
          },
          "completionChange" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksAnnotationDataCompletionChange"
          },
          "creation" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksAnnotationDataCreation"
          },
          "deletionChange" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksAnnotationDataDeletionChange"
          },
          "taskId" : {
            "description" : "ID of task. Will be used to create deep links to Tasks.",
            "type" : "string"
          },
          "taskProperties" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksAnnotationDataTaskProperties"
          },
          "userDefinedMessage" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedTasksAnnotationDataAssigneeChange" : {
        "properties" : {
          "oldAssignee" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedTasksAnnotationDataCompletionChange" : {
        "type" : "object"
      },
      "AppsDynamiteSharedTasksAnnotationDataCreation" : {
        "type" : "object"
      },
      "AppsDynamiteSharedTasksAnnotationDataDeletionChange" : {
        "type" : "object"
      },
      "AppsDynamiteSharedTasksAnnotationDataTaskProperties" : {
        "description" : "All relevant task properties for a Chat message.",
        "properties" : {
          "assignee" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "completed" : {
            "description" : "Whether the task is marked as completed.",
            "type" : "boolean"
          },
          "deleted" : {
            "description" : "Whether the task is marked as deleted.",
            "type" : "boolean"
          },
          "description" : {
            "description" : "The description of the task. If Task original description's length is greater than 1024, then Task BE sends the truncated description to Dynamite Integration Server.",
            "type" : "string"
          },
          "startDate" : {
            "$ref" : "#/components/schemas/Date"
          },
          "startTime" : {
            "description" : "Set if the task has both a date and a time. Source of truth in Tasks BE: http://shortn/_u6cr0F5ttE",
            "format" : "google-datetime",
            "type" : "string"
          },
          "title" : {
            "description" : "The title of the task.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage" : {
        "description" : "Used for task card attachments on custom user messages that should be kept as is without generating an i18n event message, e.g. the user starts a conversation from an existing task. IMPORTANT: please don't populate this field yet as it could break existing flows until it's implemented. See code at http://shortn/_CM74CdENMx used by http://shortn/_5o85POJY8Q.",
        "type" : "object"
      },
      "AppsDynamiteSharedTasksMessageIntegrationPayload" : {
        "description" : "A payload containing Tasks metadata for rendering a live card. Currently not used by the Tasks integration.",
        "type" : "object"
      },
      "AppsDynamiteSharedUserBlockRelationship" : {
        "description" : "User-block relationship",
        "properties" : {
          "hasBlockedRequester" : {
            "type" : "boolean"
          },
          "isBlockedByRequester" : {
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteSharedVideoReference" : {
        "description" : "Reference to a transcoded video attachment.",
        "properties" : {
          "format" : {
            "description" : "Available transcode format. Value is defined in video/storage/proto/content_header.proto",
            "items" : {
              "format" : "int32",
              "type" : "integer"
            },
            "type" : "array"
          },
          "status" : {
            "description" : "Transcode status",
            "enum" : [ "UNKNOWN_STATUS", "SUCCESS", "ERROR", "NOT_APPLICABLE", "THUMBNAIL_SUCCESS", "GO_LIVE_SUCCESS" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageAction" : {
        "description" : "An action that describes the behavior when the form is submitted. For example, an Apps Script can be invoked to handle the form.",
        "properties" : {
          "function" : {
            "description" : "Apps Script function to invoke when the containing element is clicked/activated.",
            "type" : "string"
          },
          "interaction" : {
            "enum" : [ "INTERACTION_UNSPECIFIED", "OPEN_DIALOG" ],
            "type" : "string"
          },
          "loadIndicator" : {
            "enum" : [ "SPINNER", "NONE" ],
            "type" : "string"
          },
          "parameters" : {
            "description" : "List of action parameters.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageActionActionParameter"
            },
            "type" : "array"
          },
          "persistValues" : {
            "description" : "Indicates whether form values persist after the action. The default value is `false`. If `true`, form values remain after the action is triggered. When using [LoadIndicator.NONE](workspace/add-ons/reference/rpc/google.apps.card.v1#loadindicator) for actions, `persist_values` = `true`is recommended, as it ensures that any changes made by the user after form or on change actions are sent to the server are not overwritten by the response. If `false`, the form values are cleared when the action is triggered. When `persist_values` is set to `false`, it is strongly recommended that the card use [LoadIndicator.SPINNER](workspace/add-ons/reference/rpc/google.apps.card.v1#loadindicator) for all actions, as this locks the UI to ensure no changes are made by the user while the action is being processed.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageActionActionParameter" : {
        "description" : "List of string parameters to supply when the action method is invoked. For example, consider three snooze buttons: snooze now, snooze 1 day, snooze next week. You might use action method = snooze(), passing the snooze type and snooze time in the list of string parameters.",
        "properties" : {
          "key" : {
            "description" : "The name of the parameter for the action script.",
            "type" : "string"
          },
          "value" : {
            "description" : "The value of the parameter.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageBorderStyle" : {
        "description" : "Represents the complete border style applied to widgets.",
        "properties" : {
          "cornerRadius" : {
            "description" : "The corner radius for the border.",
            "format" : "int32",
            "type" : "integer"
          },
          "strokeColor" : {
            "$ref" : "#/components/schemas/Color"
          },
          "type" : {
            "description" : "The border type.",
            "enum" : [ "BORDER_TYPE_UNSPECIFIED", "NO_BORDER", "STROKE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageButton" : {
        "description" : "A button. Can be a text button or an image button.",
        "properties" : {
          "altText" : {
            "description" : "The alternative text used for accessibility. Has no effect when an icon is set; use `icon.alt_text` instead.",
            "type" : "string"
          },
          "color" : {
            "$ref" : "#/components/schemas/Color"
          },
          "disabled" : {
            "description" : "If true, the button is displayed in a disabled state and doesn't respond to user actions.",
            "type" : "boolean"
          },
          "icon" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageIcon"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOnClick"
          },
          "text" : {
            "description" : "The text of the button.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageButtonList" : {
        "description" : "A list of buttons layed out horizontally.",
        "properties" : {
          "buttons" : {
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageButton"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageCard" : {
        "description" : "A card is a UI element that can contain UI widgets such as text and images. For more information, see Cards . For example, the following JSON creates a card that has a header with the name, position, icons, and link for a contact, followed by a section with contact information like email and phone number. ``` { \"header\": { \"title\": \"Heba Salam\", \"subtitle\": \"Software Engineer\", \"imageStyle\": \"ImageStyle.AVATAR\", \"imageUrl\": \"https://example.com/heba_salam.png\", \"imageAltText\": \"Avatar for Heba Salam\" }, \"sections\" : [ { \"header\": \"Contact Info\", \"widgets\": [ { \"decorated_text\": { \"icon\": { \"knownIcon\": \"EMAIL\" }, \"content\": \"heba.salam@example.com\" } }, { \"decoratedText\": { \"icon\": { \"knownIcon\": \"PERSON\" }, \"content\": \"Online\" } }, { \"decoratedText\": { \"icon\": { \"knownIcon\": \"PHONE\" }, \"content\": \"+1 (555) 555-1234\" } }, { \"buttons\": [ { \"textButton\": { \"text\": \"Share\", }, \"onClick\": { \"openLink\": { \"url\": \"https://example.com/share\" } } }, { \"textButton\": { \"text\": \"Edit\", }, \"onClick\": { \"action\": { \"function\": \"goToView\", \"parameters\": [ { \"key\": \"viewType\", \"value\": \"EDIT\" } ], \"loadIndicator\": \"LoadIndicator.SPINNER\" } } } ] } ], \"collapsible\": true, \"uncollapsibleWidgetsCount\": 3 } ], \"cardActions\": [ { \"actionLabel\": \"Send Feedback\", \"onClick\": { \"openLink\": { \"url\": \"https://example.com/feedback\" } } } ], \"name\": \"contact-card-K3wB6arF2H9L\" } ```",
        "properties" : {
          "cardActions" : {
            "description" : "The actions of this card. They are added to a card's generated toolbar menu. For example, the following JSON constructs a card action menu with Settings and Send Feedback options: ``` \"card_actions\": [ { \"actionLabel\": \"Setting\", \"onClick\": { \"action\": { \"functionName\": \"goToView\", \"parameters\": [ { \"key\": \"viewType\", \"value\": \"SETTING\" } ], \"loadIndicator\": \"LoadIndicator.SPINNER\" } } }, { \"actionLabel\": \"Send Feedback\", \"onClick\": { \"openLink\": { \"url\": \"https://example.com/feedback\" } } } ] ```",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageCardCardAction"
            },
            "type" : "array"
          },
          "header" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageCardCardHeader"
          },
          "name" : {
            "description" : "Name of the card, which is used as a identifier for the card in card navigation.",
            "type" : "string"
          },
          "sections" : {
            "description" : "Sections are separated by a line divider.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageCardSection"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageCardCardAction" : {
        "description" : "A card action is the action associated with the card. For example, an invoice card might include actions such as delete invoice, email invoice, or open the invoice in a browser.",
        "properties" : {
          "actionLabel" : {
            "description" : "The label that displays as the action menu item.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOnClick"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageCardCardHeader" : {
        "properties" : {
          "imageAltText" : {
            "description" : "The alternative text of this image which is used for accessibility.",
            "type" : "string"
          },
          "imageType" : {
            "description" : "The image's type.",
            "enum" : [ "SQUARE", "CIRCLE" ],
            "type" : "string"
          },
          "imageUrl" : {
            "description" : "The URL of the image in the card header.",
            "type" : "string"
          },
          "subtitle" : {
            "description" : "The subtitle of the card header.",
            "type" : "string"
          },
          "title" : {
            "description" : "The title of the card header. The title must be specified. The header has a fixed height: if both a title and subtitle are specified, each takes up one line. If only the title is specified, it takes up both lines.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageCardSection" : {
        "description" : "A section contains a collection of widgets that are rendered vertically in the order that they are specified. Across all platforms, cards have a narrow fixed width, so there is currently no need for layout properties, for example, float.",
        "properties" : {
          "collapsible" : {
            "description" : "Indicates whether this section is collapsible. If a section is collapsible, the description must be given.",
            "type" : "boolean"
          },
          "header" : {
            "description" : "The header of the section. Formatted text is supported.",
            "type" : "string"
          },
          "uncollapsibleWidgetsCount" : {
            "description" : "The number of uncollapsible widgets. For example, when a section contains five widgets and the `numUncollapsibleWidget` is set to `2`, the first two widgets are always shown and the last three are collapsed as default. The `numUncollapsibleWidget` is taken into account only when collapsible is set to `true`.",
            "format" : "int32",
            "type" : "integer"
          },
          "widgets" : {
            "description" : "A section must contain at least 1 widget.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageWidget"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageColumns" : {
        "description" : "Represents a Columns widget that displays a single row of columns.",
        "properties" : {
          "columnItems" : {
            "description" : "Each card supports up to 2 columns.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageColumnsColumn"
            },
            "type" : "array"
          },
          "wrapStyle" : {
            "description" : "Controls how the column resizes based on screen width.",
            "enum" : [ "WRAP_STYLE_UNSPECIFIED", "NOWRAP", "WRAP" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageColumnsColumn" : {
        "description" : "Represents a Column that consists of widgets stacked vertically.",
        "properties" : {
          "horizontalAlignment" : {
            "description" : "The horizontal alignment of the column.",
            "enum" : [ "HORIZONTAL_ALIGNMENT_UNSPECIFIED", "START", "CENTER", "END" ],
            "type" : "string"
          },
          "horizontalSizeStyle" : {
            "description" : "Specifies how the column content is sized horizontally.",
            "enum" : [ "HORIZONTAL_SIZE_STYLE_UNSPECIFIED", "FILL_AVAILABLE_SPACE", "FILL_MINIMUM_SPACE" ],
            "type" : "string"
          },
          "verticalAlignment" : {
            "description" : "The vertical alignment of the column.",
            "enum" : [ "VERTICAL_ALIGNMENT_UNSPECIFIED", "CENTER", "TOP", "BOTTOM" ],
            "type" : "string"
          },
          "widgets" : {
            "description" : "LINT.ThenChange(//depot/google3/google/apps/card/v1/card.proto) Array of widgets included in the column.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageColumnsColumnWidgets"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageColumnsColumnWidgets" : {
        "description" : "LINT.IfChange The `column` widget can contain these widgets.",
        "properties" : {
          "buttonList" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageButtonList"
          },
          "dateTimePicker" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageDateTimePicker"
          },
          "decoratedText" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageDecoratedText"
          },
          "image" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageImage"
          },
          "selectionInput" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageSelectionInput"
          },
          "textInput" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageTextInput"
          },
          "textParagraph" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageTextParagraph"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageDateTimePicker" : {
        "description" : "The widget that lets users to specify a date and time.",
        "properties" : {
          "label" : {
            "description" : "The label for the field that displays to the user.",
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the text input that's used in formInput, and uniquely identifies this input.",
            "type" : "string"
          },
          "onChangeAction" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageAction"
          },
          "timezoneOffsetDate" : {
            "description" : "The number representing the time zone offset from UTC, in minutes. If set, the `value_ms_epoch` is displayed in the specified time zone. If not set, it uses the user's time zone setting on the client side.",
            "format" : "int32",
            "type" : "integer"
          },
          "type" : {
            "description" : "The type of the date/time picker.",
            "enum" : [ "DATE_AND_TIME", "DATE_ONLY", "TIME_ONLY" ],
            "type" : "string"
          },
          "valueMsEpoch" : {
            "description" : "The value to display as the default value before user input or previous user input. It is represented in milliseconds (Epoch time). For `DATE_AND_TIME` type, the full epoch value is used. For `DATE_ONLY` type, only date of the epoch time is used. For `TIME_ONLY` type, only time of the epoch time is used. For example, you can set epoch time to `3 * 60 * 60 * 1000` to represent 3am.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageDecoratedText" : {
        "description" : "A widget that displays text with optional decorations such as a label above or below the text, an icon in front of the text, a selection widget or a button after the text.",
        "properties" : {
          "bottomLabel" : {
            "description" : "The formatted text label that shows below the main text.",
            "type" : "string"
          },
          "button" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageButton"
          },
          "endIcon" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageIcon"
          },
          "icon" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageIcon"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOnClick"
          },
          "startIcon" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageIcon"
          },
          "switchControl" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageDecoratedTextSwitchControl"
          },
          "text" : {
            "description" : "Required. The main widget formatted text. See Text formatting for details.",
            "type" : "string"
          },
          "topLabel" : {
            "description" : "The formatted text label that shows above the main text.",
            "type" : "string"
          },
          "wrapText" : {
            "description" : "The wrap text setting. If `true`, the text is wrapped and displayed in multiline. Otherwise, the text is truncated.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageDecoratedTextSwitchControl" : {
        "properties" : {
          "controlType" : {
            "description" : "The control type, either switch or checkbox.",
            "enum" : [ "SWITCH", "CHECKBOX", "CHECK_BOX" ],
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the switch widget that's used in formInput.",
            "type" : "string"
          },
          "onChangeAction" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageAction"
          },
          "selected" : {
            "description" : "If the switch is selected.",
            "type" : "boolean"
          },
          "value" : {
            "description" : "The value is what is passed back in the callback.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageDivider" : {
        "description" : "A divider that appears in between widgets.",
        "type" : "object"
      },
      "AppsDynamiteStorageGrid" : {
        "description" : "Represents a Grid widget that displays items in a configurable grid layout.",
        "properties" : {
          "borderStyle" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageBorderStyle"
          },
          "columnCount" : {
            "description" : "The number of columns to display in the grid. A default value is used if this field isn't specified, and that default value is different depending on where the grid is shown (dialog versus companion).",
            "format" : "int32",
            "type" : "integer"
          },
          "items" : {
            "description" : "The items to display in the grid.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageGridGridItem"
            },
            "type" : "array"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOnClick"
          },
          "title" : {
            "description" : "The text that displays in the grid header.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageGridGridItem" : {
        "description" : "Represents a single item in the grid layout.",
        "properties" : {
          "id" : {
            "description" : "A user-specified identifier for this grid item. This identifier is returned in the parent Grid's onClick callback parameters.",
            "type" : "string"
          },
          "image" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageImageComponent"
          },
          "layout" : {
            "description" : "The layout to use for the grid item.",
            "enum" : [ "GRID_ITEM_LAYOUT_UNSPECIFIED", "TEXT_BELOW", "TEXT_ABOVE" ],
            "type" : "string"
          },
          "subtitle" : {
            "description" : "The grid item's subtitle.",
            "type" : "string"
          },
          "textAlignment" : {
            "description" : "The horizontal alignment of the grid item's text.",
            "enum" : [ "HORIZONTAL_ALIGNMENT_UNSPECIFIED", "START", "CENTER", "END" ],
            "type" : "string"
          },
          "title" : {
            "description" : "The grid item's title.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageIcon" : {
        "properties" : {
          "altText" : {
            "description" : "The description of the icon, used for accessibility. The default value is provided if you don't specify one.",
            "type" : "string"
          },
          "iconUrl" : {
            "description" : "The icon specified by a URL.",
            "type" : "string"
          },
          "imageType" : {
            "description" : "The crop style applied to the image. In some cases, applying a `CIRCLE` crop causes the image to be drawn larger than a standard icon.",
            "enum" : [ "SQUARE", "CIRCLE" ],
            "type" : "string"
          },
          "knownIcon" : {
            "description" : "The icon specified by the string name of a list of known icons",
            "type" : "string"
          },
          "materialIcon" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageMaterialIcon"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageImage" : {
        "description" : "An image that is specified by a URL and can have an onClick action.",
        "properties" : {
          "altText" : {
            "description" : "The alternative text of this image, used for accessibility.",
            "type" : "string"
          },
          "imageUrl" : {
            "description" : "An image URL.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOnClick"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageImageComponent" : {
        "properties" : {
          "altText" : {
            "description" : "The accessibility label for the image.",
            "type" : "string"
          },
          "borderStyle" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageBorderStyle"
          },
          "cropStyle" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageImageCropStyle"
          },
          "imageUri" : {
            "description" : "The image URL.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageImageCropStyle" : {
        "description" : "Represents the crop style applied to an image.",
        "properties" : {
          "aspectRatio" : {
            "description" : "The aspect ratio to use if the crop type is `RECTANGLE_CUSTOM`.",
            "format" : "double",
            "type" : "number"
          },
          "type" : {
            "description" : "The crop type.",
            "enum" : [ "IMAGE_CROP_TYPE_UNSPECIFIED", "SQUARE", "CIRCLE", "RECTANGLE_CUSTOM", "RECTANGLE_4_3" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageMaterialIcon" : {
        "description" : "A [Google Font Icon](https://fonts.google.com/icons), which includes over 2500+ options. For example, to display a [check box icon](https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck_box%3AFILL%400%3Bwght%40400%3BGRAD%400%3Bopsz%4048) with customized weight and grade, write { \"name\": \"check_box\", \"fill\": true, \"weight\": 300, \"grade\": -25 }",
        "properties" : {
          "fill" : {
            "description" : "Whether it renders a filled icon. Default value is false. See Customization in [Google Font Icon](https://fonts.google.com/icons) for details.",
            "type" : "boolean"
          },
          "grade" : {
            "description" : "Weight and grade affect a symbol’s thickness. Adjustments to grade are more granular than adjustments to weight and have a small impact on the size of the symbol. Choose from {-25, 0, 200}. If absent, default value is 0. If any other value is specified, a broken image icon will be displayed. See Customization in [Google Font Icon](https://fonts.google.com/icons) for details.",
            "format" : "int32",
            "type" : "integer"
          },
          "name" : {
            "description" : "The icon name defined in the [Google Material Icon](https://fonts.google.com/icons) in snake_case. e.g. \"check_box\". Any invalid name will be trimmed as empty string result in the icon falied to render.",
            "type" : "string"
          },
          "weight" : {
            "description" : "The stroke weight of the icon. Choose from {100, 200, 300, 400, 500, 600, 700}. If absent, default value is 400. If any other value is specified, a broken image icon will be displayed. See Customization in [Google Font Icon](https://fonts.google.com/icons) for details.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageOnClick" : {
        "properties" : {
          "action" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageAction"
          },
          "hostAppAction" : {
            "$ref" : "#/components/schemas/HostAppActionMarkup"
          },
          "openDynamicLinkAction" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageAction"
          },
          "openLink" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOpenLink"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageOpenLink" : {
        "properties" : {
          "appUri" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOpenLinkAppUri"
          },
          "onClose" : {
            "enum" : [ "NOTHING", "RELOAD" ],
            "type" : "string"
          },
          "openAs" : {
            "enum" : [ "FULL_SIZE", "OVERLAY" ],
            "type" : "string"
          },
          "url" : {
            "description" : "The URL to open.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageOpenLinkAppUri" : {
        "description" : "Represents the platform specific uri/intent to open for each client.",
        "properties" : {
          "androidIntent" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageOpenLinkAppUriIntent"
          },
          "companionUri" : {
            "description" : "A companion uri string to be opened in the chat companion window. on the web.",
            "type" : "string"
          },
          "iosUri" : {
            "description" : "A uri string to be opened in the corresponding iOS hosting app.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageOpenLinkAppUriIntent" : {
        "description" : "Android intent.",
        "properties" : {
          "extraData" : {
            "description" : "A list of extra data for the android intent. For example, for a calendar event edit intent, the event title information can be passed as extra data.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageOpenLinkAppUriIntentExtraData"
            },
            "type" : "array"
          },
          "intentAction" : {
            "description" : "An android intent action string for the {@link android.content.Intent} object. For example: for the view intent action type, a valid value will be android.content.Intent.ACTION_VIEW.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageOpenLinkAppUriIntentExtraData" : {
        "description" : "Extra data for an android intent. Valid keys are defined in the hosting app contract.",
        "properties" : {
          "key" : {
            "description" : "A key for the intent extra data.",
            "type" : "string"
          },
          "value" : {
            "description" : "Value for the given extra data key.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageSelectionInput" : {
        "description" : "A widget that creates a UI item (for example, a drop-down list) with options for users to select.",
        "properties" : {
          "items" : {
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageSelectionInputSelectionItem"
            },
            "type" : "array"
          },
          "label" : {
            "description" : "The label displayed ahead of the switch control.",
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the text input which is used in formInput.",
            "type" : "string"
          },
          "onChangeAction" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageAction"
          },
          "type" : {
            "enum" : [ "CHECK_BOX", "RADIO_BUTTON", "SWITCH", "DROPDOWN", "MULTI_SELECT" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageSelectionInputSelectionItem" : {
        "description" : "The item in the switch control. A radio button, at most one of the items is selected.",
        "properties" : {
          "selected" : {
            "description" : "If more than one item is selected for `RADIO_BUTTON` and `DROPDOWN`, the first selected item is treated as selected and the ones after are ignored.",
            "type" : "boolean"
          },
          "text" : {
            "description" : "The text to be displayed.",
            "type" : "string"
          },
          "value" : {
            "description" : "The value associated with this item. The client should use this as a form input value.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageSuggestions" : {
        "description" : "A container wrapping elements necessary for showing suggestion items used in text input autocomplete.",
        "properties" : {
          "items" : {
            "description" : "A list of suggestions items which will be used in are used in autocomplete.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteStorageSuggestionsSuggestionItem"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageSuggestionsSuggestionItem" : {
        "description" : "A suggestion item. Only supports text for now.",
        "properties" : {
          "text" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageTextInput" : {
        "description" : "A text input is a UI item where users can input text. A text input can also have an onChange action and suggestions.",
        "properties" : {
          "autoCompleteAction" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageAction"
          },
          "hintText" : {
            "description" : "The hint text.",
            "type" : "string"
          },
          "initialSuggestions" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageSuggestions"
          },
          "label" : {
            "description" : "At least one of label and hintText must be specified.",
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the text input which is used in formInput.",
            "type" : "string"
          },
          "onChangeAction" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageAction"
          },
          "type" : {
            "description" : "The style of the text, for example, a single line or multiple lines.",
            "enum" : [ "SINGLE_LINE", "MULTIPLE_LINE" ],
            "type" : "string"
          },
          "value" : {
            "description" : "The default value when there is no input from the user.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageTextParagraph" : {
        "description" : "A paragraph of text that supports formatting. See [Text formatting](workspace/add-ons/concepts/widgets#text_formatting\") for details.",
        "properties" : {
          "text" : {
            "description" : "The text that's shown in the widget.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteStorageWidget" : {
        "description" : "A widget is a UI element that presents texts, images, etc.",
        "properties" : {
          "buttonList" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageButtonList"
          },
          "columns" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageColumns"
          },
          "dateTimePicker" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageDateTimePicker"
          },
          "decoratedText" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageDecoratedText"
          },
          "divider" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageDivider"
          },
          "grid" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageGrid"
          },
          "horizontalAlignment" : {
            "description" : "The horizontal alignment of this widget.",
            "enum" : [ "HORIZONTAL_ALIGNMENT_UNSPECIFIED", "START", "CENTER", "END" ],
            "type" : "string"
          },
          "image" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageImage"
          },
          "selectionInput" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageSelectionInput"
          },
          "textInput" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageTextInput"
          },
          "textParagraph" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageTextParagraph"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteV1ApiCompatV1Action" : {
        "description" : "Interactive objects inside a message. Documentation: - https://api.slack.com/docs/message-buttons",
        "properties" : {
          "confirm" : {
            "$ref" : "#/components/schemas/AppsDynamiteV1ApiCompatV1ActionConfirm"
          },
          "name" : {
            "description" : "Unique identifier for this action.",
            "type" : "string"
          },
          "style" : {
            "description" : "Button style (\"default\", \"primary\", or \"danger\").",
            "type" : "string"
          },
          "text" : {
            "description" : "User-facing label for the action.",
            "type" : "string"
          },
          "type" : {
            "description" : "Action type - currently only \"button\".",
            "type" : "string"
          },
          "value" : {
            "description" : "Payload for this action. Will be sent to the action handler along with name.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteV1ApiCompatV1ActionConfirm" : {
        "description" : "Confirmation dialog config.",
        "properties" : {
          "dismiss_text" : {
            "description" : "\"Cancel\" button label.",
            "type" : "string"
          },
          "ok_text" : {
            "description" : "\"OK\" button label.",
            "type" : "string"
          },
          "text" : {
            "description" : "Confirmation dialog body text.",
            "type" : "string"
          },
          "title" : {
            "description" : "Confirmation dialog title.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteV1ApiCompatV1Attachment" : {
        "description" : "Richly formatted attachments. Documentation: - https://api.slack.com/docs/message-attachments",
        "properties" : {
          "actions" : {
            "description" : "Array of actions (currently only buttons).",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteV1ApiCompatV1Action"
            },
            "type" : "array"
          },
          "attachment_type" : {
            "description" : "Undocumented - used in interactive button examples. The only valid value appears to be \"default\".",
            "type" : "string"
          },
          "author_icon" : {
            "description" : "Avatar URL for the user.",
            "type" : "string"
          },
          "author_link" : {
            "description" : "URL that the user name should link to.",
            "type" : "string"
          },
          "author_name" : {
            "description" : "User name to display as the author of the message.",
            "type" : "string"
          },
          "callback_id" : {
            "description" : "Unique identifier for the collection of buttons within this attachment. Will be sent back to the action handler URL when a button is clicked.",
            "type" : "string"
          },
          "color" : {
            "description" : "A color \"bar\" to display to the left of the attachment.",
            "type" : "string"
          },
          "fallback" : {
            "description" : "Fallback plain-text string for clients that don't support attachments.",
            "type" : "string"
          },
          "fields" : {
            "description" : "Columns of text inside the attachment body.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteV1ApiCompatV1Field"
            },
            "type" : "array"
          },
          "footer" : {
            "description" : "A string displayed at the bottom of the attachment.",
            "type" : "string"
          },
          "footer_icon" : {
            "description" : "Avatar URL displayed to the left of the footer.",
            "type" : "string"
          },
          "image_url" : {
            "description" : "URL of an image to display in an image chip.",
            "type" : "string"
          },
          "mrkdwn_in" : {
            "description" : "List of fields to apply formatting to.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "pretext" : {
            "description" : "A string to show above the attachment.",
            "type" : "string"
          },
          "text" : {
            "description" : "Main text.",
            "type" : "string"
          },
          "thumb_url" : {
            "description" : "URL of a thumbnail image to display to the right of the attachment body.",
            "type" : "string"
          },
          "title" : {
            "description" : "Title string of this attachment.",
            "type" : "string"
          },
          "title_link" : {
            "description" : "URL that the title string should link to.",
            "type" : "string"
          },
          "ts" : {
            "description" : "UNIX timestamp of the attachment.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "AppsDynamiteV1ApiCompatV1Field" : {
        "description" : "A column of text in an attachment. Documentation: - https://api.slack.com/docs/message-attachments",
        "properties" : {
          "short" : {
            "description" : "Whether the field can be shown side-by-side with another field.",
            "type" : "boolean"
          },
          "title" : {
            "description" : "The heading text, shown in bold.",
            "type" : "string"
          },
          "value" : {
            "description" : "The text value of the field.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup" : {
        "properties" : {
          "addonAttachments" : {
            "items" : {
              "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment" : {
        "properties" : {
          "iconUrl" : {
            "description" : "Link to the resource's icon.",
            "type" : "string"
          },
          "mimeType" : {
            "description" : "MIME type of the content in resource_url.",
            "type" : "string"
          },
          "resourceUrl" : {
            "type" : "string"
          },
          "title" : {
            "description" : "Title of the attachment.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup" : {
        "description" : "Markup that defines conference data associated to a Google Calendar event.",
        "properties" : {
          "conferenceId" : {
            "description" : "Unique identifier for this conference data. Maximum 512 characters long.",
            "type" : "string"
          },
          "conferenceSolutionId" : {
            "description" : "An identifier of the conferencing solution. Must match a value from the deployment's `calendar.conferenceSolution.id` field.",
            "type" : "string"
          },
          "entryPoints" : {
            "description" : "Entry points to the conference. Maximum 300 entry points are allowed.",
            "items" : {
              "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup"
            },
            "type" : "array"
          },
          "error" : {
            "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError"
          },
          "note" : {
            "description" : "Additional notes (such as instructions from the administrator, legal notices) to display to the user. Can contain HTML. Max length 2048 characters.",
            "type" : "string"
          },
          "parameters" : {
            "description" : "Additional add-on parameters. Maximum 300 parameters are allowed.",
            "items" : {
              "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup" : {
        "description" : "A way to join the conference.",
        "properties" : {
          "accessCode" : {
            "description" : "An access code for accessing the conference. Maximum 128 characters long.",
            "type" : "string"
          },
          "features" : {
            "description" : "Features of the entry point, such as being toll or toll-free. One entry point can have multiple features.",
            "items" : {
              "enum" : [ "UNKNOWN_FEATURE", "TOLL", "TOLL_FREE" ],
              "type" : "string"
            },
            "type" : "array"
          },
          "label" : {
            "description" : "The label of the entry point to display to the user. Maximum 512 characters long.",
            "type" : "string"
          },
          "meetingCode" : {
            "description" : "A meeting code for accessing the conference. Maximum 128 characters long.",
            "type" : "string"
          },
          "passcode" : {
            "description" : "A passcode for accessing the conference. Maximum 128 characters long.",
            "type" : "string"
          },
          "password" : {
            "description" : "A password for accessing the conference. Maximum 128 characters long.",
            "type" : "string"
          },
          "pin" : {
            "description" : "A PIN for accessing the conference. Maximum 128 characters long.",
            "type" : "string"
          },
          "regionCode" : {
            "description" : "The CLDR/ISO 3166 region code for the country associated with this entry point. Applicable only to `Type.PHONE`.",
            "type" : "string"
          },
          "type" : {
            "description" : "The type of the entry point. Required.",
            "enum" : [ "UNKNOWN", "VIDEO", "PHONE", "MORE", "SIP" ],
            "type" : "string"
          },
          "uri" : {
            "description" : "A URI for joining the conference. Supports tel: and http(s): and should be at most 1300 characters long. Required.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError" : {
        "description" : "Represents an error that occurred during conference creation.",
        "properties" : {
          "authenticationUrl" : {
            "description" : "If the error type is `AUTHENTICATION`, the add-on can provide a URL allowing users to log in. Maximum 1300 characters long.",
            "type" : "string"
          },
          "type" : {
            "description" : "The type of error. Required.",
            "enum" : [ "UNKNOWN", "AUTHENTICATION", "TEMPORARY", "PERMANENT", "PERMISSION_DENIED", "CONFERENCE_SOLUTION_FORBIDDEN" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter" : {
        "description" : "Solution-specific parameters that are persisted with the event data and, if an update or delete is needed, are passed to the add-on. For example: `[{key: 'sessionKey', value: '123'}, {key: 'meetingId', value: '456'}]`",
        "properties" : {
          "key" : {
            "description" : "The key of the parameter. Maximum 50 characters long. Required.",
            "type" : "string"
          },
          "value" : {
            "description" : "The value of the parameter. Maximum 1024 characters long. Required.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup" : {
        "properties" : {
          "addAttendeeEmails" : {
            "description" : "A list of attendees to add to the Google Calendar event.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup" : {
        "properties" : {
          "conferenceData" : {
            "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup"
          }
        },
        "type" : "object"
      },
      "Attachment" : {
        "description" : "Attachments that follow the message text.",
        "properties" : {
          "addOnData" : {
            "$ref" : "#/components/schemas/GoogleChatV1ContextualAddOnMarkup"
          },
          "appId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "attachmentId" : {
            "description" : "To identify an attachment within repeated in a message",
            "type" : "string"
          },
          "cardAddOnData" : {
            "$ref" : "#/components/schemas/AppsDynamiteStorageCard"
          },
          "deprecatedAddOnData" : {
            "$ref" : "#/components/schemas/ContextualAddOnMarkup"
          },
          "slackData" : {
            "$ref" : "#/components/schemas/AppsDynamiteV1ApiCompatV1Attachment"
          },
          "slackDataImageUrlHeight" : {
            "description" : "The height of image url as fetched by fife. This field is asynchronously filled.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "Attribute" : {
        "description" : "An Attribute is a piece of data attached an Item. Attributes are opaque to the Starbox and have no effect on, nor are they effected by, message storage, indexing, or search. ",
        "properties" : {
          "name" : {
            "description" : "The name of the attribute. Required - If a write is attempted with an empty string, the server will return an error.",
            "type" : "string"
          },
          "value" : {
            "$ref" : "#/components/schemas/CaribouAttributeValue"
          }
        },
        "type" : "object"
      },
      "AttributeRemoved" : {
        "description" : "An attribute was deleted from some (subset of the) messages in this thread.",
        "properties" : {
          "attributeId" : {
            "type" : "string"
          },
          "messageKeys" : {
            "items" : {
              "$ref" : "#/components/schemas/MultiKey"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AttributeSet" : {
        "description" : "An attribute was added to some (subset of the) messages in this thread.",
        "properties" : {
          "attributeId" : {
            "type" : "string"
          },
          "attributeValue" : {
            "description" : "The serialized attribute_value as persisted in the storage layer. The application is responsible for deserializing it to an Attribute.Value if appropriate.",
            "format" : "byte",
            "type" : "string"
          },
          "messageKeys" : {
            "items" : {
              "$ref" : "#/components/schemas/MultiKey"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "Attributes" : {
        "properties" : {
          "attribute" : {
            "items" : {
              "$ref" : "#/components/schemas/Attribute"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AuditLoggingSettings" : {
        "description" : "Represents the settings for Cloud audit logging",
        "properties" : {
          "logAdminReadActions" : {
            "description" : "Indicates whether audit logging is on/off for admin activity read APIs i.e. Get/List DataSources, Get/List SearchApplications etc.",
            "type" : "boolean"
          },
          "logDataReadActions" : {
            "description" : "Indicates whether audit logging is on/off for data access read APIs i.e. ListItems, GetItem etc.",
            "type" : "boolean"
          },
          "logDataWriteActions" : {
            "description" : "Indicates whether audit logging is on/off for data access write APIs i.e. IndexItem etc.",
            "type" : "boolean"
          },
          "project" : {
            "description" : "The resource name of the GCP Project to store audit logs. Cloud audit logging will be enabled after project_name has been updated through CustomerService. Format: projects/{project_id}",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AuthorizedItemId" : {
        "description" : "A combination of an identifier for a Drive resource (e.g. file, folder, or drive) and any secrets needed to access it. The secrets should never be logged, and this proto annotates those secret fields to ensure that they are not. Clients are encouraged to use this proto rather than defining their own, to ensure that secrets are correctly annotated.",
        "properties" : {
          "id" : {
            "description" : "Serialized ID of the Drive resource",
            "type" : "string"
          },
          "resourceKey" : {
            "description" : "Resource key of the Drive item. This field should be unset if, depending on the context, the item does not have a resource key, or if none was specified. This must never be logged.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "AutoComplete" : {
        "properties" : {
          "items" : {
            "items" : {
              "$ref" : "#/components/schemas/AutoCompleteItem"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "AutoCompleteItem" : {
        "properties" : {
          "text" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "BabelMessageProps" : {
        "description" : "Container for Babel (Hangouts Classic) only message properties. The properties here will not be consumed by Dynamite clients. They are relevant only for Hangouts Classic.",
        "properties" : {
          "clientGeneratedId" : {
            "description" : "Babel clients locally generate this ID to dedupe against the async fanout.",
            "format" : "int64",
            "type" : "string"
          },
          "contentExtension" : {
            "$ref" : "#/components/schemas/ChatContentExtension"
          },
          "deliveryMedium" : {
            "$ref" : "#/components/schemas/DeliveryMedium"
          },
          "eventId" : {
            "description" : "Primary identifier used by Hangouts Classic for its events (messages).",
            "type" : "string"
          },
          "messageContent" : {
            "$ref" : "#/components/schemas/ChatConserverMessageContent"
          },
          "wasUpdatedByBackfill" : {
            "description" : "Whether or not these message properties were backfilled by go/dinnertrain.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "BabelPlaceholderMetadata" : {
        "description" : "Annotation metadata for Babel-only items that signals which type of placeholder message should be displayed in Babel clients.",
        "properties" : {
          "deleteMetadata" : {
            "$ref" : "#/components/schemas/DeleteMetadata"
          },
          "editMetadata" : {
            "$ref" : "#/components/schemas/EditMetadata"
          },
          "hangoutVideoMetadata" : {
            "$ref" : "#/components/schemas/HangoutVideoEventMetadata"
          }
        },
        "type" : "object"
      },
      "BooleanOperatorOptions" : {
        "description" : "Used to provide a search operator for boolean properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.",
        "properties" : {
          "operatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the boolean property. For example, if operatorName is *closed* and the property's name is *isClosed*, then queries like *closed:<value>* show results only where the value of the property named *isClosed* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "BooleanPropertyOptions" : {
        "description" : "The options for boolean properties.",
        "properties" : {
          "operatorOptions" : {
            "$ref" : "#/components/schemas/BooleanOperatorOptions"
          }
        },
        "type" : "object"
      },
      "BorderStyle" : {
        "description" : "Represents a complete border style that can be applied to widgets.",
        "properties" : {
          "cornerRadius" : {
            "description" : "The corner radius for the border.",
            "format" : "int32",
            "type" : "integer"
          },
          "strokeColor" : {
            "description" : "The colors to use when the type is STROKE.",
            "type" : "string"
          },
          "type" : {
            "description" : "The border type.",
            "enum" : [ "BORDER_TYPE_NOT_SET", "NO_BORDER", "STROKE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "BotInfo" : {
        "description" : "Bot-specific profile information.",
        "properties" : {
          "appAllowlistStatus" : {
            "enum" : [ "UNSPECIFIED_STATUS", "ALLOWED", "ALL_APPS_DISABLED_BY_ADMIN", "APP_NOT_ALLOWLISTED_BY_ADMIN" ],
            "type" : "string"
          },
          "appId" : {
            "$ref" : "#/components/schemas/AppId"
          },
          "botAvatarUrl" : {
            "description" : "URL for the avatar picture of the User in dynamite. This field should be populated if the request is FetchBotCategories/ListBotCatalogEntries",
            "type" : "string"
          },
          "botName" : {
            "description" : "Non-unique, user-defined display name of the Bot. This field should be populated if the request is FetchBotCategories/ListBotCatalogEntries.",
            "type" : "string"
          },
          "description" : {
            "description" : "Short description for the bot.",
            "type" : "string"
          },
          "developerName" : {
            "description" : "Name of bot developer.",
            "type" : "string"
          },
          "marketPlaceBannerUrl" : {
            "description" : "URL for the banner image in GSuite Market Place. The banner will be 220x140.",
            "type" : "string"
          },
          "status" : {
            "description" : "Indicates whether bot is enabled/disabled.",
            "enum" : [ "UNKNOWN_STATUS", "ENABLED", "DISABLED_BY_DEVELOPER" ],
            "type" : "string"
          },
          "supportHomeScreen" : {
            "description" : "If the app supports a home screen.",
            "type" : "boolean"
          },
          "supportUrls" : {
            "$ref" : "#/components/schemas/SupportUrls"
          },
          "supportedUses" : {
            "description" : "The supported uses are limited according to the user that made the request. If the user does not have permission to use the bot, the list will be empty. This could occur for non whitelisted bots in the catalog.",
            "items" : {
              "enum" : [ "UNKNOWN", "CAN_ADD_TO_DM", "CAN_ADD_TO_ROOM", "CAN_ADD_TO_HUMAN_DM" ],
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "BotResponse" : {
        "description" : "Information about a bot response, branched from shared/bot_response.proto without frontend User proto as we never store it.",
        "properties" : {
          "botId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "requiredAction" : {
            "enum" : [ "UNKNOWN_SETUP_TYPE", "CONFIGURATION", "AUTHENTICATION" ],
            "type" : "string"
          },
          "responseType" : {
            "enum" : [ "UNKNOWN_RESPONSE_TYPE", "ERROR", "SETUP_REQUIRED", "DISABLED_BY_ADMIN", "DISABLED_BY_DEVELOPER", "PRIVATE", "APP_SUGGESTION" ],
            "type" : "string"
          },
          "setupUrl" : {
            "description" : "URL for setting up bot.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "BroadcastAccess" : {
        "description" : "Broadcast access information of a meeting space.",
        "properties" : {
          "accessPolicy" : {
            "description" : "The policy that controls the broadcast's viewer access.",
            "enum" : [ "BROADCASTING_ACCESS_POLICY_UNSPECIFIED", "ORGANIZATION", "PUBLIC" ],
            "type" : "string"
          },
          "viewUrl" : {
            "description" : "A URL that can be used to access the broadcast of the meeting. This field will be empty if broadcast is not enabled. It will be populated by the backend. Clients cannot modify the value.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "BroadcastSessionInfo" : {
        "description" : "Information about a broadcast session.",
        "properties" : {
          "broadcastSessionId" : {
            "description" : "A unique server-generated ID for the broadcast session.",
            "type" : "string"
          },
          "broadcastStats" : {
            "$ref" : "#/components/schemas/BroadcastStats"
          },
          "ingestionId" : {
            "description" : "Input only. Deprecated field, should not be used.",
            "type" : "string"
          },
          "sessionStateInfo" : {
            "$ref" : "#/components/schemas/SessionStateInfo"
          }
        },
        "type" : "object"
      },
      "BroadcastStats" : {
        "description" : "Statistics of the broadcast session.",
        "properties" : {
          "estimatedViewerCount" : {
            "description" : "Estimated concurrent viewer count.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Button" : {
        "properties" : {
          "imageButton" : {
            "$ref" : "#/components/schemas/ImageButton"
          },
          "textButton" : {
            "$ref" : "#/components/schemas/TextButton"
          }
        },
        "type" : "object"
      },
      "CalendarClientActionMarkup" : {
        "properties" : {
          "addAttachmentsActionMarkup" : {
            "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup"
          },
          "editAttendeesActionMarkup" : {
            "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup"
          },
          "editConferenceDataActionMarkup" : {
            "$ref" : "#/components/schemas/AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup"
          }
        },
        "type" : "object"
      },
      "CallInfo" : {
        "description" : "Contains information regarding an ongoing conference (aka call) for a meeting space.",
        "properties" : {
          "abuseReportingConfig" : {
            "$ref" : "#/components/schemas/AbuseReportingConfig"
          },
          "artifactOwner" : {
            "$ref" : "#/components/schemas/UserDisplayInfo"
          },
          "attachedDocuments" : {
            "description" : "Output only. Documents attached to an ongoing conference.",
            "items" : {
              "$ref" : "#/components/schemas/DocumentInfo"
            },
            "readOnly" : true,
            "type" : "array"
          },
          "availableAccessTypes" : {
            "description" : "List of available access types of the conference.",
            "items" : {
              "enum" : [ "ACCESS_TYPE_UNSPECIFIED", "ACCESS_TYPE_OPEN", "ACCESS_TYPE_TRUSTED", "ACCESS_TYPE_RESTRICTED", "ACCESS_TYPE_CLOSED" ],
              "type" : "string"
            },
            "type" : "array"
          },
          "availableReactions" : {
            "description" : "Output only. The set of reactions that clients are allowed to send and can expect to receive. Note that a device in the conference should have the MAY_SEND_REACTIONS privilege to be able to send reactions.",
            "items" : {
              "$ref" : "#/components/schemas/ReactionInfo"
            },
            "readOnly" : true,
            "type" : "array"
          },
          "broadcastSessionInfo" : {
            "$ref" : "#/components/schemas/BroadcastSessionInfo"
          },
          "calendarEventId" : {
            "description" : "Output only. The calendar event ID of a Google Calendar event that the meeting space is associated with. If the meeting space is not associated with an event in Google Calendar, this field is empty. For recurring events, it refers to the recurring instance associated with the current call, as determined by the server.",
            "readOnly" : true,
            "type" : "string"
          },
          "coActivity" : {
            "$ref" : "#/components/schemas/CoActivity"
          },
          "collaboration" : {
            "$ref" : "#/components/schemas/Collaboration"
          },
          "cseInfo" : {
            "$ref" : "#/components/schemas/CseInfo"
          },
          "maxJoinedDevices" : {
            "description" : "Output only. The maximum number of devices that may be in the joined state simultaneously in this conference. This can be used by clients to guess whether it will be possible to join, but the only way to know is to try to join. It can also be used to inform users about the limit that is in effect. This limit is normally set when the conference is created and not changed during the lifetime of the conference. But there are some cases where it may change, so clients should be aware that the information may be stale.",
            "format" : "int32",
            "readOnly" : true,
            "type" : "integer"
          },
          "organizationName" : {
            "description" : "Output only. The name or description of the organization or domain that the organizer belongs to. The expected use of this in clients is to present messages like \"John Doe (outside of Google.com) is trying to join this call\", where \"Google.com\" is the organization name. The field will be empty if the organization name could not be determined, possibly because of a backend error.",
            "readOnly" : true,
            "type" : "string"
          },
          "paygateInfo" : {
            "$ref" : "#/components/schemas/PaygateInfo"
          },
          "presenter" : {
            "$ref" : "#/components/schemas/Presenter"
          },
          "recordingInfo" : {
            "$ref" : "#/components/schemas/RecordingInfo"
          },
          "recordingSessionInfo" : {
            "$ref" : "#/components/schemas/RecordingSessionInfo"
          },
          "settings" : {
            "$ref" : "#/components/schemas/CallSettings"
          },
          "streamingSessions" : {
            "description" : "Output only. Info about streaming sessions (recording or broadcast) for this conference. This should contain all active sessions. Currently, it's guaranteed to have at most one recording and at most one broadcast (at most two sessions in total). For each application type (recording or broadcast), latest inactive session is included if there's no active one.",
            "items" : {
              "$ref" : "#/components/schemas/StreamingSessionInfo"
            },
            "readOnly" : true,
            "type" : "array"
          },
          "transcriptionSessionInfo" : {
            "$ref" : "#/components/schemas/TranscriptionSessionInfo"
          },
          "viewerCount" : {
            "description" : "The number of devices viewing the conference - MeetingDevices that are in VIEWER role and JOINED state in the conference.",
            "format" : "int32",
            "type" : "integer"
          },
          "youTubeBroadcastSessionInfos" : {
            "description" : "Information about active YouTube broadcast sessions in the ongoing conference.",
            "items" : {
              "$ref" : "#/components/schemas/YouTubeBroadcastSessionInfo"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "CallSettings" : {
        "description" : "Effective settings of the ongoing conference.",
        "properties" : {
          "accessLock" : {
            "description" : "Indicates whether the access lock is currently on or off.",
            "type" : "boolean"
          },
          "accessType" : {
            "description" : "The current access type of the conference.",
            "enum" : [ "ACCESS_TYPE_UNSPECIFIED", "ACCESS_TYPE_OPEN", "ACCESS_TYPE_TRUSTED", "ACCESS_TYPE_RESTRICTED", "ACCESS_TYPE_CLOSED" ],
            "type" : "string"
          },
          "allowJoiningBeforeHost" : {
            "description" : "Whether users can join this conference before a host (Host or Cohost).",
            "type" : "boolean"
          },
          "attendanceReportEnabled" : {
            "description" : "Indicates whether the attendance report is currently enabled or disabled.",
            "type" : "boolean"
          },
          "audioLock" : {
            "description" : "Indicates whether the audio lock is currently on or off.",
            "type" : "boolean"
          },
          "chatLock" : {
            "description" : "Indicates whether the chat lock is currently on or off.",
            "type" : "boolean"
          },
          "cseEnabled" : {
            "description" : "Whether Client-side Encryption is enabled for this conference.",
            "type" : "boolean"
          },
          "moderationEnabled" : {
            "description" : "Indicates whether moderation is currently on or off.",
            "type" : "boolean"
          },
          "presentLock" : {
            "description" : "Indicates whether the present lock is currently on or off.",
            "type" : "boolean"
          },
          "reactionsLock" : {
            "description" : "Indicates whether the reactions lock is currently on or off.",
            "type" : "boolean"
          },
          "videoLock" : {
            "description" : "Indicates whether the video lock is currently on or off.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "CapTokenHolderProto" : {
        "description" : "Represents a principal which possesses a particular secret string whose cryptographic hash is specified here. CapTokens (\"Capability Tokens\") are used in ACLProto. It's expected that ACLs with CapTokenHolders will strongly enforce them by Keystore-wrapping crypto keys for the corresponding CapTokens.",
        "properties" : {
          "tokenHmacSha1Prefix" : {
            "description" : "The hash of the corresponding capability token. The value is defined to be identical to the one in acl.proto's CapTokenMetadata: 10-byte prefix of HMAC-SHA1 of the token. The HMAC key is the following fixed (non-secret) 512-bit value: 79b1c8f4 82baf523 b8a9ab4a e960f438 c45be041 11f1f222 e8a3f64d aeb05e3d c3576acc ec649194 aede422c 4e48e0d1 ff21234a a6ed6b49 a7fa592e efd7bba3",
            "format" : "byte",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Card" : {
        "properties" : {
          "cardActions" : {
            "items" : {
              "$ref" : "#/components/schemas/CardAction"
            },
            "type" : "array"
          },
          "displayStyle" : {
            "enum" : [ "DISPLAY_STYLE_UNSPECIFIED", "PEEK", "REPLACE" ],
            "type" : "string"
          },
          "fixedFooter" : {
            "$ref" : "#/components/schemas/FixedFooter"
          },
          "header" : {
            "$ref" : "#/components/schemas/CardHeader"
          },
          "name" : {
            "description" : "Name of the card used in CardNavigation.pop_to_card_name.",
            "type" : "string"
          },
          "peekCardHeader" : {
            "$ref" : "#/components/schemas/CardHeader"
          },
          "sections" : {
            "items" : {
              "$ref" : "#/components/schemas/Section"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "CardAction" : {
        "description" : "When an AddOn Card is shown in detailed view, a card action is the action associated with the card. For an invoice card, a typical action would be: delete invoice, email invoice or open the invoice in browser.",
        "properties" : {
          "actionLabel" : {
            "description" : "The label used to be displayed in the action menu item.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          }
        },
        "type" : "object"
      },
      "CardCapabilityMetadata" : {
        "properties" : {
          "requiredCapabilities" : {
            "description" : "NEXT TAG : 2",
            "items" : {
              "enum" : [ "UNKNOWN", "SUPPORTS_BASE_CARDS" ],
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "CardHeader" : {
        "properties" : {
          "imageAltText" : {
            "description" : "The alternative text of this image which will be used for accessibility.",
            "type" : "string"
          },
          "imageStyle" : {
            "enum" : [ "CROP_TYPE_NOT_SET", "SQUARE", "CIRCLE", "RECTANGLE_CUSTOM", "RECTANGLE_4_3" ],
            "type" : "string"
          },
          "imageUrl" : {
            "type" : "string"
          },
          "subtitle" : {
            "type" : "string"
          },
          "title" : {
            "description" : "The title must be specified. The header has a fixed height: if both a title and subtitle is specified, each will take up 1 line. If only the title is specified, it will take up both lines. The header is rendered in collapsed and detailed view.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "CaribouAttributeValue" : {
        "properties" : {
          "booleanValue" : {
            "description" : "Tags 1 through 15 are reserved for the most commonly used fields.",
            "type" : "boolean"
          },
          "intValue" : {
            "format" : "int32",
            "type" : "integer"
          },
          "longValue" : {
            "format" : "int64",
            "type" : "string"
          },
          "rawByteValue" : {
            "description" : "Generally, applications should avoid storing raw bytes and instead store structured data as protocol buffer extensions. This both reduces the amount of ad-hoc attribute parsing code as well as eliminates an intermediate copy of the data when deserializing the value. The rawByteValue field is mainly provided for compatibility with attributes stored before the introduction of the Attribute.Value.",
            "format" : "byte",
            "type" : "string"
          },
          "stringValue" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ChatClientActionMarkup" : {
        "description" : "Actions handled by Chat Clients.",
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadata" : {
        "description" : "Metadata used as inputs to the localization that is performed on Dynamite-originated messages that are incompatible with Hangouts clients. See go/localization-of-system-messages for more details.",
        "properties" : {
          "attachmentMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadataAttachmentMetadata"
          },
          "botMessageMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadataBotMessageMetadata"
          },
          "calendarEventMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata"
          },
          "deleteMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadataDeleteMetadata"
          },
          "editMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadataEditMetadata"
          },
          "spaceUrl" : {
            "description" : "The space URL embedded in the localized string.",
            "type" : "string"
          },
          "tasksMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadataTasksMetadata"
          },
          "videoCallMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadataVideoCallMetadata"
          }
        },
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadataAttachmentMetadata" : {
        "description" : "An attachment uploaded in Dynamite and its filename.",
        "properties" : {
          "filename" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadataBotMessageMetadata" : {
        "description" : "A bot sent a message in Dynamite.",
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata" : {
        "description" : "A Calendar event message in Dynamite.",
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadataDeleteMetadata" : {
        "description" : "A message was deleted in Dynamite.",
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadataEditMetadata" : {
        "description" : "An edit was made in Dynamite.",
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadataTasksMetadata" : {
        "description" : "A Tasks message in Dynamite.",
        "type" : "object"
      },
      "ChatConserverDynamitePlaceholderMetadataVideoCallMetadata" : {
        "description" : "A Meet initiated in Dynamite and its URL.",
        "properties" : {
          "meetingUrl" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ChatConserverMessageContent" : {
        "description" : "The content of a chat message, which includes 0 or more segments along with 0 or more embeds, which represent various attachment types (like photos).",
        "properties" : {
          "attachment" : {
            "description" : "Items attached to this message, such as photos. This should *NOT* be set by clients. It will be automatically set from media uploaded along with this request and using the information provided in existing_media.",
            "items" : {
              "$ref" : "#/components/schemas/SocialCommonAttachmentAttachment"
            },
            "type" : "array"
          },
          "segment" : {
            "description" : "The text part of the message content. Segments are concatenated together to yield the full message. A message can have zero or more segments.",
            "items" : {
              "$ref" : "#/components/schemas/Segment"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ChatContentExtension" : {
        "description" : "NEXT ID: 12",
        "properties" : {
          "annotation" : {
            "description" : "Annotations to decorate this event.",
            "items" : {
              "$ref" : "#/components/schemas/EventAnnotation"
            },
            "type" : "array"
          },
          "dynamitePlaceholderMetadata" : {
            "$ref" : "#/components/schemas/ChatConserverDynamitePlaceholderMetadata"
          },
          "eventOtrStatus" : {
            "description" : "Is this event OnTR or OffTR? Since some events can be ON_THE_RECORD and have an expiration_timestamp (for example enterprise retention users) we need to store the otr status.",
            "enum" : [ "OFF_THE_RECORD", "ON_THE_RECORD" ],
            "type" : "string"
          },
          "groupLinkSharingModificationEvent" : {
            "$ref" : "#/components/schemas/GroupLinkSharingModificationEvent"
          },
          "hangoutEvent" : {
            "$ref" : "#/components/schemas/HangoutEvent"
          },
          "inviteAcceptedEvent" : {
            "$ref" : "#/components/schemas/InviteAcceptedEvent"
          },
          "membershipChangeEvent" : {
            "$ref" : "#/components/schemas/MembershipChangeEvent"
          },
          "otrChatMessageEvent" : {
            "$ref" : "#/components/schemas/OtrChatMessageEvent"
          },
          "otrModificationEvent" : {
            "$ref" : "#/components/schemas/OtrModificationEvent"
          },
          "renameEvent" : {
            "$ref" : "#/components/schemas/RenameEvent"
          }
        },
        "type" : "object"
      },
      "ChatProto" : {
        "description" : "Represents the invitees or other users associated with a Babel Chat (see http://goto/babel). Corresponds to GroupType CHAT in //social/graph/storage/proto/data.proto.",
        "properties" : {
          "chatId" : {
            "description" : "Chat IDs consist of alphanumeric characters and colons. Currently required.",
            "type" : "string"
          },
          "memberType" : {
            "description" : "The type of Chat members to consider, e.g. \"all members\" vs. \"invitee\" These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See chat.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with chat. Currently required.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "CheckAccessResponse" : {
        "properties" : {
          "hasAccess" : {
            "description" : "Returns true if principal has access. Returns false otherwise.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "CircleProto" : {
        "description" : "Represents a Google+ Circle. Currently (12/2011), a Circle is identical to the ContactGroup with matching parameters, but Circle must only be used for true Circles and not other Focus groups, and should be preferred over ContactGroup where applicable. Soon it may become more efficient to check membership in a Circle than in a ContactGroup (see http://go/superglue). Support for this principal type is currently (12/2011) incomplete -- e.g., Keystore does not support it yet (see b/5703421).",
        "properties" : {
          "circleId" : {
            "description" : "Circle ID is unique only relative to the owner's Gaia ID. Currently required.",
            "format" : "int64",
            "type" : "string"
          },
          "ownerGaiaId" : {
            "description" : "The owner of the circle. Currently required.",
            "format" : "int64",
            "type" : "string"
          },
          "requiredConsistencyTimestampUsec" : {
            "description" : "If present, then tests for membership in this circle must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http://go/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this circle supports checking consistency timestamps. For example, as of 12/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ClientContext" : {
        "description" : "Represents the context of the client on behalf of which a HistoryRecord is produced. The ClientContext message can be used to hold context about the service client (e.g. the internal server making fusebox requests) or the user client (e.g. the IP address of the end user).",
        "properties" : {
          "clientOperationId" : {
            "description" : "The client operation to which this history record belongs. The notion of a client operation is provided to keep track of client operations which might span multiple transactions in the lower level.",
            "type" : "string"
          },
          "clientType" : {
            "description" : "E.g. \"pinto\", \"imap\", \"bigtop\", \"upload\"",
            "type" : "string"
          },
          "sessionContext" : {
            "$ref" : "#/components/schemas/SessionContext"
          },
          "userIp" : {
            "description" : "Textual representation of the user's IP address, if available.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "CloudPrincipalProto" : {
        "description" : "Principal associated with a Cloud Principal representing third party user.",
        "properties" : {
          "id" : {
            "description" : "Format: \"{identity-pool}:{subject}#\" Details: go/cloud-principal-identifiers",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ClusterInfo" : {
        "description" : "ClusterInfo contains clustering related information for a particular thread that would be sent as part of the conversation view. Today, this information would be used by iOS notification server to identify whether the thread belongs to a cluster. If the thread belongs to a grouped cluster, it would identify whether the cluster is throttled.",
        "properties" : {
          "clusterId" : {
            "description" : "IDs of the highest priority clusters to which the thread belongs to. If this field is not present, the thread does not belong to any cluster and would be shown in the inbox, unclustered.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "throttled" : {
            "description" : "If the thread belongs to a grouped cluster and all of those clusters are throttled, then this field is set to true.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "CoActivity" : {
        "description" : "Metadata about a co-activity session.",
        "properties" : {
          "activityTitle" : {
            "description" : "The title of the activity in this co-activity session. For example, this might be the title of the video being co-watched, or the name of the round of a game being co-played.",
            "type" : "string"
          },
          "coActivityApp" : {
            "description" : "Identifies the app handling this co-activity.",
            "enum" : [ "CO_ACTIVITY_APP_UNSPECIFIED", "CO_ACTIVITY_APP_YOU_TUBE_MAIN", "CO_ACTIVITY_APP_SPOTIFY", "CO_ACTIVITY_APP_UNO", "CO_ACTIVITY_APP_HEADSUP", "CO_ACTIVITY_APP_KAHOOT", "CO_ACTIVITY_APP_GQUEUES", "CO_ACTIVITY_APP_YOU_TUBE_MUSIC", "CO_ACTIVITY_APP_SAMSUNG_NOTES", "CO_ACTIVITY_APP_HAPPY_AARDVARK" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Collaboration" : {
        "description" : "Information about a collaboration session.",
        "properties" : {
          "attachmentId" : {
            "description" : "The attachment being collaborated on.",
            "type" : "string"
          },
          "initiator" : {
            "$ref" : "#/components/schemas/UserDisplayInfo"
          },
          "uri" : {
            "description" : "The uri of the artifact being collaborated on.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Color" : {
        "description" : "Represents a color in the RGBA color space. This representation is designed for simplicity of conversion to/from color representations in various languages over compactness. For example, the fields of this representation can be trivially provided to the constructor of `java.awt.Color` in Java; it can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha` method in iOS; and, with just a little work, it can be easily formatted into a CSS `rgba()` string in JavaScript. This reference page doesn't carry information about the absolute color space that should be used to interpret the RGB value (e.g. sRGB, Adobe RGB, DCI-P3, BT.2020, etc.). By default, applications should assume the sRGB color space. When color equality needs to be decided, implementations, unless documented otherwise, treat two colors as equal if all their red, green, blue, and alpha values each differ by at most 1e-5. Example (Java): import com.google.type.Color; // ... public static java.awt.Color fromProto(Color protocolor) { float alpha = protocolor.hasAlpha() ? protocolor.getAlpha().getValue() : 1.0; return new java.awt.Color( protocolor.getRed(), protocolor.getGreen(), protocolor.getBlue(), alpha); } public static Color toProto(java.awt.Color color) { float red = (float) color.getRed(); float green = (float) color.getGreen(); float blue = (float) color.getBlue(); float denominator = 255.0; Color.Builder resultBuilder = Color .newBuilder() .setRed(red / denominator) .setGreen(green / denominator) .setBlue(blue / denominator); int alpha = color.getAlpha(); if (alpha != 255) { result.setAlpha( FloatValue .newBuilder() .setValue(((float) alpha) / denominator) .build()); } return resultBuilder.build(); } // ... Example (iOS / Obj-C): // ... static UIColor* fromProto(Color* protocolor) { float red = [protocolor red]; float green = [protocolor green]; float blue = [protocolor blue]; FloatValue* alpha_wrapper = [protocolor alpha]; float alpha = 1.0; if (alpha_wrapper != nil) { alpha = [alpha_wrapper value]; } return [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; } static Color* toProto(UIColor* color) { CGFloat red, green, blue, alpha; if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) { return nil; } Color* result = [[Color alloc] init]; [result setRed:red]; [result setGreen:green]; [result setBlue:blue]; if (alpha <= 0.9999) { [result setAlpha:floatWrapperWithValue(alpha)]; } [result autorelease]; return result; } // ... Example (JavaScript): // ... var protoToCssColor = function(rgb_color) { var redFrac = rgb_color.red || 0.0; var greenFrac = rgb_color.green || 0.0; var blueFrac = rgb_color.blue || 0.0; var red = Math.floor(redFrac * 255); var green = Math.floor(greenFrac * 255); var blue = Math.floor(blueFrac * 255); if (!('alpha' in rgb_color)) { return rgbToCssColor(red, green, blue); } var alphaFrac = rgb_color.alpha.value || 0.0; var rgbParams = [red, green, blue].join(','); return ['rgba(', rgbParams, ',', alphaFrac, ')'].join(''); }; var rgbToCssColor = function(red, green, blue) { var rgbNumber = new Number((red << 16) | (green << 8) | blue); var hexString = rgbNumber.toString(16); var missingZeros = 6 - hexString.length; var resultBuilder = ['#']; for (var i = 0; i < missingZeros; i++) { resultBuilder.push('0'); } resultBuilder.push(hexString); return resultBuilder.join(''); }; // ...",
        "properties" : {
          "alpha" : {
            "description" : "The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation: `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)` This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. This uses a wrapper message rather than a simple float scalar so that it is possible to distinguish between a default value and the value being unset. If omitted, this color object is rendered as a solid color (as if the alpha value had been explicitly given a value of 1.0).",
            "format" : "float",
            "type" : "number"
          },
          "blue" : {
            "description" : "The amount of blue in the color as a value in the interval [0, 1].",
            "format" : "float",
            "type" : "number"
          },
          "green" : {
            "description" : "The amount of green in the color as a value in the interval [0, 1].",
            "format" : "float",
            "type" : "number"
          },
          "red" : {
            "description" : "The amount of red in the color as a value in the interval [0, 1].",
            "format" : "float",
            "type" : "number"
          }
        },
        "type" : "object"
      },
      "CommunalLabelTag" : {
        "description" : "An individual instance (or \"tag\") of a label configured as a communal type that's associated with a message.",
        "properties" : {
          "creatorUserId" : {
            "description" : "Gaia ID of the user who added the tag, if any. Not present for any tags automatically created by server-side processing.",
            "format" : "int64",
            "type" : "string"
          },
          "labelId" : {
            "description" : "A string ID representing the label. Possible ID values are documented at go/chat-labels-howto:ids. Example: \"^*t_p\" for \"Pinned\".",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "CompositeFilter" : {
        "properties" : {
          "logicOperator" : {
            "description" : "The logic operator of the sub filter.",
            "enum" : [ "AND", "OR", "NOT" ],
            "type" : "string"
          },
          "subFilters" : {
            "description" : "Sub filters.",
            "items" : {
              "$ref" : "#/components/schemas/Filter"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ConsentedAppUnfurlMetadata" : {
        "description" : "Annotation metadata app unfurl consent.",
        "properties" : {
          "clientSpecifiedAppId" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "ContactGroupProto" : {
        "description" : "A group of contacts for a given user, as described in http://cs/p#google3/focus/backend/proto/backend.proto Historically (and in still-existing ACLs), this was used to represent Google+ circles as well as contact groups, but this use is now deprecated. New code should use the CIRCLE principal type to represent Google+ circles.",
        "properties" : {
          "groupId" : {
            "description" : "Group ID is unique only relative to the owner's Gaia ID.",
            "format" : "int64",
            "type" : "string"
          },
          "ownerGaiaId" : {
            "format" : "int64",
            "type" : "string"
          },
          "requiredConsistencyTimestampUsec" : {
            "description" : "If present, then tests for membership in this ContactGroup must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http://go/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this group supports checking consistency timestamps. For example, as of 12/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ContentReport" : {
        "properties" : {
          "reportCreateTimestamp" : {
            "description" : "The time at which the report is generated. Always populated when it is in a response.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "reportJustification" : {
            "$ref" : "#/components/schemas/ContentReportJustification"
          },
          "reportType" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedContentReportType"
          },
          "reporterUserId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "revisionCreateTimestamp" : {
            "description" : "Create timestamp of the revisions of the message when it's reported. Always populated when it is in a response.",
            "format" : "google-datetime",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ContentReportJustification" : {
        "properties" : {
          "userJustification" : {
            "description" : "Optional. User-generated free-text justification for the content report.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ContentReportSummary" : {
        "description" : "Summarized info of content reports. Usually less expensive to fetch than to fetch all detailed reports. Set only when the request asks for it.",
        "properties" : {
          "numberReports" : {
            "description" : "Total number of reports attached to this (revision of) message.",
            "format" : "int32",
            "type" : "integer"
          },
          "numberReportsAllRevisions" : {
            "description" : "Totoal number of reports attached to all revisions of this message (i.e. since creation). Set only when the request asks for it.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "ContextAttribute" : {
        "description" : "A named attribute associated with an item which can be used for influencing the ranking of the item based on the context in the request.",
        "properties" : {
          "name" : {
            "description" : "The name of the attribute. It should not be empty. The maximum length is 32 characters. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The name will be normalized (lower-cased) before being matched.",
            "type" : "string"
          },
          "values" : {
            "description" : "Text values of the attribute. The maximum number of elements is 10. The maximum length of an element in the array is 32 characters. The value will be normalized (lower-cased) before being matched.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ContextualAddOnMarkup" : {
        "description" : "The markup for developers to specify the contents of a contextual AddOn. A contextual AddOn is triggered in context of an email. For that email, there can be N items that are associated with the email (e.g. contacts, sales lead, meeting information). Each item is represented as a \"card\". A card has two views, collapsed and detailed. If there are more than 1 card, the cards are show as a list of collapsed views. The end user can expand into the detailed view for each of those cards. In the detailed view, developers have the freedom to use a variety of \"widgets\" to construct it. The model here is to restrict (make consistent for end users) the navigation of the N cards but providing developers the freedom to build the detailed view that can best represent their use case/content. Go http://go/aoig-widgets1 to see the mocks. Post v1, we plan to support new AddOn use cases that will require different and separate 'templates'. For example, a compose triggered AddOn which will support a new set of use cases with different user interaction patterns. As a result, we will likely need a very different template than this one.",
        "properties" : {
          "cards" : {
            "description" : "A card must contain a header and at least 1 section.",
            "items" : {
              "$ref" : "#/components/schemas/Card"
            },
            "type" : "array"
          },
          "toolbar" : {
            "$ref" : "#/components/schemas/Toolbar"
          }
        },
        "type" : "object"
      },
      "CseInfo" : {
        "description" : "Information needed for Client-side Encryption.",
        "properties" : {
          "cseDomain" : {
            "description" : "CSE domain name claimed by the meeting owner's company. This field is expected to be used for display purposes only, i.e., \"Extra encryption added by $cse_domain\". It can differ from the `cse_domain` as defined elsewhere on the User, in the case of cross-domain meetings.",
            "type" : "string"
          },
          "wrappedKey" : {
            "description" : "The wrapped CSE key used by this conference.",
            "format" : "byte",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "CustomEmojiMetadata" : {
        "properties" : {
          "customEmoji" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCustomEmoji"
          }
        },
        "type" : "object"
      },
      "CustomFunctionReturnValueMarkup" : {
        "description" : "The result of a user running a custom function.",
        "properties" : {
          "errorMessage" : {
            "description" : "The error message to show to the user if something went wrong.",
            "type" : "string"
          },
          "value" : {
            "description" : "The value that resulted from running the custom function."
          }
        },
        "type" : "object"
      },
      "CustomerId" : {
        "description" : "Represents a GSuite customer ID. Obfuscated with CustomerIdObfuscator.",
        "properties" : {
          "customerId" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "CustomerIndexStats" : {
        "description" : "Aggregation of items by status code as of the specified date.",
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "itemCountByStatus" : {
            "description" : "Number of items aggregrated by status code.",
            "items" : {
              "$ref" : "#/components/schemas/ItemCountByStatus"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "CustomerQueryStats" : {
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "queryCountByStatus" : {
            "items" : {
              "$ref" : "#/components/schemas/QueryCountByStatus"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "CustomerSearchApplicationStats" : {
        "description" : "Search application stats for a customer for the given date.",
        "properties" : {
          "count" : {
            "description" : "The count of search applications for the date.",
            "format" : "int64",
            "type" : "string"
          },
          "date" : {
            "$ref" : "#/components/schemas/Date"
          }
        },
        "type" : "object"
      },
      "CustomerSessionStats" : {
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "searchSessionsCount" : {
            "description" : "The count of search sessions on the day",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "CustomerSettings" : {
        "description" : "Represents settings at a customer level.",
        "properties" : {
          "auditLoggingSettings" : {
            "$ref" : "#/components/schemas/AuditLoggingSettings"
          },
          "vpcSettings" : {
            "$ref" : "#/components/schemas/VPCSettings"
          }
        },
        "type" : "object"
      },
      "CustomerUserStats" : {
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "oneDayActiveUsersCount" : {
            "description" : "The count of unique active users in the past one day",
            "format" : "int64",
            "type" : "string"
          },
          "sevenDaysActiveUsersCount" : {
            "description" : "The count of unique active users in the past seven days",
            "format" : "int64",
            "type" : "string"
          },
          "thirtyDaysActiveUsersCount" : {
            "description" : "The count of unique active users in the past thirty days",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DataLossPreventionMetadata" : {
        "description" : "Annotation metadata for Data Loss Prevention that pertains to DLP violation on message send or edit events. It is used for client -> BE communication and other downstream process in BE (e.g. storage and audit logging), and it should never be returned to the client.",
        "properties" : {
          "dlpScanSummary" : {
            "$ref" : "#/components/schemas/DlpScanSummary"
          },
          "warnAcknowledged" : {
            "description" : "Flag set by client on message resend to bypass WARN violation.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "DataSource" : {
        "description" : "Datasource is a logical namespace for items to be indexed. All items must belong to a datasource. This is the prerequisite before items can be indexed into Cloud Search.",
        "properties" : {
          "disableModifications" : {
            "description" : "If true, sets the datasource to read-only mode. In read-only mode, the Indexing API rejects any requests to index or delete items in this source. Enabling read-only mode does not stop the processing of previously accepted data.",
            "type" : "boolean"
          },
          "disableServing" : {
            "description" : "Disable serving any search or assist results.",
            "type" : "boolean"
          },
          "displayName" : {
            "description" : "Required. Display name of the datasource The maximum length is 300 characters.",
            "type" : "string"
          },
          "indexingServiceAccounts" : {
            "description" : "List of service accounts that have indexing access.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "itemsVisibility" : {
            "description" : "This field restricts visibility to items at the datasource level. Items within the datasource are restricted to the union of users and groups included in this field. Note that, this does not ensure access to a specific item, as users need to have ACL permissions on the contained items. This ensures a high level access on the entire datasource, and that the individual items are not shared outside this visibility.",
            "items" : {
              "$ref" : "#/components/schemas/GSuitePrincipal"
            },
            "type" : "array"
          },
          "name" : {
            "description" : "The name of the datasource resource. Format: datasources/{source_id}. The name is ignored when creating a datasource.",
            "type" : "string"
          },
          "operationIds" : {
            "description" : "IDs of the Long Running Operations (LROs) currently running for this schema.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "returnThumbnailUrls" : {
            "description" : "Can a user request to get thumbnail URI for Items indexed in this data source.",
            "type" : "boolean"
          },
          "shortName" : {
            "description" : "A short name or alias for the source. This value will be used to match the 'source' operator. For example, if the short name is *<value>* then queries like *source:<value>* will only return results for this source. The value must be unique across all datasources. The value must only contain alphanumeric characters (a-zA-Z0-9). The value cannot start with 'google' and cannot be one of the following: mail, gmail, docs, drive, groups, sites, calendar, hangouts, gplus, keep, people, teams. Its maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DataSourceIndexStats" : {
        "description" : "Aggregation of items by status code as of the specified date.",
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "itemCountByStatus" : {
            "description" : "Number of items aggregrated by status code.",
            "items" : {
              "$ref" : "#/components/schemas/ItemCountByStatus"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "DataSourceRestriction" : {
        "description" : "Restriction on Datasource.",
        "properties" : {
          "filterOptions" : {
            "description" : "Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: \"objecttype\", \"type\" and \"mimetype\". For now, schema specific filters cannot be used to filter suggestions.",
            "items" : {
              "$ref" : "#/components/schemas/FilterOptions"
            },
            "type" : "array"
          },
          "source" : {
            "$ref" : "#/components/schemas/Source"
          }
        },
        "type" : "object"
      },
      "Date" : {
        "description" : "Represents a whole calendar date, for example a date of birth. The time of day and time zone are either specified elsewhere or are not significant. The date is relative to the [Proleptic Gregorian Calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar). The date must be a valid calendar date between the year 1 and 9999.",
        "properties" : {
          "day" : {
            "description" : "Day of month. Must be from 1 to 31 and valid for the year and month.",
            "format" : "int32",
            "type" : "integer"
          },
          "month" : {
            "description" : "Month of date. Must be from 1 to 12.",
            "format" : "int32",
            "type" : "integer"
          },
          "year" : {
            "description" : "Year of date. Must be from 1 to 9999.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "DateOperatorOptions" : {
        "description" : "Optional. Provides a search operator for date properties. Search operators let users restrict the query to specific fields relevant to the type of item being searched.",
        "properties" : {
          "greaterThanOperatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the date property using the greater-than operator. For example, if greaterThanOperatorName is *closedafter* and the property's name is *closeDate*, then queries like *closedafter:<value>* show results only where the value of the property named *closeDate* is later than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          },
          "lessThanOperatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the date property using the less-than operator. For example, if lessThanOperatorName is *closedbefore* and the property's name is *closeDate*, then queries like *closedbefore:<value>* show results only where the value of the property named *closeDate* is earlier than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          },
          "operatorName" : {
            "description" : "Indicates the actual string required in the query in order to isolate the date property. For example, suppose an issue tracking schema object has a property named *closeDate* that specifies an operator with an operatorName of *closedon*. For searches on that data, queries like *closedon:<value>* show results only where the value of the *closeDate* property matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the indexed datasource. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DatePropertyOptions" : {
        "description" : "The options for date properties.",
        "properties" : {
          "operatorOptions" : {
            "$ref" : "#/components/schemas/DateOperatorOptions"
          }
        },
        "type" : "object"
      },
      "DateTimePicker" : {
        "properties" : {
          "label" : {
            "description" : "The label for the field, which is displayed to the user.",
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the text field which is used in FormInput, and uniquely identifies this input.",
            "type" : "string"
          },
          "onChange" : {
            "$ref" : "#/components/schemas/FormAction"
          },
          "timezoneOffsetDate" : {
            "description" : "The number representing the time-zone offset from UTC, in minutes. If set, the value_ms_epoch will be displayed in the specified time zone. If not set, it will use the user's timezone setting in client side.",
            "format" : "int32",
            "type" : "integer"
          },
          "type" : {
            "description" : "The type of the DateTimePicker.",
            "enum" : [ "UNSPECIFIED_TYPE", "DATE_AND_TIME", "DATE_ONLY", "TIME_ONLY" ],
            "type" : "string"
          },
          "valueMsEpoch" : {
            "description" : "The value to display which can be the default value before user input or previous user input. It is represented in milliseconds (Epoch time). - For DATE_AND_TIME type, the full epoch value is used. - For DATE_ONLY type, only date of the epoch time is used. - For TIME_ONLY type, only time of the epoch time is used. For example, you can set epoch time to 3 * 60 * 60 * 1000 to represent 3am.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DateValues" : {
        "description" : "List of date values.",
        "properties" : {
          "values" : {
            "items" : {
              "$ref" : "#/components/schemas/Date"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "DebugOptions" : {
        "description" : "Shared request debug options for all cloudsearch RPC methods.",
        "properties" : {
          "enableDebugging" : {
            "description" : "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "DeepLinkData" : {
        "description" : "Deep-linking data is used to construct a deep-link URI for an activity or frame's embed, such that on click, the user is taken to the right place in a mobile app. If the app is not installed, the user is taken to the app store. If not on mobile, an analogous web uri is used.",
        "properties" : {
          "appId" : {
            "description" : "Application ID (or project ID) from Google API Console.",
            "format" : "int64",
            "type" : "string"
          },
          "client" : {
            "description" : "The data for a Google API Console client is entered by a developer during client registration and is stored in PackagingService.",
            "items" : {
              "$ref" : "#/components/schemas/PackagingServiceClient"
            },
            "type" : "array"
          },
          "deepLinkId" : {
            "description" : "The ID for non-URL content. Embeds may either have no analogous web presence or prefer a native mobile experience if supported. In the case of no web presence, instead of setting the \"url\" field of an embed, such developers will set this field and other content fields, e.g. thumbnail, title, description. If set, this field is used to construct the deep-link URI. Note that the native experience is preferred over the web link and the web link is used as a fallback.",
            "type" : "string"
          },
          "url" : {
            "description" : "Analogous web presence. Used as desktop fallback or when no native link data is present.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DeleteMetadata" : {
        "description" : "A message delete in Dynamite inserts a Babel-only item containing this field. This is only inserted for messages before the source-of-truth flip. See go/hsc-message-deletions for more details.",
        "type" : "object"
      },
      "DeleteQueueItemsRequest" : {
        "properties" : {
          "connectorName" : {
            "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
            "type" : "string"
          },
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "queue" : {
            "description" : "The name of a queue to delete items from.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DeliveryMedium" : {
        "properties" : {
          "mediumType" : {
            "description" : "Describes the medium the cent was sent/received. For example, if I receive an SMS via GV, the medium_type will be GV.",
            "enum" : [ "UNKNOWN_MEDIUM", "BABEL_MEDIUM", "GOOGLE_VOICE_MEDIUM", "LOCAL_SMS_MEDIUM" ],
            "type" : "string"
          },
          "selfPhone" : {
            "$ref" : "#/components/schemas/VoicePhoneNumber"
          }
        },
        "type" : "object"
      },
      "DisplayedProperty" : {
        "description" : "A reference to a top-level property within the object that should be displayed in search results. The values of the chosen properties is displayed in the search results along with the display label for that property if one is specified. If a display label is not specified, only the values is shown.",
        "properties" : {
          "propertyName" : {
            "description" : "The name of the top-level property as defined in a property definition for the object. If the name is not a defined property in the schema, an error is given when attempting to update the schema.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Divider" : {
        "type" : "object"
      },
      "DlpScanSummary" : {
        "description" : "A summary of a DLP scan event. This is a summary and should contain the minimum amount of data required to identify and process DLP scans. It is written to Starcast and encoded & returned to the client on attachment upload.",
        "properties" : {
          "scanId" : {
            "description" : "The scan ID of the corresponding {@link DlpViolationScanRecord} in the {@link EphemeralDlpScans} Spanner table. This can be used to fetch additional details about the scan, e.g. for audit logging.",
            "type" : "string"
          },
          "scanNotApplicableForContext" : {
            "description" : "Indicates that was no attempt to scan a message or attachment because it was not applicable in the given context (e.g. atomic mutuate). If this is true, scan_outcome should not be set. This flag is used to identify messages that DLP did not attempt to scan for monitoring scan coverage. Contents that DLP attempted to scan but skipped can be identified by DlpScanOutcome.SCAN_SKIPPED_* reasons. DEPRECATED: The prober can determine this from the context.",
            "type" : "boolean"
          },
          "scanOutcome" : {
            "description" : "The outcome of a DLP Scan. If this is set, scan_not_applicable_for_context should not be true.",
            "enum" : [ "SCAN_UNKNOWN_OUTCOME", "SCAN_SUCCEEDED_NO_VIOLATION", "SCAN_SUCCEEDED_BLOCK", "SCAN_SUCCEEDED_WARN", "SCAN_SUCCEEDED_AUDIT_ONLY", "SCAN_FAILURE_EXCEPTION", "SCAN_FAILURE_RULE_FETCH_FAILED", "SCAN_FAILURE_TIMEOUT", "SCAN_FAILURE_ALL_RULES_FAILED", "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS", "SCAN_SKIPPED_EXPERIMENT_DISABLED", "SCAN_SKIPPED_CONSUMER", "SCAN_SKIPPED_NON_HUMAN_USER", "SCAN_SKIPPED_NO_MESSAGE", "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING", "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN", "SCAN_SKIPPED_MESSAGE_SENT_DURING_SPACE_MIGRATION", "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND", "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS", "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER", "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR", "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE", "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE", "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION", "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK", "SCAN_SUCCEEDED_WITH_FAILURES_WARN", "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DmId" : {
        "properties" : {
          "dmId" : {
            "description" : "Unique server assigned Id, per Direct Message Space.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DocumentInfo" : {
        "description" : "Information on a document attached to an active conference.",
        "properties" : {
          "whiteboardInfo" : {
            "$ref" : "#/components/schemas/WhiteboardInfo"
          }
        },
        "type" : "object"
      },
      "DoubleOperatorOptions" : {
        "description" : "Used to provide a search operator for double properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.",
        "properties" : {
          "operatorName" : {
            "description" : "Indicates the operator name required in the query in order to use the double property in sorting or as a facet. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DoublePropertyOptions" : {
        "description" : "The options for double properties.",
        "properties" : {
          "operatorOptions" : {
            "$ref" : "#/components/schemas/DoubleOperatorOptions"
          }
        },
        "type" : "object"
      },
      "DoubleValues" : {
        "description" : "List of double values.",
        "properties" : {
          "values" : {
            "items" : {
              "format" : "double",
              "type" : "number"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "DriveClientActionMarkup" : {
        "properties" : {
          "requestFileScope" : {
            "$ref" : "#/components/schemas/RequestFileScope"
          }
        },
        "type" : "object"
      },
      "DriveFollowUpRestrict" : {
        "description" : "Drive follow-up search restricts (e.g. \"followup:suggestions\").",
        "properties" : {
          "type" : {
            "enum" : [ "UNSPECIFIED", "FOLLOWUP_SUGGESTIONS", "FOLLOWUP_ACTION_ITEMS" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DriveLocationRestrict" : {
        "description" : "Drive location search restricts (e.g. \"is:starred\").",
        "properties" : {
          "type" : {
            "enum" : [ "UNSPECIFIED", "TRASHED", "STARRED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DriveMetadata" : {
        "description" : "Annotation metadata for Drive artifacts.",
        "properties" : {
          "aclFixRequest" : {
            "$ref" : "#/components/schemas/AclFixRequest"
          },
          "aclFixStatus" : {
            "$ref" : "#/components/schemas/AclFixStatus"
          },
          "canEdit" : {
            "description" : "Can the current user edit this resource",
            "type" : "boolean"
          },
          "canShare" : {
            "description" : "Can the current user share this resource",
            "type" : "boolean"
          },
          "canView" : {
            "description" : "Can the current user view this resource",
            "type" : "boolean"
          },
          "driveAction" : {
            "description" : "DriveAction for organizing this file in Drive. If the user does not have access to the Drive file, the value will be DriveAction.DRIVE_ACTION_UNSPECIFIED. This field is only set when part of a FileResult in a ListFilesResponse.",
            "enum" : [ "DRIVE_ACTION_UNSPECIFIED", "ADD_TO_DRIVE", "ORGANIZE", "ADD_SHORTCUT", "ADD_ANOTHER_SHORTCUT" ],
            "type" : "string"
          },
          "driveState" : {
            "enum" : [ "DRIVE_STATE_UNSPECIFIED", "IN_MY_DRIVE", "IN_TEAM_DRIVE", "SHARED_IN_DRIVE", "NOT_IN_DRIVE" ],
            "type" : "string"
          },
          "embedUrl" : {
            "$ref" : "#/components/schemas/TrustedResourceUrlProto"
          },
          "encryptedDocId" : {
            "description" : "Indicates whether the Drive link contains an encrypted doc ID. If true, Dynamite should not attempt to query the doc ID in Drive Service. See go/docid-encryption for details.",
            "type" : "boolean"
          },
          "encryptedResourceKey" : {
            "description" : "This is deprecated and unneeded. TODO (b/182479059): Remove this.",
            "type" : "string"
          },
          "externalMimetype" : {
            "description" : "External mimetype of the Drive Resource (Useful for creating Drive URL) See: http://b/35219462",
            "type" : "string"
          },
          "id" : {
            "description" : "Drive resource ID of the artifact.",
            "type" : "string"
          },
          "isDownloadRestricted" : {
            "description" : "Deprecated. Whether the setting to restrict downloads is enabled for this file. This was previously used to determine whether to hide the download and print buttons in the UI, but is no longer used by clients, because Projector now independently queries Drive to ensure that we have the most up-to-date value.",
            "type" : "boolean"
          },
          "isOwner" : {
            "description" : "If the current user is the Drive file's owner. The field is currently only set for Annotations for the ListFiles action (as opposed to fetching Topics/Messages with Drive annotations).",
            "type" : "boolean"
          },
          "legacyUploadMetadata" : {
            "$ref" : "#/components/schemas/LegacyUploadMetadata"
          },
          "mimetype" : {
            "description" : "Mimetype of the Drive Resource",
            "type" : "string"
          },
          "organizationDisplayName" : {
            "description" : "The display name of the organization owning the Drive item.",
            "type" : "string"
          },
          "shortcutAuthorizedItemId" : {
            "$ref" : "#/components/schemas/AuthorizedItemId"
          },
          "shouldNotRender" : {
            "description" : "If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip.",
            "type" : "boolean"
          },
          "thumbnailHeight" : {
            "description" : "Thumbnail image of the Drive Resource",
            "format" : "int32",
            "type" : "integer"
          },
          "thumbnailUrl" : {
            "description" : "Thumbnail image of the Drive Resource",
            "type" : "string"
          },
          "thumbnailWidth" : {
            "description" : "Thumbnail image of the Drive Resource",
            "format" : "int32",
            "type" : "integer"
          },
          "title" : {
            "description" : "Title of the Drive Resource",
            "type" : "string"
          },
          "urlFragment" : {
            "description" : "Url string fragment that generally indicates the specific location in the linked file. Example: #header=h.123abc456. If the fragment is not present this will not be present and therefore default to an empty string. The \"#\" will not be included.",
            "type" : "string"
          },
          "wrappedResourceKey" : {
            "$ref" : "#/components/schemas/WrappedResourceKey"
          }
        },
        "type" : "object"
      },
      "DriveMimeTypeRestrict" : {
        "description" : "Drive mime-type search restricts (e.g. \"type:pdf\").",
        "properties" : {
          "type" : {
            "enum" : [ "UNSPECIFIED", "PDF", "DOCUMENT", "PRESENTATION", "SPREADSHEET", "FORM", "DRAWING", "SCRIPT", "MAP", "IMAGE", "AUDIO", "VIDEO", "FOLDER", "ARCHIVE", "SITE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DriveTimeSpanRestrict" : {
        "description" : "The time span search restrict (e.g. \"after:2017-09-11 before:2017-09-12\").",
        "properties" : {
          "type" : {
            "enum" : [ "UNSPECIFIED", "TODAY", "YESTERDAY", "LAST_7_DAYS", "LAST_30_DAYS", "LAST_90_DAYS" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "DynamiteMessagesScoringInfo" : {
        "description" : "This is the proto for holding message level scoring information. This data is used for logging in query-api server and for testing purposes.",
        "properties" : {
          "commonContactCount" : {
            "format" : "int64",
            "type" : "string"
          },
          "commonCountToContactListCountRatio" : {
            "format" : "double",
            "type" : "number"
          },
          "commonCountToMembershipCountRatio" : {
            "format" : "double",
            "type" : "number"
          },
          "creatorGaiaId" : {
            "format" : "int64",
            "type" : "string"
          },
          "creatorInSearcherContactList" : {
            "type" : "boolean"
          },
          "crowdingMultiplier" : {
            "format" : "double",
            "type" : "number"
          },
          "dasContactCount" : {
            "format" : "int64",
            "type" : "string"
          },
          "finalScore" : {
            "format" : "double",
            "type" : "number"
          },
          "freshnessScore" : {
            "format" : "double",
            "type" : "number"
          },
          "joinedSpaceAffinityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "lastReadTimestampAgeInDays" : {
            "format" : "double",
            "type" : "number"
          },
          "messageAgeInDays" : {
            "format" : "double",
            "type" : "number"
          },
          "messageSenderAffinityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "spaceId" : {
            "format" : "int64",
            "type" : "string"
          },
          "spaceMembershipCount" : {
            "format" : "int64",
            "type" : "string"
          },
          "topicalityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "unjoinedSpaceAffinityScore" : {
            "format" : "double",
            "type" : "number"
          }
        },
        "type" : "object"
      },
      "DynamiteSpacesScoringInfo" : {
        "description" : "This is the proto for holding space level scoring information. This data is used for logging in query-api server and for testing purposes.",
        "properties" : {
          "affinityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "commonContactCountAffinityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "contactsIntersectionCount" : {
            "format" : "double",
            "type" : "number"
          },
          "finalScore" : {
            "format" : "double",
            "type" : "number"
          },
          "freshnessScore" : {
            "format" : "double",
            "type" : "number"
          },
          "joinedSpacesAffinityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "lastMessagePostedTimestampSecs" : {
            "format" : "int64",
            "type" : "string"
          },
          "lastReadTimestampSecs" : {
            "format" : "int64",
            "type" : "string"
          },
          "memberMetadataCount" : {
            "format" : "double",
            "type" : "number"
          },
          "messageScore" : {
            "format" : "double",
            "type" : "number"
          },
          "numAucContacts" : {
            "format" : "int64",
            "type" : "string"
          },
          "smallContactListAffinityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "smallUnjoinedSpacesAffinityScore" : {
            "format" : "double",
            "type" : "number"
          },
          "spaceAgeInDays" : {
            "format" : "double",
            "type" : "number"
          },
          "spaceCreationTimestampSecs" : {
            "format" : "int64",
            "type" : "string"
          },
          "topicalityScore" : {
            "format" : "double",
            "type" : "number"
          }
        },
        "type" : "object"
      },
      "EditMetadata" : {
        "description" : "A message edit in Dynamite inserts a Babel-only item containing this field.",
        "type" : "object"
      },
      "EditorClientActionMarkup" : {
        "properties" : {
          "requestFileScopeForActiveDocument" : {
            "$ref" : "#/components/schemas/RequestFileScopeForActiveDocument"
          }
        },
        "type" : "object"
      },
      "EmailAddress" : {
        "description" : "A person's email address.",
        "properties" : {
          "customType" : {
            "description" : "If the value of type is custom, this property contains the custom type string.",
            "type" : "string"
          },
          "emailAddress" : {
            "description" : "The email address.",
            "type" : "string"
          },
          "emailUrl" : {
            "description" : "The URL to send email.",
            "type" : "string"
          },
          "primary" : {
            "description" : "Indicates if this is the user's primary email. Only one entry can be marked as primary.",
            "type" : "boolean"
          },
          "type" : {
            "description" : "The type of the email account. Acceptable values are: \"custom\", \"home\", \"other\", \"work\".",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "EmailOwnerProto" : {
        "description" : "Represents a verified owner of the given email address. Note that a single address may have many owners, and a single user may own many addresses. (All lower-case, in display form -- see com.google.gaia.client.GaiaEmail)",
        "properties" : {
          "email" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "EmbedClientItem" : {
        "description" : "Represents an embedded object in an update. This is a wrapper class that can contain a single specific item proto in an extension field. Think of it as a base class like `Message` in Java. Each item proto must declare that it extends this proto: message ExampleObject { option (item_type) = EXAMPLE_OBJECT; extend EmbedClientItem { optional ExampleObject example_object = ; } } See go/es-embeds for details.",
        "properties" : {
          "canonicalId" : {
            "description" : "The canonical ID of the embed. If absent, the canonical ID is equal to the ID; if present, then the canonical ID represents an \"equivalence class\" of embeds which really refer to the same object. (For example, the URLs http://www.foo.com/ and http://foo.com/ refer to the same object) This field may be updated periodically by background processes.",
            "type" : "string"
          },
          "deepLinkData" : {
            "$ref" : "#/components/schemas/DeepLinkData"
          },
          "id" : {
            "description" : "The ID of the embed. This corresponds to the schema.org ID, as represented in the ItemScope.id field.",
            "type" : "string"
          },
          "provenance" : {
            "$ref" : "#/components/schemas/Provenance"
          },
          "renderId" : {
            "description" : "The ID used to identify the embed during rendering. This field will match ID, if set, otherwise it will be the ID of the parent activity. This field is only populated on the server for client use and is not persisted to storage.",
            "type" : "string"
          },
          "signature" : {
            "description" : "Signature of the embed, used for verification.",
            "type" : "string"
          },
          "transientData" : {
            "$ref" : "#/components/schemas/TransientData"
          },
          "type" : {
            "description" : "The first value in `type` determines which extension field will be set. When creating an EmbedClientItem, you only need to set the first (primary) type in this field. When the server receives the item, it will populate the full type list using the parent annotations in the ItemType enum.",
            "items" : {
              "enum" : [ "UNKNOWN", "ACTION_V2", "ADD_ACTION_V2", "AGGREGATE_RATING_V2", "ARTICLE_V2", "ASSESS_ACTION_V2", "AUDIO_OBJECT_V2", "BASIC_INTERACTION_V2", "BLOG_POSTING_V2", "BLOG_V2", "BOOK_V2", "BUY_ACTION_V2", "CHECK_IN_ACTION_V2", "CHECKIN_V2", "COLLEXION_V2", "COMMENT_ACTION_V2", "COMMENT_V2", "COMMUNICATE_ACTION_V2", "CONSUME_ACTION_V2", "CREATE_ACTION_V2", "CREATIVE_WORK_V2", "DISCOVER_ACTION_V2", "DOCUMENT_OBJECT_V2", "DRAWING_OBJECT_V2", "DRIVE_OBJECT_V2", "EMOTISHARE_V2", "ENTRY_POINT_V2", "EVENT_TIME_V2", "EVENT_V2", "FILE_OBJECT_V2", "FIND_ACTION_V2", "FINANCIAL_QUOTE_V2", "FORM_OBJECT_V2", "GEO_COORDINATES_V2", "GOOGLE_OFFER_V2", "HANGOUT_CHAT_MESSAGE", "HANGOUT_QUOTE", "HANGOUT_V2", "HOA_PLUS_EVENT_V2", "IMAGE_OBJECT_V2", "INTERACT_ACTION_V2", "INTERACTION_V2", "LISTEN_ACTION_V2", "LOCAL_BUSINESS_V2", "LOCAL_PLUS_PHOTO_ALBUM_V2", "MAGAZINE_V2", "MEDIA_OBJECT_V2", "MOBILE_APPLICATION_V2", "MOVIE_V2", "MUSIC_ALBUM_V2", "MUSIC_GROUP_V2", "MUSIC_PLAYLIST_V2", "MUSIC_RECORDING_V2", "NEWS_ARTICLE_V2", "OFFER_V2", "ORGANIZATION_V2", "ORGANIZE_ACTION_V2", "PERSON_V2", "PLACE_REVIEW_V2", "PLACE_V2", "PLAN_ACTION_V2", "PLAY_MUSIC_ALBUM_V2", "PLAY_MUSIC_TRACK_V2", "PLAY_OBJECT_V2", "PLUS_AUDIO_V2", "PLUS_EVENT_V2", "PLUS_MEDIA_COLLECTION_V2", "PLUS_MEDIA_OBJECT_V2", "PLUS_PAGE_V2", "PLUS_PHOTOS_ADDED_TO_COLLECTION_V2", "PLUS_PHOTO_ALBUM_V2", "PLUS_PHOTO_COLLECTION_V2", "PLUS_PHOTO_V2", "PLUS_POST_V2", "PLUS_RESHARE_V2", "PLUS_SOFTWARE_APPLICATION_V2", "POLL_OPTION_V2", "POLL_V2", "POSTAL_ADDRESS_V2", "PRESENTATION_OBJECT_V2", "PRODUCT_REVIEW_V2", "RATING_V2", "REACT_ACTION_V2", "RESERVATION_V2", "RESERVE_ACTION_V2", "REVIEW_V2", "REVIEW_ACTION_V2", "SOFTWARE_APPLICATION_V2", "SPREADSHEET_OBJECT_V2", "SQUARE_INVITE_V2", "SQUARE_V2", "STICKER_V2", "STORY_V2", "THING_V2", "TRADE_ACTION_V2", "DEPRECATED_TOUR_OBJECT_V2", "TV_EPISODE_V2", "TV_SERIES_V2", "UPDATE_ACTION_V2", "VIEW_ACTION_V2", "VIDEO_OBJECT_V2", "VIDEO_GALLERY_V2", "WANT_ACTION_V2", "WEB_PAGE_V2", "WRITE_ACTION_V2", "YOUTUBE_CHANNEL_V2", "GOOGLE_USER_PHOTO_V2", "GOOGLE_USER_PHOTO_ALBUM", "GOOGLE_PHOTO_RECIPE", "THING", "CREATIVE_WORK", "EVENT", "INTANGIBLE", "ORGANIZATION", "PERSON", "PLACE", "PRODUCT", "ARTICLE", "BLOG_POSTING", "NEWS_ARTICLE", "SCHOLARLY_ARTICLE", "BLOG", "BOOK", "COMMENT", "ITEM_LIST", "MAP", "MEDIA_OBJECT", "AUDIO_OBJECT", "IMAGE_OBJECT", "MUSIC_VIDEO_OBJECT", "VIDEO_OBJECT", "MOVIE", "MUSIC_PLAYLIST", "MUSIC_ALBUM", "MUSIC_RECORDING", "PAINTING", "PHOTOGRAPH", "RECIPE", "REVIEW", "SCULPTURE", "SOFTWARE_APPLICATION", "MOBILE_APPLICATION", "WEB_APPLICATION", "TV_EPISODE", "TV_SEASON", "TV_SERIES", "WEB_PAGE", "ABOUT_PAGE", "CHECKOUT_PAGE", "COLLECTION_PAGE", "IMAGE_GALLERY", "VIDEO_GALLERY", "CONTACT_PAGE", "ITEM_PAGE", "PROFILE_PAGE", "SEARCH_RESULTS_PAGE", "WEB_PAGE_ELEMENT", "SITE_NAVIGATION_ELEMENT", "TABLE", "WP_AD_BLOCK", "WP_FOOTER", "WP_HEADER", "WP_SIDEBAR", "APP_INVITE", "EMOTISHARE", "BUSINESS_EVENT", "CHILDRENS_EVENT", "COMEDY_EVENT", "DANCE_EVENT", "EDUCATION_EVENT", "FESTIVAL", "FOOD_EVENT", "LITERARY_EVENT", "MUSIC_EVENT", "SALE_EVENT", "SOCIAL_EVENT", "SPORTS_EVENT", "THEATER_EVENT", "VISUAL_ARTS_EVENT", "RESERVATION", "TRAVEL_EVENT", "CORPORATION", "EDUCATIONAL_ORGANIZATION", "COLLEGE_OR_UNIVERSITY", "ELEMENTARY_SCHOOL", "HIGH_SCHOOL", "MIDDLE_SCHOOL", "PRESCHOOL", "SCHOOL", "GOVERNMENT_ORGANIZATION", "LOCAL_BUSINESS", "ANIMAL_SHELTER", "AUTOMOTIVE_BUSINESS", "AUTO_BODY_SHOP", "AUTO_DEALER", "AUTO_PARTS_STORE", "AUTO_RENTAL", "AUTO_REPAIR", "AUTO_WASH", "GAS_STATION", "MOTORCYCLE_DEALER", "MOTORCYCLE_REPAIR", "CHILD_CARE", "DRY_CLEANING_OR_LAUNDRY", "EMERGENCY_SERVICE", "FIRE_STATION", "HOSPITAL", "POLICE_STATION", "EMPLOYMENT_AGENGY", "ENTERTAINMENT_BUSINESS", "ADULT_ENTERTAINMENT", "AMUSEMENT_PARK", "ART_GALLERY", "CASINO", "COMEDY_CLUB", "MOVIE_THEATER", "NIGHT_CLUB", "FINANCIAL_SERVICE", "ACCOUNTING_SERVICE", "AUTOMATED_TELLER", "BANK_OR_CREDIT_UNION", "INSURANCE_AGENCY", "FOOD_ESTABLISHMENT", "BAKERY", "BAR_OR_PUB", "BREWERY", "CAFE_OR_COFFEE_SHOP", "FAST_FOOD_RESTAURANT", "ICE_CREAM_SHOP", "RESTAURANT", "WINERY", "GOVERNMENT_OFFICE", "POST_OFFICE", "HEALTH_AND_BEAUTY_BUSINESS", "BEAUTY_SALON", "DAY_SPA", "HAIR_SALON", "HEALTH_CLUB", "NAIL_SALON", "TATTOO_PARLOR", "HOME_AND_CONSTRUCTION_BUSINESS", "ELECTRICIAN", "GENERAL_CONTRACTOR", "HVAC_BUSINESS", "HOUSE_PAINTER", "LOCKSMITH", "MOVING_COMPANY", "PLUMBER", "ROOFING_CONTRACTOR", "INTERNET_CAFE", "LIBRARY", "LODGING_BUSINESS", "BED_AND_BREAKFAST", "HOSTEL", "HOTEL", "MOTEL", "MEDICAL_ORGANIZATION", "DENTIST", "MEDICAL_CLINIC", "OPTICIAN", "PHARMACY", "PHYSICIAN", "VETERINARY_CARE", "PROFESSIONAL_SERVICE", "ATTORNEY", "NOTARY", "RADIO_STATION", "REAL_ESTATE_AGENT", "RECYCLING_CENTER", "SELF_STORAGE", "SHOPPING_CENTER", "SPORTS_ACTIVITY_LOCATION", "BOWLING_ALLEY", "EXERCISE_GYM", "GOLF_COURSE", "PUBLIC_SWIMMING_POOL", "SKI_RESORT", "SPORTS_CLUB", "STADIUM_OR_ARENA", "TENNIS_COMPLEX", "STORE", "BIKE_STORE", "BOOK_STORE", "CLOTHING_STORE", "COMPUTER_STORE", "CONVENIENCE_STORE", "DEPARTMENT_STORE", "ELECTRONICS_STORE", "FLORIST", "FURNITURE_STORE", "GARDEN_STORE", "GROCERY_STORE", "HARDWARE_STORE", "HOBBY_SHOP", "HOME_GOODS_STORE", "JEWELRY_STORE", "LIQUOR_STORE", "MENS_CLOTHING_STORE", "MOBILE_PHONE_STORE", "MOVIE_RENTAL_STORE", "MUSIC_STORE", "OFFICE_EQUIPMENT_STORE", "OUTLET_STORE", "PAWN_SHOP", "PET_STORE", "SHOE_STORE", "SPORTING_GOODS_STORE", "TIRE_SHOP", "TOY_STORE", "WHOLESALE_STORE", "TELEVISION_STATION", "TOURIST_INFORMATION_CENTER", "TRAVEL_AGENCY", "PERFORMING_GROUP", "MUSIC_GROUP", "ADMINISTRATIVE_AREA", "CITY", "COUNTRY", "STATE", "CIVIC_STRUCTURE", "AIRPORT", "AQUARIUM", "BEACH", "BUS_STATION", "BUS_STOP", "CAMPGROUND", "CEMETERY", "CREMATORIUM", "EVENT_VENUE", "GOVERNMENT_BUILDING", "CITY_HALL", "COURTHOUSE", "DEFENCE_ESTABLISHMENT", "EMBASSY", "LEGISLATIVE_BUILDING", "MUSEUM", "MUSIC_VENUE", "PARK", "PARKING_FACILITY", "PERFORMING_ARTS_THEATER", "PLACE_OF_WORSHIP", "BUDDHIST_TEMPLE", "CATHOLIC_CHURCH", "CHURCH", "HINDU_TEMPLE", "MOSQUE", "SYNAGOGUE", "PLAYGROUND", "R_V_PARK", "RESIDENCE", "APARTMENT_COMPLEX", "GATED_RESIDENCE_COMMUNITY", "SINGLE_FAMILY_RESIDENCE", "TOURIST_ATTRACTION", "SUBWAY_STATION", "TAXI_STAND", "TRAIN_STATION", "ZOO", "LANDFORM", "BODY_OF_WATER", "CANAL", "LAKE_BODY_OF_WATER", "OCEAN_BODY_OF_WATER", "POND", "RESERVOIR", "RIVER_BODY_OF_WATER", "SEA_BODY_OF_WATER", "WATERFALL", "CONTINENT", "MOUNTAIN", "VOLCANO", "LANDMARKS_OR_HISTORICAL_BUILDINGS", "USER_INTERACTION", "USER_PLUS_ONES", "ENUMERATION", "BOOK_FORMAT_TYPE", "ITEM_AVAILABILITY", "OFFER_ITEM_CONDITION", "JOB_POSTING", "LANGUAGE", "OFFER", "QUANTITY", "DISTANCE", "DURATION", "ENERGY", "MASS", "RATING", "AGGREGATE_RATING", "STRUCTURED_VALUE", "CONTACT_POINT", "POSTAL_ADDRESS", "GEO_COORDINATES", "GEO_SHAPE", "NUTRITION_INFORMATION", "PRESENTATION_OBJECT", "DOCUMENT_OBJECT", "SPREADSHEET_OBJECT", "FORM_OBJECT", "DRAWING_OBJECT", "PLACE_REVIEW", "FILE_OBJECT", "PLAY_MUSIC_TRACK", "PLAY_MUSIC_ALBUM", "MAGAZINE", "CAROUSEL_FRAME", "PLUS_EVENT", "HANGOUT", "HANGOUT_BROADCAST", "HANGOUT_CONSUMER", "CHECKIN", "EXAMPLE_OBJECT", "SQUARE", "SQUARE_INVITE", "PLUS_PHOTO", "PLUS_PHOTO_ALBUM", "LOCAL_PLUS_PHOTO_ALBUM", "PRODUCT_REVIEW", "FINANCIAL_QUOTE", "DEPRECATED_TOUR_OBJECT", "PLUS_PAGE", "GOOGLE_CHART", "PLUS_PHOTOS_ADDED_TO_COLLECTION", "RECOMMENDED_PEOPLE", "PLUS_POST", "DATE", "DRIVE_OBJECT_COLLECTION", "NEWS_MEDIA_ORGANIZATION", "DYNAMITE_ATTACHMENT_METADATA", "DYNAMITE_MESSAGE_METADATA" ],
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "EnumOperatorOptions" : {
        "description" : "Used to provide a search operator for enum properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched. For example, if you provide no operator for a *priority* enum property with possible values *p0* and *p1*, a query that contains the term *p0* returns items that have *p0* as the value of the *priority* property, as well as any items that contain the string *p0* in other fields. If you provide an operator name for the enum, such as *priority*, then search users can use that operator to refine results to only items that have *p0* as this property's value, with the query *priority:p0*.",
        "properties" : {
          "operatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the enum property. For example, if operatorName is *priority* and the property's name is *priorityVal*, then queries like *priority:<value>* show results only where the value of the property named *priorityVal* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "EnumPropertyOptions" : {
        "description" : "The options for enum properties, which allow you to define a restricted set of strings to match user queries, set rankings for those string values, and define an operator name to be paired with those strings so that users can narrow results to only items with a specific value. For example, for items in a request tracking system with priority information, you could define *p0* as an allowable enum value and tie this enum to the operator name *priority* so that search users could add *priority:p0* to their query to restrict the set of results to only those items indexed with the value *p0*.",
        "properties" : {
          "operatorOptions" : {
            "$ref" : "#/components/schemas/EnumOperatorOptions"
          },
          "orderedRanking" : {
            "description" : "Used to specify the ordered ranking for the enumeration that determines how the integer values provided in the possible EnumValuePairs are used to rank results. If specified, integer values must be provided for all possible EnumValuePair values given for this property. Can only be used if isRepeatable is false.",
            "enum" : [ "NO_ORDER", "ASCENDING", "DESCENDING" ],
            "type" : "string"
          },
          "possibleValues" : {
            "description" : "The list of possible values for the enumeration property. All EnumValuePairs must provide a string value. If you specify an integer value for one EnumValuePair, then all possible EnumValuePairs must provide an integer value. Both the string value and integer value must be unique over all possible values. Once set, possible values cannot be removed or modified. If you supply an ordered ranking and think you might insert additional enum values in the future, leave gaps in the initial integer values to allow adding a value in between previously registered values. The maximum number of elements is 100.",
            "items" : {
              "$ref" : "#/components/schemas/EnumValuePair"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "EnumValuePair" : {
        "description" : "The enumeration value pair defines two things: a required string value and an optional integer value. The string value defines the necessary query term required to retrieve that item, such as *p0* for a priority item. The integer value determines the ranking of that string value relative to other enumerated values for the same property. For example, you might associate *p0* with *0* and define another enum pair such as *p1* and *1*. You must use the integer value in combination with ordered ranking to set the ranking of a given value relative to other enumerated values for the same property name. Here, a ranking order of DESCENDING for *priority* properties results in a ranking boost for items indexed with a value of *p0* compared to items indexed with a value of *p1*. Without a specified ranking order, the integer value has no effect on item ranking.",
        "properties" : {
          "integerValue" : {
            "description" : "The integer value of the EnumValuePair which must be non-negative. Optional.",
            "format" : "int32",
            "type" : "integer"
          },
          "stringValue" : {
            "description" : "The string value of the EnumValuePair. The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "EnumValues" : {
        "description" : "List of enum values.",
        "properties" : {
          "values" : {
            "description" : "The maximum allowable length for string values is 32 characters.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ErrorInfo" : {
        "description" : "Error information about the response.",
        "properties" : {
          "errorMessages" : {
            "items" : {
              "$ref" : "#/components/schemas/ErrorMessage"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ErrorMessage" : {
        "description" : "Error message per source response.",
        "properties" : {
          "errorMessage" : {
            "type" : "string"
          },
          "source" : {
            "$ref" : "#/components/schemas/Source"
          }
        },
        "type" : "object"
      },
      "EventAnnotation" : {
        "properties" : {
          "type" : {
            "format" : "int32",
            "type" : "integer"
          },
          "value" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "EventProto" : {
        "description" : "Represents the invitees or other users associated with a Google+ Event (see http://goto/events-backend-design).",
        "properties" : {
          "eventId" : {
            "description" : "Event IDs consist of alphanumeric characters and colons. Currently required.",
            "type" : "string"
          },
          "memberType" : {
            "description" : "The type of Event members to consider, e.g. \"all members\" vs. \"owners\" vs. \"admins\". These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See event.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with event. Currently required.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "FacetBucket" : {
        "description" : "A bucket in a facet is the basic unit of operation. A bucket can comprise either a single value OR a contiguous range of values, depending on the type of the field bucketed. FacetBucket is currently used only for returning the response object.",
        "properties" : {
          "count" : {
            "description" : "Number of results that match the bucket value. Counts are only returned for searches when count accuracy is ensured. Cloud Search does not guarantee facet counts for any query and facet counts might be present only intermittently, even for identical queries. Do not build dependencies on facet count existence; instead use facet ount percentages which are always returned.",
            "format" : "int32",
            "type" : "integer"
          },
          "filter" : {
            "$ref" : "#/components/schemas/Filter"
          },
          "percentage" : {
            "description" : "Percent of results that match the bucket value. The returned value is between (0-100], and is rounded down to an integer if fractional. If the value is not explicitly returned, it represents a percentage value that rounds to 0. Percentages are returned for all searches, but are an estimate. Because percentages are always returned, you should render percentages instead of counts.",
            "format" : "int32",
            "type" : "integer"
          },
          "value" : {
            "$ref" : "#/components/schemas/Value"
          }
        },
        "type" : "object"
      },
      "FacetOptions" : {
        "description" : "Specifies operators to return facet results for. There will be one FacetResult for every source_name/object_type/operator_name combination.",
        "properties" : {
          "integerFacetingOptions" : {
            "$ref" : "#/components/schemas/IntegerFacetingOptions"
          },
          "numFacetBuckets" : {
            "description" : "Maximum number of facet buckets that should be returned for this facet. Defaults to 10. Maximum value is 100.",
            "format" : "int32",
            "type" : "integer"
          },
          "objectType" : {
            "description" : "If object_type is set, only those objects of that type will be used to compute facets. If empty, then all objects will be used to compute facets.",
            "type" : "string"
          },
          "operatorName" : {
            "description" : "The name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions",
            "type" : "string"
          },
          "sourceName" : {
            "description" : "Source name to facet on. Format: datasources/{source_id} If empty, all data sources will be used.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "FacetResult" : {
        "description" : "Source specific facet response",
        "properties" : {
          "buckets" : {
            "description" : "FacetBuckets for values in response containing at least a single result with the corresponding filter.",
            "items" : {
              "$ref" : "#/components/schemas/FacetBucket"
            },
            "type" : "array"
          },
          "objectType" : {
            "description" : "Object type for which facet results are returned. Can be empty.",
            "type" : "string"
          },
          "operatorName" : {
            "description" : "The name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions",
            "type" : "string"
          },
          "sourceName" : {
            "description" : "Source name for which facet results are returned. Will not be empty.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "FieldViolation" : {
        "properties" : {
          "description" : {
            "description" : "The description of the error.",
            "type" : "string"
          },
          "field" : {
            "description" : "Path of field with violation.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Filter" : {
        "description" : "A generic way of expressing filters in a query, which supports two approaches: **1. Setting a ValueFilter.** The name must match an operator_name defined in the schema for your data source. **2. Setting a CompositeFilter.** The filters are evaluated using the logical operator. The top-level operators can only be either an AND or a NOT. AND can appear only at the top-most level. OR can appear only under a top-level AND.",
        "properties" : {
          "compositeFilter" : {
            "$ref" : "#/components/schemas/CompositeFilter"
          },
          "valueFilter" : {
            "$ref" : "#/components/schemas/ValueFilter"
          }
        },
        "type" : "object"
      },
      "FilterCreated" : {
        "description" : "A filter was created.",
        "type" : "object"
      },
      "FilterDeleted" : {
        "description" : "A filter was deleted.",
        "type" : "object"
      },
      "FilterOptions" : {
        "description" : "Filter options to be applied on query.",
        "properties" : {
          "filter" : {
            "$ref" : "#/components/schemas/Filter"
          },
          "objectType" : {
            "description" : "If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "FilterUpdate" : {
        "description" : "HistoryRecord for changes associated with a filter, namely: FILTER_CREATED FILTER_DELETED",
        "properties" : {
          "filterCreated" : {
            "$ref" : "#/components/schemas/FilterCreated"
          },
          "filterDeleted" : {
            "$ref" : "#/components/schemas/FilterDeleted"
          },
          "filterId" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "FixedFooter" : {
        "description" : "A persistent (sticky) footer that is added to the bottom of the card.",
        "properties" : {
          "buttons" : {
            "items" : {
              "$ref" : "#/components/schemas/Button"
            },
            "type" : "array"
          },
          "primaryButton" : {
            "$ref" : "#/components/schemas/TextButton"
          },
          "secondaryButton" : {
            "$ref" : "#/components/schemas/TextButton"
          }
        },
        "type" : "object"
      },
      "Folder" : {
        "properties" : {
          "id" : {
            "description" : "Folder mapping id.",
            "format" : "uint64",
            "type" : "string"
          },
          "message" : {
            "description" : "One for each copy of the message in the IMAP folder.",
            "items" : {
              "$ref" : "#/components/schemas/ImapsyncFolderAttributeFolderMessage"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "FolderAttribute" : {
        "description" : "This is the content of //imapsync/folder attribute.",
        "properties" : {
          "folder" : {
            "description" : "List of all IMAP folders where the message presents.",
            "items" : {
              "$ref" : "#/components/schemas/Folder"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "FormAction" : {
        "properties" : {
          "actionMethodName" : {
            "description" : "Apps script function that should be invoked in the developer's apps script when the containing element is clicked/activated.",
            "type" : "string"
          },
          "loadIndicator" : {
            "enum" : [ "SPINNER", "NONE" ],
            "type" : "string"
          },
          "parameters" : {
            "items" : {
              "$ref" : "#/components/schemas/ActionParameter"
            },
            "type" : "array"
          },
          "persistValues" : {
            "description" : "Indicates whether form values persist after the action. When false, the Apps Script is responsible for persisting values, by setting any form field values using the formInputs in the event. Disabling this behavior can be used if the add-on needs the ability to clear form fields, for example, as with persistent values, there is no means for clearing existing values. When disabling persistent values, it is strongly recommended that the add-on use LoadIndicator.SPINNER for all events, as this locks the UI to ensure no changes are made by the user while the action is being processed. When using LoadIndicator.NONE for any of the actions, persistent values are recommended, as it ensures that any changes made by the user after form / on change actions are sent to the server are not overwritten by the response. Persistent values disabled by default. While we recommend persistent values be used in the typical use case, we do not enable by default, as doing so would change the current behavior of existing add-ons in prod.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "FormatMetadata" : {
        "description" : "Annotation metadata for markup formatting",
        "properties" : {
          "fontColor" : {
            "description" : "Font color is set if and only if format_type is FONT_COLOR. The components are stored as (alpha << 24) | (red << 16) | (green << 8) | blue. Clients should always set the alpha component to 0xFF. NEXT TAG: 3",
            "format" : "uint32",
            "type" : "integer"
          },
          "formatType" : {
            "description" : "LINT.ThenChange(//depot/google3/apps/dynamite/v1/web/datakeys/annotated_span.proto)",
            "enum" : [ "TYPE_UNSPECIFIED", "BOLD", "ITALIC", "STRIKE", "SOURCE_CODE", "MONOSPACE", "HIDDEN", "MONOSPACE_BLOCK", "UNDERLINE", "FONT_COLOR", "BULLETED_LIST", "BULLETED_LIST_ITEM", "CLIENT_HIDDEN" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Formatting" : {
        "description" : "Formatting information for a segment.",
        "properties" : {
          "bold" : {
            "type" : "boolean"
          },
          "highlight" : {
            "description" : "This indicates that the segment should be rendered as highlighted or visually emphasized.",
            "type" : "boolean"
          },
          "italics" : {
            "type" : "boolean"
          },
          "strikethrough" : {
            "type" : "boolean"
          },
          "style" : {
            "description" : "If set, this indicates that the segment should be rendered with the specified style. The absence of an explicit style represents \"no style\", i.e. the segment can be rendered with the default style chosen by the application.",
            "enum" : [ "UNKNOWN_STYLE", "HEADING_1", "HEADING_2", "HEADING_3", "HEADING_4" ],
            "type" : "string"
          },
          "underline" : {
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "FreshnessOptions" : {
        "description" : "Indicates which freshness property to use when adjusting search ranking for an item. Fresher, more recent dates indicate higher quality. Use the freshness option property that best works with your data. For fileshare documents, last modified time is most relevant. For calendar event data, the time when the event occurs is a more relevant freshness indicator. In this way, calendar events that occur closer to the time of the search query are considered higher quality and ranked accordingly.",
        "properties" : {
          "freshnessDuration" : {
            "description" : "The duration after which an object should be considered stale. The default value is 180 days (in seconds).",
            "format" : "google-duration",
            "type" : "string"
          },
          "freshnessProperty" : {
            "description" : "This property indicates the freshness level of the object in the index. If set, this property must be a top-level property within the property definitions and it must be a timestamp type or date type. Otherwise, the Indexing API uses updateTime as the freshness indicator. The maximum length is 256 characters. When a property is used to calculate freshness, the value defaults to 2 years from the current time.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "FuseboxItem" : {
        "description" : "The Item message is the read interface for user data (traditionally referred to as a \"message\", such as a mail message or a chat message, but generalized to encompass other types such as tasks) and stored in Tingle. Each Item is associated with a single Thread. An Item contains three classes of data. (1): Item \"fields\" are common to items of all message types (e.g. mail, chat, task, etc.) and are identified by the ItemFieldSpec.FetchType enum when fetching Items. (2): Item \"attributes\" represent data associated with an Item that is stored on behalf of the client but to which the fusebox and storage layers are otherwise agnostic. (3): Item \"parts\" are application-defined protocol buffers that affect how the Item is indexed. Item parts are referenced as extensions to the ItemParts message. By default the application specifies the index terms associated with an Item part. For performance sensitive applications, the storage layer can be modified to understand and index data types natively.",
        "properties" : {
          "attributes" : {
            "$ref" : "#/components/schemas/Attributes"
          },
          "creationTimeMicroseconds" : {
            "description" : "The creation time of the Item in micro seconds.",
            "format" : "uint64",
            "type" : "string"
          },
          "history" : {
            "$ref" : "#/components/schemas/History"
          },
          "itemKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "labels" : {
            "$ref" : "#/components/schemas/Labels"
          },
          "lastModificationTimeUs" : {
            "description" : "The modification time of the Item in micro seconds. Modifications to the message include label addition, deletion, etc.",
            "format" : "uint64",
            "type" : "string"
          },
          "lockerReferences" : {
            "$ref" : "#/components/schemas/References"
          },
          "matchInfo" : {
            "$ref" : "#/components/schemas/MatchInfo"
          },
          "parts" : {
            "$ref" : "#/components/schemas/ItemParts"
          },
          "readTs" : {
            "description" : "The read timestamp at which this item was read. This is a temporary field used to check if two items streamed during dual reading were read at the same timestamp. This will be populated by Fusebox RPCs. \"DO NOT USE UNLESS YOU TALK TO FUSEBOX TEAM (gmail-fusebox@)\".",
            "format" : "int64",
            "type" : "string"
          },
          "references" : {
            "$ref" : "#/components/schemas/References"
          },
          "snippet" : {
            "description" : "The snippet is a brief bit of text describing this item.",
            "type" : "string"
          },
          "threadKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "threadLocator" : {
            "description" : "A base64 encoded and encrypted string generated from the Gaia Id and the thread id. Used to generate the permalink for this thread, exposed from Gmail API.",
            "type" : "string"
          },
          "triggers" : {
            "$ref" : "#/components/schemas/Triggers"
          },
          "version" : {
            "description" : "The latest history operation id that resulted in a mutation of the item.",
            "format" : "uint64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "FuseboxItemThreadMatchInfo" : {
        "description" : "In the context of a search, the MatchInfo contains information about which Items matched the query.",
        "properties" : {
          "clusterId" : {
            "description" : "If SearchQuery.Options.Clustering is present, the query will be treated as a cluster query, and this field may be populated with the cluster ID of the cluster to which this thread belongs, if any. The cluster ID will be a label on the message.",
            "type" : "string"
          },
          "lastMatchingItemId" : {
            "description" : "The server id of the last item that matched the query. This is always set, regardless of the compute_matching_items_per_thread option. This is the value by which search results are sorted, in descending (i.e. newest first) order.",
            "format" : "uint64",
            "type" : "string"
          },
          "lastMatchingItemKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "matchingItemKey" : {
            "description" : "If SearchQuery.Options.compute_matching_items_per_thread, this field will contain the keys of all items that matched the query, in ascending order. Note that this option requires extra computation.",
            "items" : {
              "$ref" : "#/components/schemas/MultiKey"
            },
            "type" : "array"
          },
          "rank" : {
            "$ref" : "#/components/schemas/Rank"
          }
        },
        "type" : "object"
      },
      "FuseboxPrefUpdatePreState" : {
        "description" : "If the Value field is not set this means the pref did not exist.",
        "properties" : {
          "value" : {
            "format" : "byte",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GSuitePrincipal" : {
        "properties" : {
          "gsuiteDomain" : {
            "description" : "This principal represents all users of the Google Workspace domain of the customer.",
            "type" : "boolean"
          },
          "gsuiteGroupEmail" : {
            "description" : "This principal references a Google Workspace group name.",
            "type" : "string"
          },
          "gsuiteUserEmail" : {
            "description" : "This principal references a Google Workspace user account.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GaiaGroupProto" : {
        "properties" : {
          "groupId" : {
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GaiaUserProto" : {
        "description" : "A Gaia account, which may represent a user, device, service account, etc. For prod (@prod.google.com) accounts, use MdbUserProto instead.",
        "properties" : {
          "userId" : {
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GatewayAccess" : {
        "description" : "Details on the third-party interoperability settings for the meeting space.",
        "properties" : {
          "enabled" : {
            "description" : "Whether third-party gateway accesses are enabled for this meeting space. If enabled, the actual access code can be retrieved by calling the GetGatewayAccess RPC method.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "GatewaySipAccess" : {
        "description" : "Details how to join the conference via a SIP gateway.",
        "properties" : {
          "sipAccessCode" : {
            "description" : "Permanent numeric code for manual entry on specially configured devices, currently the same as the PSTN \"Universal pin\".",
            "type" : "string"
          },
          "uri" : {
            "description" : "The SIP URI the conference can be reached through. The string is on one of the formats: \"sip:@\" \"sips:@\" where currently is the 13-digit universal pin (with the future option to support using a Meet meeting code as well), and is a valid address to be resolved using a DNS SRV lookup, or a dotted quad.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GetCustomerIndexStatsResponse" : {
        "properties" : {
          "averageIndexedItemCount" : {
            "description" : "Average item count for the given date range for which billing is done.",
            "format" : "int64",
            "type" : "string"
          },
          "stats" : {
            "description" : "Summary of indexed item counts, one for each day in the requested range.",
            "items" : {
              "$ref" : "#/components/schemas/CustomerIndexStats"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GetCustomerQueryStatsResponse" : {
        "properties" : {
          "stats" : {
            "items" : {
              "$ref" : "#/components/schemas/CustomerQueryStats"
            },
            "type" : "array"
          },
          "totalQueryCount" : {
            "description" : "Total successful query count (status code 200) for the given date range.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GetCustomerSearchApplicationStatsResponse" : {
        "description" : "Response format for search application stats for a customer.",
        "properties" : {
          "averageSearchApplicationCount" : {
            "description" : "Average search application count for the given date range.",
            "format" : "int64",
            "type" : "string"
          },
          "stats" : {
            "description" : "Search application stats by date.",
            "items" : {
              "$ref" : "#/components/schemas/CustomerSearchApplicationStats"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GetCustomerSessionStatsResponse" : {
        "properties" : {
          "stats" : {
            "items" : {
              "$ref" : "#/components/schemas/CustomerSessionStats"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GetCustomerUserStatsResponse" : {
        "properties" : {
          "stats" : {
            "items" : {
              "$ref" : "#/components/schemas/CustomerUserStats"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GetDataSourceIndexStatsResponse" : {
        "properties" : {
          "averageIndexedItemCount" : {
            "description" : "Average item count for the given date range for which billing is done.",
            "format" : "int64",
            "type" : "string"
          },
          "stats" : {
            "description" : "Summary of indexed item counts, one for each day in the requested range.",
            "items" : {
              "$ref" : "#/components/schemas/DataSourceIndexStats"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GetSearchApplicationQueryStatsResponse" : {
        "description" : "Response format for getting query stats for a search application between given dates.",
        "properties" : {
          "stats" : {
            "description" : "Query stats per date for a search application.",
            "items" : {
              "$ref" : "#/components/schemas/SearchApplicationQueryStats"
            },
            "type" : "array"
          },
          "totalQueryCount" : {
            "description" : "Total successful query count (status code 200) for the given date range.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GetSearchApplicationSessionStatsResponse" : {
        "properties" : {
          "stats" : {
            "items" : {
              "$ref" : "#/components/schemas/SearchApplicationSessionStats"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GetSearchApplicationUserStatsResponse" : {
        "properties" : {
          "stats" : {
            "items" : {
              "$ref" : "#/components/schemas/SearchApplicationUserStats"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GmailClientActionMarkup" : {
        "properties" : {
          "addonComposeUiActionMarkup" : {
            "$ref" : "#/components/schemas/AddonComposeUiActionMarkup"
          },
          "openCreatedDraftActionMarkup" : {
            "$ref" : "#/components/schemas/OpenCreatedDraftActionMarkup"
          },
          "taskAction" : {
            "$ref" : "#/components/schemas/TaskActionMarkup"
          },
          "updateDraftActionMarkup" : {
            "$ref" : "#/components/schemas/UpdateDraftActionMarkup"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1ContextualAddOnMarkup" : {
        "description" : "The markup for developers to specify the contents of a contextual AddOn.",
        "properties" : {
          "cards" : {
            "description" : "A list of cards. A card must contain a header and at least 1 section.",
            "items" : {
              "$ref" : "#/components/schemas/GoogleChatV1ContextualAddOnMarkupCard"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1ContextualAddOnMarkupCard" : {
        "description" : "A card is a UI element that can contain UI widgets such as texts, images.",
        "properties" : {
          "cardActions" : {
            "description" : "The actions of this card.",
            "items" : {
              "$ref" : "#/components/schemas/GoogleChatV1ContextualAddOnMarkupCardCardAction"
            },
            "type" : "array"
          },
          "header" : {
            "$ref" : "#/components/schemas/GoogleChatV1ContextualAddOnMarkupCardCardHeader"
          },
          "name" : {
            "description" : "Name of the card.",
            "type" : "string"
          },
          "sections" : {
            "description" : "Sections are separated by a line divider.",
            "items" : {
              "$ref" : "#/components/schemas/GoogleChatV1ContextualAddOnMarkupCardSection"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1ContextualAddOnMarkupCardCardAction" : {
        "description" : "A card action is the action associated with the card. For an invoice card, a typical action would be: delete invoice, email invoice or open the invoice in browser. Not supported by Google Chat apps.",
        "properties" : {
          "actionLabel" : {
            "description" : "The label used to be displayed in the action menu item.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupOnClick"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1ContextualAddOnMarkupCardCardHeader" : {
        "properties" : {
          "imageStyle" : {
            "description" : "The image's type (e.g. square border or circular border).",
            "enum" : [ "IMAGE_STYLE_UNSPECIFIED", "IMAGE", "AVATAR" ],
            "type" : "string"
          },
          "imageUrl" : {
            "description" : "The URL of the image in the card header.",
            "type" : "string"
          },
          "subtitle" : {
            "description" : "The subtitle of the card header.",
            "type" : "string"
          },
          "title" : {
            "description" : "The title must be specified. The header has a fixed height: if both a title and subtitle is specified, each will take up 1 line. If only the title is specified, it will take up both lines.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1ContextualAddOnMarkupCardSection" : {
        "description" : "A section contains a collection of widgets that are rendered (vertically) in the order that they are specified. Across all platforms, cards have a narrow fixed width, so there is currently no need for layout properties (e.g. float).",
        "properties" : {
          "header" : {
            "description" : "The header of the section, text formatted supported.",
            "type" : "string"
          },
          "widgets" : {
            "description" : "A section must contain at least 1 widget.",
            "items" : {
              "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkup"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkup" : {
        "description" : "A widget is a UI element that presents texts, images, etc.",
        "properties" : {
          "buttons" : {
            "description" : "A list of buttons. Buttons is also oneof data and only one of these fields should be set.",
            "items" : {
              "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupButton"
            },
            "type" : "array"
          },
          "image" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupImage"
          },
          "keyValue" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupKeyValue"
          },
          "textParagraph" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupTextParagraph"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupButton" : {
        "description" : "A button. Can be a text button or an image button.",
        "properties" : {
          "imageButton" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupImageButton"
          },
          "textButton" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupTextButton"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupFormAction" : {
        "description" : "A form action describes the behavior when the form is submitted. For example, an Apps Script can be invoked to handle the form.",
        "properties" : {
          "actionMethodName" : {
            "description" : "The method name is used to identify which part of the form triggered the form submission. This information is echoed back to the Chat app as part of the card click event. The same method name can be used for several elements that trigger a common behavior if desired.",
            "type" : "string"
          },
          "parameters" : {
            "description" : "List of action parameters.",
            "items" : {
              "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupFormActionActionParameter"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupFormActionActionParameter" : {
        "description" : "List of string parameters to supply when the action method is invoked. For example, consider three snooze buttons: snooze now, snooze 1 day, snooze next week. You might use action method = snooze(), passing the snooze type and snooze time in the list of string parameters.",
        "properties" : {
          "key" : {
            "description" : "The name of the parameter for the action script.",
            "type" : "string"
          },
          "value" : {
            "description" : "The value of the parameter.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupImage" : {
        "description" : "An image that is specified by a URL and can have an onclick action.",
        "properties" : {
          "aspectRatio" : {
            "description" : "The aspect ratio of this image (width/height). This field allows clients to reserve the right height for the image while waiting for it to load. It's not meant to override the native aspect ratio of the image. If unset, the server fills it by prefetching the image.",
            "format" : "double",
            "type" : "number"
          },
          "imageUrl" : {
            "description" : "The URL of the image.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupOnClick"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupImageButton" : {
        "description" : "An image button with an onclick action.",
        "properties" : {
          "icon" : {
            "description" : "The icon specified by an enum that indices to an icon provided by Chat API.",
            "enum" : [ "ICON_UNSPECIFIED", "AIRPLANE", "BOOKMARK", "BUS", "CAR", "CLOCK", "CONFIRMATION_NUMBER_ICON", "DOLLAR", "DESCRIPTION", "EMAIL", "EVENT_PERFORMER", "EVENT_SEAT", "FLIGHT_ARRIVAL", "FLIGHT_DEPARTURE", "HOTEL", "HOTEL_ROOM_TYPE", "INVITE", "MAP_PIN", "MEMBERSHIP", "MULTIPLE_PEOPLE", "OFFER", "PERSON", "PHONE", "RESTAURANT_ICON", "SHOPPING_CART", "STAR", "STORE", "TICKET", "TRAIN", "VIDEO_CAMERA", "VIDEO_PLAY" ],
            "type" : "string"
          },
          "iconUrl" : {
            "description" : "The icon specified by a URL.",
            "type" : "string"
          },
          "name" : {
            "description" : "The name of this image_button which will be used for accessibility. Default value will be provided if developers don't specify.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupOnClick"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupKeyValue" : {
        "description" : "A UI element contains a key (label) and a value (content). And this element may also contain some actions such as onclick button.",
        "properties" : {
          "bottomLabel" : {
            "description" : "The text of the bottom label. Formatted text supported.",
            "type" : "string"
          },
          "button" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupButton"
          },
          "content" : {
            "description" : "The text of the content. Formatted text supported and always required.",
            "type" : "string"
          },
          "contentMultiline" : {
            "description" : "If the content should be multiline.",
            "type" : "boolean"
          },
          "icon" : {
            "description" : "An enum value that will be replaced by the Chat API with the corresponding icon image.",
            "enum" : [ "ICON_UNSPECIFIED", "AIRPLANE", "BOOKMARK", "BUS", "CAR", "CLOCK", "CONFIRMATION_NUMBER_ICON", "DOLLAR", "DESCRIPTION", "EMAIL", "EVENT_PERFORMER", "EVENT_SEAT", "FLIGHT_ARRIVAL", "FLIGHT_DEPARTURE", "HOTEL", "HOTEL_ROOM_TYPE", "INVITE", "MAP_PIN", "MEMBERSHIP", "MULTIPLE_PEOPLE", "OFFER", "PERSON", "PHONE", "RESTAURANT_ICON", "SHOPPING_CART", "STAR", "STORE", "TICKET", "TRAIN", "VIDEO_CAMERA", "VIDEO_PLAY" ],
            "type" : "string"
          },
          "iconUrl" : {
            "description" : "The icon specified by a URL.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupOnClick"
          },
          "topLabel" : {
            "description" : "The text of the top label. Formatted text supported.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupOnClick" : {
        "description" : "An onclick action (e.g. open a link).",
        "properties" : {
          "action" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupFormAction"
          },
          "openLink" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupOpenLink"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupOpenLink" : {
        "description" : "A link that opens a new window.",
        "properties" : {
          "url" : {
            "description" : "The URL to open.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupTextButton" : {
        "description" : "A button with text and onclick action.",
        "properties" : {
          "onClick" : {
            "$ref" : "#/components/schemas/GoogleChatV1WidgetMarkupOnClick"
          },
          "text" : {
            "description" : "The text of the button.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GoogleChatV1WidgetMarkupTextParagraph" : {
        "description" : "A paragraph of text. Formatted text supported.",
        "properties" : {
          "text" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GoogleDocsMetadata" : {
        "description" : "The corpus specific metadata for office-type documents, from Google Docs and other sources. This message is passed to the scorer and beyond. Next tag: 9",
        "properties" : {
          "aclInfo" : {
            "$ref" : "#/components/schemas/AclInfo"
          },
          "documentType" : {
            "description" : "The conceptual type (presentation, document, etc.) of this document.",
            "enum" : [ "UNKNOWN", "DOCUMENT", "PRESENTATION", "SPREADSHEET", "PDF", "IMAGE", "BINARY_BLOB", "FUSION_TABLE", "FOLDER", "DRAWING", "VIDEO", "FORM", "DRAFT_SITE", "DRAFT_SITE_PAGE", "JAM", "SHORTCUT", "SCRIPT" ],
            "type" : "string"
          },
          "fileExtension" : {
            "description" : "The file extension of the document. NOTE: As of October 2018 this field is not backfilled for old documents.",
            "type" : "string"
          },
          "lastContentModifiedTimestamp" : {
            "description" : "The last time this document was modified, in seconds since epoch. Only counts content modifications.",
            "format" : "int64",
            "type" : "string"
          },
          "numSubscribers" : {
            "description" : "Contains number of subscribers for the document.",
            "format" : "int32",
            "type" : "integer"
          },
          "numViewers" : {
            "description" : "Size of untruncated viewers list.",
            "format" : "int32",
            "type" : "integer"
          },
          "resultInfo" : {
            "$ref" : "#/components/schemas/GoogleDocsResultInfo"
          },
          "typeInfo" : {
            "$ref" : "#/components/schemas/TypeInfo"
          }
        },
        "type" : "object"
      },
      "GoogleDocsResultInfo" : {
        "description" : "A message containing information about a specific result. This information is passed to the scorer and beyond; in particular, GWS relies on it to format the result in the UI. Split from GoogleDocsMetadata in case we later want to reuse the message.",
        "properties" : {
          "attachmentSha1" : {
            "description" : "The SHA1 hash of the object in Drive, if any.",
            "type" : "string"
          },
          "cosmoId" : {
            "$ref" : "#/components/schemas/Id"
          },
          "cosmoNameSpace" : {
            "description" : "For Cosmo objects, the Cosmo namespace the object was in. This allows downstream clients to identify whether a document was created in Writely or Kix, Presently or Punch, or whether it was uploaded from GDrive. See storage_cosmo.Id.NAME_SPACE for a list of all Cosmo name spaces.",
            "format" : "int32",
            "type" : "integer"
          },
          "encryptedId" : {
            "description" : "The encrypted (user-visible) id of this object. Knowing the id is sufficient to create a canonical URL for this document.",
            "type" : "string"
          },
          "mimeType" : {
            "description" : "The mimetype of the document.",
            "type" : "string"
          },
          "shareScope" : {
            "$ref" : "#/components/schemas/ShareScope"
          }
        },
        "type" : "object"
      },
      "Grid" : {
        "properties" : {
          "borderStyle" : {
            "$ref" : "#/components/schemas/BorderStyle"
          },
          "items" : {
            "description" : "The items to display in the grid.",
            "items" : {
              "$ref" : "#/components/schemas/GridItem"
            },
            "type" : "array"
          },
          "numColumns" : {
            "description" : "The number of columns to display in the grid. Note that a default value will be used if this field is not specified, and that default value will be different depending on where the grid is shown (dialog vs companion).",
            "format" : "int32",
            "type" : "integer"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          },
          "title" : {
            "description" : "The text to display in the grid header.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GridItem" : {
        "properties" : {
          "identifier" : {
            "description" : "A user-specified identifier for this grid item. This identifier will be returned in the parent Grid's on_click callback's parameters.",
            "type" : "string"
          },
          "image" : {
            "$ref" : "#/components/schemas/ImageComponent"
          },
          "layout" : {
            "enum" : [ "NOT_SET", "TEXT_BELOW", "TEXT_ABOVE" ],
            "type" : "string"
          },
          "subtitle" : {
            "type" : "string"
          },
          "textAlignment" : {
            "enum" : [ "HORIZONTAL_ALIGNMENT_UNSPECIFIED", "START", "CENTER", "END" ],
            "type" : "string"
          },
          "title" : {
            "description" : "Text properties.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GroupDetailsUpdatedMetadata" : {
        "properties" : {
          "newGroupDetails" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedGroupDetails"
          },
          "prevGroupDetails" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedGroupDetails"
          }
        },
        "type" : "object"
      },
      "GroupId" : {
        "description" : "Id representing a group that could be a space, a chat, or a direct message space. Which ID is set here will determine which group",
        "properties" : {
          "dmId" : {
            "$ref" : "#/components/schemas/DmId"
          },
          "spaceId" : {
            "$ref" : "#/components/schemas/SpaceId"
          }
        },
        "type" : "object"
      },
      "GroupLinkSharingModificationEvent" : {
        "properties" : {
          "newStatus" : {
            "enum" : [ "UNKNOWN_LINK_SHARING_STATUS", "LINK_SHARING_ON", "LINK_SHARING_OFF", "NOT_AVAILABLE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "GroupRetentionSettingsUpdatedMetaData" : {
        "properties" : {
          "initiator" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "retentionSettings" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedRetentionSettings"
          }
        },
        "type" : "object"
      },
      "GsuiteIntegrationMetadata" : {
        "description" : "Annotation metadata for an GsuiteIntegration artifact.",
        "properties" : {
          "activityFeedData" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedActivityFeedAnnotationData"
          },
          "assistantData" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAssistantAnnotationData"
          },
          "calendarEventData" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCalendarEventAnnotationData"
          },
          "callData" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedCallAnnotationData"
          },
          "clientType" : {
            "enum" : [ "UNKNOWN_CLIENT_TYPE", "MEET", "TASKS", "CALENDAR_EVENT", "ASSISTANT", "ACTIVITY_FEED_SERVICE" ],
            "type" : "string"
          },
          "indexableTexts" : {
            "description" : "A list of all strings that are to be indexed for this 1P chip. Each string in this list would be the contents of a single string field in the 1P chip. Eg. For Tasks[title = “hello world”, description = “good bye”]. If we want to index only the title, this would be set to [“hello world”]. If both title and description, then this would be [“hello world”, “good bye”]. Please make sure that the contents of this field is a subset of strings that are rendered as part of the 1P Chip.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "tasksData" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedTasksAnnotationData"
          }
        },
        "type" : "object"
      },
      "HangoutEvent" : {
        "properties" : {
          "hangoutDurationSecs" : {
            "format" : "int64",
            "type" : "string"
          },
          "mediaType" : {
            "enum" : [ "AUDIO_VIDEO", "AUDIO_ONLY", "PUSH_TO_TALK" ],
            "type" : "string"
          },
          "participantId" : {
            "items" : {
              "$ref" : "#/components/schemas/StoredParticipantId"
            },
            "type" : "array"
          },
          "type" : {
            "enum" : [ "START_HANGOUT", "JOIN_HANGOUT", "LEAVE_HANGOUT", "END_HANGOUT", "HANGOUT_COMING_SOON", "ONGOING_HANGOUT" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "HangoutVideoEventMetadata" : {
        "description" : "A message representing the Hangout video start/end events in Babel",
        "properties" : {
          "hangoutVideoType" : {
            "enum" : [ "UNKNOWN_HANGOUT_VIDEO_EVENT_TYPE", "VIDEO_START", "VIDEO_END" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "HashtagData" : {
        "description" : "Hashtag metadata, for HASHTAG segments. For a hashtag, the \"text\" field should contain the display text, and the search_text field should represent the topic being referenced, without the hash symbol; for example, we might have: text = \"#Google\" hashtag_data.search_text = \"Google\" Another example: text = \"#pikachu\" hashtag_data.search_text = \"Pokemon\" Both strings should be considered part of the searchable text. In go/sbe, both are indexed and searchable.",
        "properties" : {
          "searchText" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "History" : {
        "description" : "The most recent history records associated with the item.",
        "properties" : {
          "record" : {
            "items" : {
              "$ref" : "#/components/schemas/HistoryRecord"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "HistoryRecord" : {
        "properties" : {
          "clientContext" : {
            "$ref" : "#/components/schemas/ClientContext"
          },
          "filterUpdate" : {
            "$ref" : "#/components/schemas/FilterUpdate"
          },
          "imapUpdate" : {
            "$ref" : "#/components/schemas/ImapUpdate"
          },
          "labelUpdate" : {
            "$ref" : "#/components/schemas/LabelUpdate"
          },
          "prefUpdate" : {
            "$ref" : "#/components/schemas/PrefUpdate"
          },
          "recordId" : {
            "description" : "Each HistoryRecord has a unique id. Ids are monotonically increasing, and not necessarily contiguous.",
            "format" : "uint64",
            "type" : "string"
          },
          "threadUpdate" : {
            "$ref" : "#/components/schemas/ThreadUpdate"
          },
          "transactionContext" : {
            "$ref" : "#/components/schemas/TransactionContext"
          },
          "txnDebugInfo" : {
            "$ref" : "#/components/schemas/TransactionDebugInfo"
          },
          "type" : {
            "enum" : [ "UNKNOWN", "INTERNAL", "MESSAGE_ADDED", "MESSAGE_DELETED", "LABEL_ADDED", "LABEL_REMOVED", "ATTRIBUTE_SET", "ATTRIBUTE_REMOVED", "THREAD_KEY_SET", "LABEL_CREATED", "LABEL_DELETED", "LABEL_RENAMED", "LABEL_UPDATED", "PREF_WRITTEN", "PREF_DELETED", "FILTER_CREATED", "FILTER_DELETED", "IMAP_UIDS_REASSIGN", "TOPIC_STATE_UPDATED", "TXN_DEBUG_INFO" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "HostAppActionMarkup" : {
        "description" : "Actions handled by individual host apps.",
        "properties" : {
          "calendarAction" : {
            "$ref" : "#/components/schemas/CalendarClientActionMarkup"
          },
          "chatAction" : {
            "$ref" : "#/components/schemas/ChatClientActionMarkup"
          },
          "driveAction" : {
            "$ref" : "#/components/schemas/DriveClientActionMarkup"
          },
          "editorAction" : {
            "$ref" : "#/components/schemas/EditorClientActionMarkup"
          },
          "gmailAction" : {
            "$ref" : "#/components/schemas/GmailClientActionMarkup"
          },
          "sheetsAction" : {
            "$ref" : "#/components/schemas/SheetsClientActionMarkup"
          }
        },
        "type" : "object"
      },
      "HostProto" : {
        "description" : "Represents a single host. Optionally, the MDB owner of the host can be specified.",
        "properties" : {
          "hostName" : {
            "description" : "Lower-case, fully qualified hostname.",
            "type" : "string"
          },
          "hostOwner" : {
            "description" : "If present, then any checks that compare this Principal to LOAS peer info must confirm the peer's machine owner is equal to 'host_owner'. If absent, then any peer machine owner is acceptable.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "HtmlOperatorOptions" : {
        "description" : "Used to provide a search operator for html properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.",
        "properties" : {
          "operatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the html property. For example, if operatorName is *subject* and the property's name is *subjectLine*, then queries like *subject:<value>* show results only where the value of the property named *subjectLine* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator return all items where *<value>* matches the value of any html properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "HtmlPropertyOptions" : {
        "description" : "The options for html properties.",
        "properties" : {
          "operatorOptions" : {
            "$ref" : "#/components/schemas/HtmlOperatorOptions"
          },
          "retrievalImportance" : {
            "$ref" : "#/components/schemas/RetrievalImportance"
          }
        },
        "type" : "object"
      },
      "HtmlValues" : {
        "description" : "List of html values.",
        "properties" : {
          "values" : {
            "description" : "The maximum allowable length for html values is 2048 characters.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "IconImage" : {
        "properties" : {
          "altText" : {
            "description" : "The alternative text of this icon_url which will be used for accessibility.",
            "type" : "string"
          },
          "icon" : {
            "enum" : [ "NONE", "AIRPLANE", "BOOKMARK", "BUS", "CAR", "CLOCK", "CONFIRMATION_NUMBER_ICON", "DOLLAR", "DESCRIPTION", "EDIT", "EDIT_NOTE", "EMAIL", "EVENT_PERFORMER", "EVENT_SEAT", "FLIGHT_ARRIVAL", "FLIGHT_DEPARTURE", "HOTEL", "HOTEL_ROOM_TYPE", "INVITE", "MAP_PIN", "MEMBERSHIP", "MULTIPLE_PEOPLE", "OFFER", "OPEN_IN_NEW", "PERSON", "PHONE", "RESTAURANT_ICON", "SHOPPING_CART", "STAR", "STORE", "TICKET", "TRAIN", "VIDEO_CAMERA", "VIDEO_PLAY" ],
            "type" : "string"
          },
          "iconUrl" : {
            "type" : "string"
          },
          "imageStyle" : {
            "description" : "The image cropping style. Note that icons with a CIRCLE style are rendered larger than the default icon size.",
            "enum" : [ "CROP_TYPE_NOT_SET", "SQUARE", "CIRCLE", "RECTANGLE_CUSTOM", "RECTANGLE_4_3" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Id" : {
        "description" : "Identifies a particular object, including both Users and DirEntries. This Id is unique across the entire server instance, such as the production or qa instance.",
        "properties" : {
          "creatorUserId" : {
            "description" : "The User account in which the DirEntry was originally created. If name_space==GAIA, then it's the gaia_id of the user this id is referring to.",
            "format" : "uint64",
            "type" : "string"
          },
          "localId" : {
            "description" : "The local identifier for the DirEntry (local to the creator's account). local_id + app_name is guaranteed to be unique within the creator account, but not across all User accounts. The string is case sensitive. Ignore if name_space==GAIA. NB For name_space==COSMO, all local_id's should be defined in google3/java/com/google/storage/cosmo/server/api/SpecialObjectIds.java as they have a special predefined meaning. See cosmo.client.CosmoIdFactory.createObjectId(long,String) for IMPORTANT recommendations when generating IDs.",
            "type" : "string"
          },
          "nameSpace" : {
            "description" : "The name space in which this id is unique (typically the application that created it). Values should be drawn from the above enum, but for experimentation, use values greater than 1000.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "Image" : {
        "properties" : {
          "altText" : {
            "description" : "The alternative text of this image which will be used for accessibility.",
            "type" : "string"
          },
          "aspectRatio" : {
            "description" : "The aspect ratio of this image (width/height).",
            "format" : "double",
            "type" : "number"
          },
          "imageUrl" : {
            "description" : "Image url specified by developers. Server side, we will wrap with FIFE so client apps can configure size/cropping/etc.",
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          }
        },
        "type" : "object"
      },
      "ImageButton" : {
        "properties" : {
          "icon" : {
            "enum" : [ "NONE", "AIRPLANE", "BOOKMARK", "BUS", "CAR", "CLOCK", "CONFIRMATION_NUMBER_ICON", "DOLLAR", "DESCRIPTION", "EDIT", "EDIT_NOTE", "EMAIL", "EVENT_PERFORMER", "EVENT_SEAT", "FLIGHT_ARRIVAL", "FLIGHT_DEPARTURE", "HOTEL", "HOTEL_ROOM_TYPE", "INVITE", "MAP_PIN", "MEMBERSHIP", "MULTIPLE_PEOPLE", "OFFER", "OPEN_IN_NEW", "PERSON", "PHONE", "RESTAURANT_ICON", "SHOPPING_CART", "STAR", "STORE", "TICKET", "TRAIN", "VIDEO_CAMERA", "VIDEO_PLAY" ],
            "type" : "string"
          },
          "iconUrl" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          }
        },
        "type" : "object"
      },
      "ImageComponent" : {
        "description" : "NOTE: Through future refactoring work, this image component will eventually be used in the Image widget, and will likely replace the Icon proto as well.",
        "properties" : {
          "altText" : {
            "type" : "string"
          },
          "borderStyle" : {
            "$ref" : "#/components/schemas/BorderStyle"
          },
          "cropStyle" : {
            "$ref" : "#/components/schemas/ImageCropStyle"
          },
          "imageUrl" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ImageCropStyle" : {
        "description" : "Represents a crop style that can be applied to an image.",
        "properties" : {
          "aspectRatio" : {
            "description" : "The aspect ratio to use if the crop type is RECTANGLE_CUSTOM.",
            "format" : "double",
            "type" : "number"
          },
          "type" : {
            "description" : "The crop type.",
            "enum" : [ "CROP_TYPE_NOT_SET", "SQUARE", "CIRCLE", "RECTANGLE_CUSTOM", "RECTANGLE_4_3" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ImageKeyValue" : {
        "description" : "This is deprecated and please use KeyValue.",
        "properties" : {
          "icon" : {
            "enum" : [ "NONE", "AIRPLANE", "BOOKMARK", "BUS", "CAR", "CLOCK", "CONFIRMATION_NUMBER_ICON", "DOLLAR", "DESCRIPTION", "EDIT", "EDIT_NOTE", "EMAIL", "EVENT_PERFORMER", "EVENT_SEAT", "FLIGHT_ARRIVAL", "FLIGHT_DEPARTURE", "HOTEL", "HOTEL_ROOM_TYPE", "INVITE", "MAP_PIN", "MEMBERSHIP", "MULTIPLE_PEOPLE", "OFFER", "OPEN_IN_NEW", "PERSON", "PHONE", "RESTAURANT_ICON", "SHOPPING_CART", "STAR", "STORE", "TICKET", "TRAIN", "VIDEO_CAMERA", "VIDEO_PLAY" ],
            "type" : "string"
          },
          "iconUrl" : {
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          },
          "text" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ImapSessionContext" : {
        "properties" : {
          "app" : {
            "enum" : [ "OTHER_APP", "CHROME", "FIREFOX", "MSIE", "SAFARI", "OPERA", "EDGE", "MSIE_COMPATIBILITY", "OTHER_BROWSER", "SAMSUNG_BROWSER", "UC_BROWSER", "ANDROID_BROWSER", "YANDEX_BROWSER", "SILK_BROWSER", "COC_COC_BROWSER", "MAX_BROWSER_APP_VALUE", "GMAIL_APP", "GMAIL_INBOX_APP", "ANDROID_EMAIL_APP", "SAMSUNG_MAIL_APP", "MOTO_EMAIL_APP", "BOXER_APP", "LIMILABS_MAIL_DLL", "BIS_APP", "OUTLOOK_MAIL_APP", "APPLE_NATIVE_APP", "CHROME_WEBVIEW_APP", "SAFARI_WEBVIEW_APP", "CHROME_SYNC_APP", "GSA_APP", "GMM_APP", "CALENDAR_APP", "PLUS_APP", "HANGOUTS_APP", "HANGOUTS_MEET_APP", "JAMBOARD_APP", "VOICE_APP", "PHOTOS_APP", "DRIVE_SYNC_APP", "DRIVE_APP", "DOCS_APP", "SHEETS_APP", "SLIDES_APP", "KEEP_APP", "WHATS_APP_IN_DRIVE_APP", "TRANSLATE_APP", "YOUTUBE_APP", "YOUTUBE_MUSIC_APP", "YOUTUBE_GAMING_APP", "YOUTUBE_KIDS_APP", "YOUTUBE_CAPTURE_APP", "YOUTUBE_CREATOR_APP", "YOUTUBE_GO_APP", "YOUTUBE_TV_APP", "YOUTUBE_VR_APP", "PLAY_APP", "PLAY_MUSIC_APP", "PLAY_BOOKS_APP", "PLAY_MOVIES_APP", "PLAY_NEWSSTAND_APP", "PLAY_GAMES_APP", "POKEMON_GO_APP", "ALLO_APP", "DUO_APP", "CLASSROOM_APP", "TRIPS_APP", "GOOGLE_PAY_APP", "WAZE_APP", "ASSISTANT_APP", "GBOARD_APP", "NEWS_APP", "HOME_APP", "EARTH_APP", "STREET_VIEW_APP", "TEZ_APP", "GOOGLE_ANALYTICS_APP", "ADSENSE_APP", "ADWORDS_APP", "EXPRESS_APP", "WEAR_APP", "GOOGLE_MY_BUSINESS_APP", "FAMILY_LINK_APP", "OPINION_REWARDS_APP", "WALLET_APP", "ARTS_AND_CULTURE_APP", "ANDROID_DEVICE_MANAGER_APP", "GOOGLE_GO_APP", "FILES_GO_APP", "DATALLY_APP", "WIFI_APP", "STADIA_APP", "BATTLESTAR_APP", "SMART_LOCK_APP", "LOGDOG_APP", "DEPRECATED_MAC_OSX_MAIL_APP", "DEPRECATED_IOS_MAIL_APP" ],
            "type" : "string"
          },
          "deviceType" : {
            "description" : "User agent information",
            "enum" : [ "UNKNOWN", "PC", "MOBILE", "TABLET", "PORTABLE_MEDIA_PLAYER", "TV", "GAME_CONSOLE", "MEDIA_PLAYER", "SMART_SPEAKER", "SMART_DISPLAY", "CONNECTED_HOME_OTHER", "WEARABLE", "GLASS", "CAR", "VR_HEADSET" ],
            "type" : "string"
          },
          "guidFingerprint" : {
            "description" : "As agreed with Bond team, this holds the fingerprint of any \"aguid\" or \"guid\" provided by the ID command. The fingerprint should be calculated by fingerprint2011. Note that not all clients will provide aguid or guid through ID command.",
            "format" : "uint64",
            "type" : "string"
          },
          "os" : {
            "enum" : [ "UNKNOWN_OS", "ANDROID_OS", "IOS_OS", "BLACKBERRY_OS", "WIN_PHONE_OS", "FIRE_OS", "MAX_MOBILE_OS_VALUE", "WINDOWS_OS", "LINUX_OS", "MAC_OS", "CHROME_OS", "PLAYSTATION_OS", "XBOX_OS", "TIZEN_OS", "APPLE_TV_OS", "KAI_OS", "ANDROID_THINGS_OS", "CAST_OS", "STADIA_OS" ],
            "type" : "string"
          },
          "osVersion" : {
            "$ref" : "#/components/schemas/OsVersion"
          },
          "possiblyTrimmedModel" : {
            "$ref" : "#/components/schemas/PossiblyTrimmedModel"
          }
        },
        "type" : "object"
      },
      "ImapSyncDelete" : {
        "description" : "Message delete history record extension that exports //imapsync/folder attribute of deleted messages which have ^is label.",
        "properties" : {
          "mappings" : {
            "$ref" : "#/components/schemas/FolderAttribute"
          },
          "msgId" : {
            "format" : "uint64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ImapUidsReassign" : {
        "properties" : {
          "labelId" : {
            "description" : "Label",
            "type" : "string"
          },
          "messageId" : {
            "description" : "The message Ids",
            "items" : {
              "format" : "uint64",
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ImapUpdate" : {
        "description" : "HistoryRecord for changes associated with IMAP, namely: IMAP_UIDS_REASSIGN",
        "properties" : {
          "imapUidsReassign" : {
            "$ref" : "#/components/schemas/ImapUidsReassign"
          }
        },
        "type" : "object"
      },
      "ImapsyncFolderAttributeFolderMessage" : {
        "properties" : {
          "flags" : {
            "$ref" : "#/components/schemas/ImapsyncFolderAttributeFolderMessageFlags"
          },
          "uid" : {
            "description" : "UID of the message.",
            "format" : "uint64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ImapsyncFolderAttributeFolderMessageFlags" : {
        "properties" : {
          "flagged" : {
            "description" : "Flagged state of the message.",
            "type" : "boolean"
          },
          "seen" : {
            "description" : "Seen state of the message.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "IncomingWebhookChangedMetadata" : {
        "description" : "Annotation metadata to display system messages for incoming webhook events. Next Tag: 7",
        "properties" : {
          "incomingWebhookName" : {
            "description" : "The webhook name at the time of the change. Used in Spanner storage, BE API responses and FE API responses.",
            "type" : "string"
          },
          "initiatorId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "initiatorProfile" : {
            "$ref" : "#/components/schemas/User"
          },
          "obfuscatedIncomingWebhookId" : {
            "description" : "The webhook id of the incoming webhook in question. This field should not be used to load webhook information dynamically and is only present for debugging purposes. Used in Spanner storage, BE API responses and FE API responses.",
            "type" : "string"
          },
          "oldIncomingWebhookName" : {
            "description" : "Only populated for UPDATED_NAME and UPDATED_NAME_AND_AVATAR events, where the webhook name was changed. Used in Spanner storage, BE API responses and FE API responses.",
            "type" : "string"
          },
          "type" : {
            "description" : "Used in Spanner storage, BE API responses and FE API responses.",
            "enum" : [ "UNSPECIFIED", "ADDED", "UPDATED", "REMOVED", "UPDATED_NAME", "UPDATED_AVATAR", "UPDATED_NAME_AND_AVATAR" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "IndexItemOptions" : {
        "properties" : {
          "allowUnknownGsuitePrincipals" : {
            "description" : "Specifies if the index request should allow Google Workspace principals that do not exist or are deleted.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "IndexItemRequest" : {
        "properties" : {
          "connectorName" : {
            "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
            "type" : "string"
          },
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "indexItemOptions" : {
            "$ref" : "#/components/schemas/IndexItemOptions"
          },
          "item" : {
            "$ref" : "#/components/schemas/Item"
          },
          "mode" : {
            "description" : "Required. The RequestMode for this request.",
            "enum" : [ "UNSPECIFIED", "SYNCHRONOUS", "ASYNCHRONOUS" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "InitializeCustomerRequest" : {
        "description" : "Request message for `InitializeCustomer` method.",
        "type" : "object"
      },
      "InsertContent" : {
        "properties" : {
          "content" : {
            "description" : "The content to be inserted.",
            "type" : "string"
          },
          "contentType" : {
            "description" : "The type of inserted content.",
            "enum" : [ "UNSPECIFIED_CONTENT_TYPE", "TEXT", "MUTABLE_HTML", "IMMUTABLE_HTML" ],
            "type" : "string"
          },
          "mimeType" : {
            "enum" : [ "UNSPECIFIED_EMAIL_MIME_TYPE", "PLAIN_TEXT", "HTML" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "IntegerFacetingOptions" : {
        "description" : "Used to specify integer faceting options.",
        "properties" : {
          "integerBuckets" : {
            "description" : "Buckets for given integer values should be in strictly ascending order. For example, if values supplied are (1,5,10,100), the following facet buckets will be formed {<1, [1,5), [5-10), [10-100), >=100}.",
            "items" : {
              "format" : "int64",
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "IntegerOperatorOptions" : {
        "description" : "Used to provide a search operator for integer properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.",
        "properties" : {
          "greaterThanOperatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the integer property using the greater-than operator. For example, if greaterThanOperatorName is *priorityabove* and the property's name is *priorityVal*, then queries like *priorityabove:<value>* show results only where the value of the property named *priorityVal* is greater than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          },
          "lessThanOperatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the integer property using the less-than operator. For example, if lessThanOperatorName is *prioritybelow* and the property's name is *priorityVal*, then queries like *prioritybelow:<value>* show results only where the value of the property named *priorityVal* is less than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          },
          "operatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the integer property. For example, if operatorName is *priority* and the property's name is *priorityVal*, then queries like *priority:<value>* show results only where the value of the property named *priorityVal* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "IntegerPropertyOptions" : {
        "description" : "The options for integer properties.",
        "properties" : {
          "integerFacetingOptions" : {
            "$ref" : "#/components/schemas/IntegerFacetingOptions"
          },
          "maximumValue" : {
            "description" : "The maximum value of the property. The minimum and maximum values for the property are used to rank results according to the ordered ranking. Indexing requests with values greater than the maximum are accepted and ranked with the same weight as items indexed with the maximum value.",
            "format" : "int64",
            "type" : "string"
          },
          "minimumValue" : {
            "description" : "The minimum value of the property. The minimum and maximum values for the property are used to rank results according to the ordered ranking. Indexing requests with values less than the minimum are accepted and ranked with the same weight as items indexed with the minimum value.",
            "format" : "int64",
            "type" : "string"
          },
          "operatorOptions" : {
            "$ref" : "#/components/schemas/IntegerOperatorOptions"
          },
          "orderedRanking" : {
            "description" : "Used to specify the ordered ranking for the integer. Can only be used if isRepeatable is false.",
            "enum" : [ "NO_ORDER", "ASCENDING", "DESCENDING" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "IntegerValues" : {
        "description" : "List of integer values.",
        "properties" : {
          "values" : {
            "items" : {
              "format" : "int64",
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "IntegrationConfigMutation" : {
        "properties" : {
          "addApp" : {
            "$ref" : "#/components/schemas/AppId"
          },
          "addPinnedItem" : {
            "$ref" : "#/components/schemas/PinnedItemId"
          },
          "removeApp" : {
            "$ref" : "#/components/schemas/AppId"
          },
          "removePinnedItem" : {
            "$ref" : "#/components/schemas/PinnedItemId"
          }
        },
        "type" : "object"
      },
      "IntegrationConfigUpdatedMetadata" : {
        "description" : "Annotation metadata to display system message for integration config updated event. This metadata is stored in spanner, and can be dispatched to clients without any field modification or transformation.",
        "properties" : {
          "initiatorId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "mutations" : {
            "description" : "A list of updates applied on the integration config.",
            "items" : {
              "$ref" : "#/components/schemas/IntegrationConfigMutation"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "Interaction" : {
        "description" : "Represents an interaction between a user and an item.",
        "properties" : {
          "interactionTime" : {
            "description" : "The time when the user acted on the item. If multiple actions of the same type exist for a single user, only the most recent action is recorded.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "principal" : {
            "$ref" : "#/components/schemas/Principal"
          },
          "type" : {
            "enum" : [ "UNSPECIFIED", "VIEW", "EDIT" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "InteractionData" : {
        "description" : "Interaction data for an annotation, which may be supplemental to the metadata oneof. For example, this will contain the fully built navigation target for smart chips. NEXT TAG: 2",
        "properties" : {
          "url" : {
            "$ref" : "#/components/schemas/SafeUrlProto"
          }
        },
        "type" : "object"
      },
      "InviteAcceptedEvent" : {
        "properties" : {
          "participantId" : {
            "items" : {
              "$ref" : "#/components/schemas/StoredParticipantId"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "InviteeInfo" : {
        "description" : "Invitee information from a Dynamite invitation. See go/dynamite-invitee-mgmt.",
        "properties" : {
          "email" : {
            "description" : "Email as typed by the user when invited to Room or DM. This value will be canonicalized and hashed before retained in storage.",
            "type" : "string"
          },
          "userId" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "Item" : {
        "description" : "Represents a single object that is an item in the search index, such as a file, folder, or a database record.",
        "properties" : {
          "acl" : {
            "$ref" : "#/components/schemas/ItemAcl"
          },
          "content" : {
            "$ref" : "#/components/schemas/ItemContent"
          },
          "itemType" : {
            "description" : "The type for this item.",
            "enum" : [ "UNSPECIFIED", "CONTENT_ITEM", "CONTAINER_ITEM", "VIRTUAL_CONTAINER_ITEM" ],
            "type" : "string"
          },
          "metadata" : {
            "$ref" : "#/components/schemas/ItemMetadata"
          },
          "name" : {
            "description" : "The name of the Item. Format: datasources/{source_id}/items/{item_id} This is a required field. The maximum length is 1536 characters.",
            "type" : "string"
          },
          "payload" : {
            "description" : "Additional state connector can store for this item. The maximum length is 10000 bytes.",
            "format" : "byte",
            "type" : "string"
          },
          "queue" : {
            "description" : "Queue this item belongs to. The maximum length is 100 characters.",
            "type" : "string"
          },
          "status" : {
            "$ref" : "#/components/schemas/ItemStatus"
          },
          "structuredData" : {
            "$ref" : "#/components/schemas/ItemStructuredData"
          },
          "version" : {
            "description" : "Required. The indexing system stores the version from the datasource as a byte string and compares the Item version in the index to the version of the queued Item using lexical ordering. Cloud Search Indexing won't index or delete any queued item with a version value that is less than or equal to the version of the currently indexed item. The maximum length for this field is 1024 bytes. For information on how item version affects the deletion process, refer to [Handle revisions after manual deletes](https://developers.google.com/cloud-search/docs/guides/operations).",
            "format" : "byte",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ItemAcl" : {
        "description" : "Access control list information for the item. For more information see [Map ACLs](https://developers.google.com/cloud-search/docs/guides/acls).",
        "properties" : {
          "aclInheritanceType" : {
            "description" : "Sets the type of access rules to apply when an item inherits its ACL from a parent. This should always be set in tandem with the inheritAclFrom field. Also, when the inheritAclFrom field is set, this field should be set to a valid AclInheritanceType.",
            "enum" : [ "NOT_APPLICABLE", "CHILD_OVERRIDE", "PARENT_OVERRIDE", "BOTH_PERMIT" ],
            "type" : "string"
          },
          "deniedReaders" : {
            "description" : "List of principals who are explicitly denied access to the item in search results. While principals are denied access by default, use denied readers to handle exceptions and override the list allowed readers. The maximum number of elements is 100.",
            "items" : {
              "$ref" : "#/components/schemas/Principal"
            },
            "type" : "array"
          },
          "inheritAclFrom" : {
            "description" : "The name of the item to inherit the Access Permission List (ACL) from. Note: ACL inheritance *only* provides access permissions to child items and does not define structural relationships, nor does it provide convenient ways to delete large groups of items. Deleting an ACL parent from the index only alters the access permissions of child items that reference the parent in the inheritAclFrom field. The item is still in the index, but may not visible in search results. By contrast, deletion of a container item also deletes all items that reference the container via the containerName field. The maximum length for this field is 1536 characters.",
            "type" : "string"
          },
          "owners" : {
            "description" : "Optional. List of owners for the item. This field has no bearing on document access permissions. It does, however, offer a slight ranking boosts items where the querying user is an owner. The maximum number of elements is 5.",
            "items" : {
              "$ref" : "#/components/schemas/Principal"
            },
            "type" : "array"
          },
          "readers" : {
            "description" : "List of principals who are allowed to see the item in search results. Optional if inheriting permissions from another item or if the item is not intended to be visible, such as virtual containers. The maximum number of elements is 1000.",
            "items" : {
              "$ref" : "#/components/schemas/Principal"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ItemContent" : {
        "description" : "Content of an item to be indexed and surfaced by Cloud Search. Only UTF-8 encoded strings are allowed as inlineContent. If the content is uploaded and not binary, it must be UTF-8 encoded.",
        "properties" : {
          "contentDataRef" : {
            "$ref" : "#/components/schemas/UploadItemRef"
          },
          "contentFormat" : {
            "enum" : [ "UNSPECIFIED", "HTML", "TEXT", "RAW" ],
            "type" : "string"
          },
          "hash" : {
            "description" : "Hashing info calculated and provided by the API client for content. Can be used with the items.push method to calculate modified state. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "inlineContent" : {
            "description" : "Content that is supplied inlined within the update method. The maximum length is 102400 bytes (100 KiB).",
            "format" : "byte",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ItemCountByStatus" : {
        "properties" : {
          "count" : {
            "description" : "Number of items matching the status code.",
            "format" : "int64",
            "type" : "string"
          },
          "indexedItemsCount" : {
            "description" : "Number of items matching the status code for which billing is done. This excludes virtual container items from the total count. This count would not be applicable for items with ERROR or NEW_ITEM status code.",
            "format" : "int64",
            "type" : "string"
          },
          "statusCode" : {
            "description" : "Status of the items.",
            "enum" : [ "CODE_UNSPECIFIED", "ERROR", "MODIFIED", "NEW_ITEM", "ACCEPTED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ItemMetadata" : {
        "description" : "Available metadata fields for the item.",
        "properties" : {
          "containerName" : {
            "description" : "The name of the container for this item. Deletion of the container item leads to automatic deletion of this item. Note: ACLs are not inherited from a container item. To provide ACL inheritance for an item, use the inheritAclFrom field. The maximum length is 1536 characters.",
            "type" : "string"
          },
          "contentLanguage" : {
            "description" : "The BCP-47 language code for the item, such as \"en-US\" or \"sr-Latn\". For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. The maximum length is 32 characters.",
            "type" : "string"
          },
          "contextAttributes" : {
            "description" : "A set of named attributes associated with the item. This can be used for influencing the ranking of the item based on the context in the request. The maximum number of elements is 10.",
            "items" : {
              "$ref" : "#/components/schemas/ContextAttribute"
            },
            "type" : "array"
          },
          "createTime" : {
            "description" : "The time when the item was created in the source repository.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "hash" : {
            "description" : "Hashing value provided by the API caller. This can be used with the items.push method to calculate modified state. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "interactions" : {
            "description" : "A list of interactions for the item. Interactions are used to improve Search quality, but are not exposed to end users. The maximum number of elements is 1000.",
            "items" : {
              "$ref" : "#/components/schemas/Interaction"
            },
            "type" : "array"
          },
          "keywords" : {
            "description" : "Additional keywords or phrases that should match the item. Used internally for user generated content. The maximum number of elements is 100. The maximum length is 8192 characters.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "mimeType" : {
            "description" : "The original mime-type of ItemContent.content in the source repository. The maximum length is 256 characters.",
            "type" : "string"
          },
          "objectType" : {
            "description" : "The type of the item. This should correspond to the name of an object definition in the schema registered for the data source. For example, if the schema for the data source contains an object definition with name 'document', then item indexing requests for objects of that type should set objectType to 'document'. The maximum length is 256 characters.",
            "type" : "string"
          },
          "searchQualityMetadata" : {
            "$ref" : "#/components/schemas/SearchQualityMetadata"
          },
          "sourceRepositoryUrl" : {
            "description" : "Link to the source repository serving the data. Seach results apply this link to the title. Whitespace or special characters may cause Cloud Seach result links to trigger a redirect notice; to avoid this, encode the URL. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "title" : {
            "description" : "The title of the item. If given, this will be the displayed title of the Search result. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "updateTime" : {
            "description" : "The time when the item was last modified in the source repository.",
            "format" : "google-datetime",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ItemParts" : {
        "description" : "Container for type-specific extensions of an Item. This protobuf is defined in a separate file to allow types to reference/extend the message without depending on other fusebox protobufs. See items.proto.",
        "type" : "object"
      },
      "ItemStatus" : {
        "description" : "This contains item's status and any errors.",
        "properties" : {
          "code" : {
            "description" : "Status code.",
            "enum" : [ "CODE_UNSPECIFIED", "ERROR", "MODIFIED", "NEW_ITEM", "ACCEPTED" ],
            "type" : "string"
          },
          "processingErrors" : {
            "description" : "Error details in case the item is in ERROR state.",
            "items" : {
              "$ref" : "#/components/schemas/ProcessingError"
            },
            "type" : "array"
          },
          "repositoryErrors" : {
            "description" : "Repository error reported by connector.",
            "items" : {
              "$ref" : "#/components/schemas/RepositoryError"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ItemStructuredData" : {
        "description" : "Available structured data fields for the item.",
        "properties" : {
          "hash" : {
            "description" : "Hashing value provided by the API caller. This can be used with the items.push method to calculate modified state. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "object" : {
            "$ref" : "#/components/schemas/StructuredDataObject"
          }
        },
        "type" : "object"
      },
      "ItemThread" : {
        "description" : "An ItemThread is an ordered list of Items. An ItemThread corresponds to a \"conversation\" in the context of mail. An Item belongs to exactly one ItemThread.",
        "properties" : {
          "clusterInfo" : {
            "$ref" : "#/components/schemas/ClusterInfo"
          },
          "item" : {
            "description" : "The Items in the ItemThread. In the context of a search, the list of Items may be a subset of those that logically belong to the ItemThread. The details of which items are included are available in the ItemThreadView returned in the overall rpc response.",
            "items" : {
              "$ref" : "#/components/schemas/FuseboxItem"
            },
            "type" : "array"
          },
          "lastItemId" : {
            "description" : "The server id of the last item returned in the ItemThread. This can be deduced from the [item] list but is provided for convenience. When manually constructing an ItemThreadViewSpec to perform operations on the ItemThread, this value can be used as the [high_item_id_watermark].",
            "format" : "uint64",
            "type" : "string"
          },
          "matchInfo" : {
            "$ref" : "#/components/schemas/FuseboxItemThreadMatchInfo"
          },
          "snippet" : {
            "description" : "A snippet summarizing the thread. This field is only populated for searches.",
            "type" : "string"
          },
          "threadKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "threadLocator" : {
            "description" : "A base64 encoded and encrypted string generated from the Gaia Id and the thread id. Used to generate the permalink for this thread, exposed from Gmail API.",
            "type" : "string"
          },
          "topicState" : {
            "$ref" : "#/components/schemas/TopicState"
          },
          "version" : {
            "description" : "The latest history operation id that resulted in a mutation of any item in the thread.",
            "format" : "uint64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "JobsettedServerSpec" : {
        "description" : "Identifies a jobsetted server as a target for Trigger dispatch.",
        "properties" : {
          "portName" : {
            "description" : "E.g. \"gateway\", \"stubby\" etc. Leave unset to use the default unnamed port.",
            "type" : "string"
          },
          "serverName" : {
            "description" : "E.g. \"satellite-server\", \"bigtop-sync\", etc.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "KeyValue" : {
        "properties" : {
          "bottomLabel" : {
            "description" : "Formatted text supported.",
            "type" : "string"
          },
          "button" : {
            "$ref" : "#/components/schemas/Button"
          },
          "content" : {
            "description" : "Formatted text supported and always required.",
            "type" : "string"
          },
          "contentMultiline" : {
            "type" : "boolean"
          },
          "endIcon" : {
            "$ref" : "#/components/schemas/IconImage"
          },
          "icon" : {
            "enum" : [ "NONE", "AIRPLANE", "BOOKMARK", "BUS", "CAR", "CLOCK", "CONFIRMATION_NUMBER_ICON", "DOLLAR", "DESCRIPTION", "EDIT", "EDIT_NOTE", "EMAIL", "EVENT_PERFORMER", "EVENT_SEAT", "FLIGHT_ARRIVAL", "FLIGHT_DEPARTURE", "HOTEL", "HOTEL_ROOM_TYPE", "INVITE", "MAP_PIN", "MEMBERSHIP", "MULTIPLE_PEOPLE", "OFFER", "OPEN_IN_NEW", "PERSON", "PHONE", "RESTAURANT_ICON", "SHOPPING_CART", "STAR", "STORE", "TICKET", "TRAIN", "VIDEO_CAMERA", "VIDEO_PLAY" ],
            "type" : "string"
          },
          "iconAltText" : {
            "description" : "The alternative text of this icon_url which will be used for accessibility.",
            "type" : "string"
          },
          "iconUrl" : {
            "type" : "string"
          },
          "imageStyle" : {
            "enum" : [ "CROP_TYPE_NOT_SET", "SQUARE", "CIRCLE", "RECTANGLE_CUSTOM", "RECTANGLE_4_3" ],
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          },
          "startIcon" : {
            "$ref" : "#/components/schemas/IconImage"
          },
          "switchWidget" : {
            "$ref" : "#/components/schemas/SwitchWidget"
          },
          "topLabel" : {
            "description" : "Formatted text supported.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "LabelAdded" : {
        "description" : "A label was added to some (subset of the) messages in this thread.",
        "properties" : {
          "labelId" : {
            "type" : "string"
          },
          "labelName" : {
            "type" : "string"
          },
          "messageKeys" : {
            "items" : {
              "$ref" : "#/components/schemas/MultiKey"
            },
            "type" : "array"
          },
          "syncId" : {
            "format" : "uint32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "LabelCreated" : {
        "description" : "A label was created.",
        "type" : "object"
      },
      "LabelDeleted" : {
        "description" : "A label was deleted.",
        "type" : "object"
      },
      "LabelRemoved" : {
        "description" : "A label was removed from some (subset of the) messages in this thread.",
        "properties" : {
          "labelId" : {
            "type" : "string"
          },
          "labelName" : {
            "type" : "string"
          },
          "messageKeys" : {
            "items" : {
              "$ref" : "#/components/schemas/MultiKey"
            },
            "type" : "array"
          },
          "syncId" : {
            "format" : "uint32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "LabelRenamed" : {
        "description" : "A label was renamed.",
        "properties" : {
          "oldCanonicalName" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "LabelUpdate" : {
        "description" : "HistoryRecord for changes associated with a label, namely: LABEL_CREATED LABEL_DELETED LABEL_RENAMED LABEL_UPDATED",
        "properties" : {
          "canonicalName" : {
            "type" : "string"
          },
          "labelCreated" : {
            "$ref" : "#/components/schemas/LabelCreated"
          },
          "labelDeleted" : {
            "$ref" : "#/components/schemas/LabelDeleted"
          },
          "labelId" : {
            "type" : "string"
          },
          "labelRenamed" : {
            "$ref" : "#/components/schemas/LabelRenamed"
          },
          "labelUpdated" : {
            "$ref" : "#/components/schemas/LabelUpdated"
          },
          "syncId" : {
            "format" : "uint32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "LabelUpdated" : {
        "description" : "A label pref was updated outside of a rename, create, or delete.",
        "type" : "object"
      },
      "Labels" : {
        "properties" : {
          "displayName" : {
            "description" : "The display name of the labels. This is populated (instead of the id) when the request fetch_spec has LABEL_DISPLAY_NAMES.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "id" : {
            "description" : "The ids of the labels attached to the Item, e.g. \"^i\", \"^x_1\"",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "LanguageConfig" : {
        "description" : "The language configuration for the session.",
        "properties" : {
          "spokenLanguages" : {
            "description" : "The spoken language(s) in BCP47 language code.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "LdapGroupProto" : {
        "properties" : {
          "groupName" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "LdapUserProto" : {
        "properties" : {
          "userName" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "LegacyUploadMetadata" : {
        "description" : "The original UploadMetadata that this DriveMetadata was converted from.",
        "properties" : {
          "legacyUniqueId" : {
            "description" : "A unique ID generated from legacy UploadMetadata. This is used for interopping URLs after uploading blob to shared drive. Links in Classic might break without this. go/drive-file-attachment-interop-from-dynamite.",
            "type" : "string"
          },
          "uploadMetadata" : {
            "$ref" : "#/components/schemas/UploadMetadata"
          }
        },
        "type" : "object"
      },
      "LinkData" : {
        "description" : "Link metadata, for LINK segments. Anchor text should be stored in the \"text\" field of the Segment, which can also serve as a fallback.",
        "properties" : {
          "attachment" : {
            "$ref" : "#/components/schemas/SocialCommonAttachmentAttachment"
          },
          "attachmentRenderHint" : {
            "description" : "The hint to use when rendering the associated attachment. Ignored if there is no associated attachment.",
            "enum" : [ "ATTACHMENT_RENDER_HINT_UNKNOWN", "ATTACHMENT_RENDER_HINT_AFTER", "ATTACHMENT_RENDER_HINT_INTERLEAVED" ],
            "type" : "string"
          },
          "displayUrl" : {
            "description" : "If we wish to show the user a different (e.g. shortened) version of the URL for display purposes, then that version should be set here. If this field isn't set, link_target will be used for both purposes.",
            "type" : "string"
          },
          "linkTarget" : {
            "description" : "link_target is the URL to navigate to when clicked. This could be the original URL, or a URL signed by the GWS URL signing service.",
            "type" : "string"
          },
          "linkType" : {
            "description" : "LinkType is an optional field that provides additional information regarding link target. For example, link type can be identified as the SELF_LINK when the request was executed from the same link as the link target.",
            "enum" : [ "UNKNOWN_LINK_TYPE", "SELF_LINK" ],
            "type" : "string"
          },
          "title" : {
            "description" : "Title is an optional field that provides a short string that describes the link or its destination. User interfaces often use title as a tooltip or for accessibility purposes. However, they are of course free to present this data in any form. This field is plain text.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ListDataSourceResponse" : {
        "properties" : {
          "nextPageToken" : {
            "description" : "Token to retrieve the next page of results, or empty if there are no more results in the list.",
            "type" : "string"
          },
          "sources" : {
            "items" : {
              "$ref" : "#/components/schemas/DataSource"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ListItemNamesForUnmappedIdentityResponse" : {
        "properties" : {
          "itemNames" : {
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "nextPageToken" : {
            "description" : "Token to retrieve the next page of results, or empty if there are no more results in the list.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ListItemsResponse" : {
        "properties" : {
          "items" : {
            "items" : {
              "$ref" : "#/components/schemas/Item"
            },
            "type" : "array"
          },
          "nextPageToken" : {
            "description" : "Token to retrieve the next page of results, or empty if there are no more results in the list.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ListOperationsResponse" : {
        "description" : "The response message for Operations.ListOperations.",
        "properties" : {
          "nextPageToken" : {
            "description" : "The standard List next-page token.",
            "type" : "string"
          },
          "operations" : {
            "description" : "A list of operations that matches the specified filter in the request.",
            "items" : {
              "$ref" : "#/components/schemas/Operation"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ListQuerySourcesResponse" : {
        "description" : "List sources response.",
        "properties" : {
          "nextPageToken" : {
            "type" : "string"
          },
          "sources" : {
            "items" : {
              "$ref" : "#/components/schemas/QuerySource"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ListSearchApplicationsResponse" : {
        "properties" : {
          "nextPageToken" : {
            "description" : "Token to retrieve the next page of results, or empty if there are no more results in the list.",
            "type" : "string"
          },
          "searchApplications" : {
            "items" : {
              "$ref" : "#/components/schemas/SearchApplication"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ListUnmappedIdentitiesResponse" : {
        "properties" : {
          "nextPageToken" : {
            "description" : "Token to retrieve the next page of results, or empty if there are no more results in the list.",
            "type" : "string"
          },
          "unmappedIdentities" : {
            "items" : {
              "$ref" : "#/components/schemas/UnmappedIdentity"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "MatchInfo" : {
        "properties" : {
          "matchingImageReferenceKey" : {
            "description" : "Reference keys for image attachments that matches search query.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "MatchRange" : {
        "description" : "Matched range of a snippet [start, end).",
        "properties" : {
          "end" : {
            "description" : "End of the match in the snippet.",
            "format" : "int32",
            "type" : "integer"
          },
          "start" : {
            "description" : "Starting position of the match in the snippet.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "MdbGroupProto" : {
        "description" : "An entity from the MDB namespace that is to be interpreted as a group. If using this for authorization, you should do an exact match of the peer role against group_name or any of the names in the Chubby expansion of the MDB group named group_name.",
        "properties" : {
          "groupName" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "MdbUserProto" : {
        "description" : "An entity from the MDB namespace that is to be interpreted as a user. If using this for authorization, you should only do an exact match on the peer role against user_name.",
        "properties" : {
          "gaiaId" : {
            "description" : "Do not set this field. Contact credentials-eng@ if you believe you absolutely need to use it. This is the @prod.google.com Gaia ID that corresponds to the MDB user, see go/authn-merge for details. This field may always be safely ignored when performing an authorization check.",
            "format" : "int64",
            "type" : "string"
          },
          "userName" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Media" : {
        "description" : "Media resource.",
        "properties" : {
          "resourceName" : {
            "description" : "Name of the media resource.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "MeetingSpace" : {
        "description" : " A meeting space is a persistent object that is the context for one or more calls. The meeting space is what makes users find each other when they want to meet and to find shared resources. With two exceptions, all the fields in the meeting space resource are visible publicly to any client, even anonymous users. The exceptions are that * The call_info field is only visible to clients that have a device (as indicated by the meeting token) in the JOINED or HIDDEN state. * The meeting_alias field will only be set for users who are in the same domain as the meeting space. The meeting space resource (outside call_info) should only contain information necessary to join a call in the meeting space, and not any other metadata about the meeting space, such as what organization it belongs to or things related to ongoing calls.",
        "properties" : {
          "acceptedNumberClass" : {
            "description" : "Which number classes are accepted by this meeting at the moment? When there is no ongoing conference, this field may change independent of the version number of the MeetingSpace. When a conference starts, this field will be locked to the value at that time, and then will be unlocked again at the end of the conference.",
            "items" : {
              "enum" : [ "NUMBER_CLASS_UNSPECIFIED", "LOW_COST", "HIGH_COST", "LEGACY" ],
              "type" : "string"
            },
            "type" : "array"
          },
          "broadcastAccess" : {
            "$ref" : "#/components/schemas/BroadcastAccess"
          },
          "callInfo" : {
            "$ref" : "#/components/schemas/CallInfo"
          },
          "gatewayAccess" : {
            "$ref" : "#/components/schemas/GatewayAccess"
          },
          "gatewaySipAccess" : {
            "description" : "The SIP based access methods that can be used to join the conference.",
            "items" : {
              "$ref" : "#/components/schemas/GatewaySipAccess"
            },
            "type" : "array"
          },
          "meetingAlias" : {
            "description" : "An optional alias for the meeting space. The alias can in some cases be resolved to the meeting space, similar to the meeting code. The limitation is that the user needs to be in the same meeting domain as the meeting space.",
            "type" : "string"
          },
          "meetingCode" : {
            "description" : "A meeting code is a globally unique code which points to a meeting space. Note: Meeting codes may be regenerated, which will cause old meeting codes to become invalid.",
            "type" : "string"
          },
          "meetingSpaceId" : {
            "description" : "A unique server-generated ID for the meeting space. This is the resource name of the meeting space resource and has the form `spaces/`, where is a sequence of characters in the [base64url set](https://tools.ietf.org/html/rfc4648#section-5), without any `=` characters.",
            "type" : "string"
          },
          "meetingUrl" : {
            "description" : "A URL to identify and access the meeting space. Output only.",
            "type" : "string"
          },
          "moreJoinUrl" : {
            "description" : "Output only. A URL that clients (e.g. Calendar) can use to show the web page with all join methods available for this meeting space. This link is also used in iOS universal links and Android intents, used for opening the \"More ways to join\" view in the Meet mobile apps. Example: https://tel.meet/mee-ting-cod?pin=1234567891011 Here, \"pin\" is the universal phone PIN. We include it explicitly to better support the offline case on the mobile. This is set when the meeting space has either a universal PIN or an interop PIN and clients who can show a \"more ways to join\" button should show it whenever this field is set.",
            "readOnly" : true,
            "type" : "string"
          },
          "phoneAccess" : {
            "description" : "All regional phone access methods for this meeting space. Can be empty.",
            "items" : {
              "$ref" : "#/components/schemas/PhoneAccess"
            },
            "type" : "array"
          },
          "settings" : {
            "$ref" : "#/components/schemas/Settings"
          },
          "universalPhoneAccess" : {
            "$ref" : "#/components/schemas/UniversalPhoneAccess"
          }
        },
        "type" : "object"
      },
      "Member" : {
        "properties" : {
          "roster" : {
            "$ref" : "#/components/schemas/Roster"
          },
          "user" : {
            "$ref" : "#/components/schemas/User"
          }
        },
        "type" : "object"
      },
      "MemberId" : {
        "description" : "Eventually this can be updated to a oneOf User, Space (for nested spaces), Bots or Service, as and when these use cases come up.",
        "properties" : {
          "rosterId" : {
            "$ref" : "#/components/schemas/RosterId"
          },
          "userId" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "MembershipChangeEvent" : {
        "properties" : {
          "leaveReason" : {
            "description" : "This should only be set when MembershipChange type is LEAVE.",
            "enum" : [ "LEAVE_REASON_UNKNOWN", "FORCE_HISTORY_POLICY_CHANGE", "USER_INITIATED" ],
            "type" : "string"
          },
          "participantId" : {
            "items" : {
              "$ref" : "#/components/schemas/StoredParticipantId"
            },
            "type" : "array"
          },
          "type" : {
            "enum" : [ "JOIN", "LEAVE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "MembershipChangedMetadata" : {
        "description" : "Annotation metadata to display system messages for membership changes. Next Tag: 8",
        "properties" : {
          "affectedMemberProfiles" : {
            "items" : {
              "$ref" : "#/components/schemas/Member"
            },
            "type" : "array"
          },
          "affectedMembers" : {
            "description" : "List of users and rosters whose membership status changed.",
            "items" : {
              "$ref" : "#/components/schemas/MemberId"
            },
            "type" : "array"
          },
          "affectedMemberships" : {
            "items" : {
              "$ref" : "#/components/schemas/AffectedMembership"
            },
            "type" : "array"
          },
          "initiator" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "initiatorProfile" : {
            "$ref" : "#/components/schemas/User"
          },
          "initiatorType" : {
            "description" : "The type of the user who initiated this membership change.",
            "enum" : [ "INITIATOR_TYPE_UNSPECIFIED", "INITIATOR_TYPE_END_USER", "INITIATOR_TYPE_ADMIN" ],
            "type" : "string"
          },
          "type" : {
            "enum" : [ "TYPE_UNSPECIFIED", "INVITED", "JOINED", "ADDED", "REMOVED", "LEFT", "BOT_ADDED", "BOT_REMOVED", "KICKED_DUE_TO_OTR_CONFLICT", "ROLE_UPDATED", "ROLE_TARGET_AUDIENCE_UPDATED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Menu" : {
        "description" : "This is deprecated and please use SelectionControl by setting type to DROPDOWN.",
        "properties" : {
          "items" : {
            "items" : {
              "$ref" : "#/components/schemas/MenuItem"
            },
            "type" : "array"
          },
          "label" : {
            "description" : "Label used to be displayed ahead of the menu. It is optional.",
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the text field which is will be used in FormInput.",
            "type" : "string"
          },
          "onChange" : {
            "$ref" : "#/components/schemas/FormAction"
          }
        },
        "type" : "object"
      },
      "MenuItem" : {
        "properties" : {
          "selected" : {
            "type" : "boolean"
          },
          "text" : {
            "description" : "The text to be displayed.",
            "type" : "string"
          },
          "value" : {
            "description" : "The value associated with this item which will be sent back to app scripts. Client should use as a form input value.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Message" : {
        "description" : "Message posted to a Space.",
        "properties" : {
          "annotations" : {
            "description" : "Annotations parsed and extracted from the text body.",
            "items" : {
              "$ref" : "#/components/schemas/Annotation"
            },
            "type" : "array"
          },
          "appProfile" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAppProfile"
          },
          "attachments" : {
            "description" : "Attachments parsed from incoming webhooks",
            "items" : {
              "$ref" : "#/components/schemas/Attachment"
            },
            "type" : "array"
          },
          "attributes" : {
            "$ref" : "#/components/schemas/MessageAttributes"
          },
          "botResponses" : {
            "description" : "Responses from bots indicating if extra auth/config is needed.",
            "items" : {
              "$ref" : "#/components/schemas/BotResponse"
            },
            "type" : "array"
          },
          "communalLabels" : {
            "description" : "Communal labels associated with a message. These exist on the message itself regardless of which user fetches them. Order of entries is arbitrary and will not list duplicates of the same label_id. See go/chat-labels-design for details.",
            "items" : {
              "$ref" : "#/components/schemas/CommunalLabelTag"
            },
            "type" : "array"
          },
          "contentReportSummary" : {
            "$ref" : "#/components/schemas/ContentReportSummary"
          },
          "createTime" : {
            "description" : "Time when the Message was posted in microseconds.",
            "format" : "int64",
            "type" : "string"
          },
          "creatorId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "deletableBy" : {
            "description" : "Indicates who can delete the message. This field is set on the read path (e.g. ListTopics) but doesn’t have any effect on the write path (e.g. CreateMessageRequest).",
            "enum" : [ "PERMISSION_UNSPECIFIED", "PERMISSION_NO_ONE", "PERMISSION_CREATOR", "PERMISSION_MEMBER" ],
            "type" : "string"
          },
          "deleteTime" : {
            "description" : "Time when the Message was deleted in microseconds. This field is set to nonzero value only for Messages deleted globally.",
            "format" : "int64",
            "type" : "string"
          },
          "deleteTimeForRequester" : {
            "description" : "Time when the Message was per-user deleted by the message requester in microseconds. This field is set to nonzero value only for Message per-user deleted by the requester.",
            "format" : "int64",
            "type" : "string"
          },
          "deletedByVault" : {
            "description" : "Was this message deleted by Vault (Only used for Vault support) This is false if message is live or message was deleted by user.",
            "type" : "boolean"
          },
          "dlpScanSummary" : {
            "$ref" : "#/components/schemas/DlpScanSummary"
          },
          "editableBy" : {
            "description" : "Indicates who can edit the message. This field is set on the read path (e.g. ListTopics) but doesn’t have any effect on the write path (e.g. CreateMessageRequest).",
            "enum" : [ "PERMISSION_UNSPECIFIED", "PERMISSION_NO_ONE", "PERMISSION_CREATOR", "PERMISSION_MEMBER" ],
            "type" : "string"
          },
          "fallbackText" : {
            "description" : "A plain-text description of the attachment, used when clients cannot display formatted attachment (e.g. mobile push notifications).",
            "type" : "string"
          },
          "id" : {
            "$ref" : "#/components/schemas/MessageId"
          },
          "isContentPurged" : {
            "description" : "Whether the message is content purged. Content purged messages contain only data required for tombstone (see go/chat-infinite-tombstone). This field is only used by Vault to display tombstone and should only be set to true if the message is a tombstone.",
            "type" : "boolean"
          },
          "isInlineReply" : {
            "description" : "Output only. Indicates if the message is an inline reply. Set to true only if the message's ParentPath is non-NULL. Currently, only inline replies have non-NULL ParentPath. See go/chat-be-inline-reply-indicator.",
            "readOnly" : true,
            "type" : "boolean"
          },
          "lastEditTime" : {
            "description" : "If the message was edited by a user, timestamp of the last edit, in microseconds.",
            "format" : "int64",
            "type" : "string"
          },
          "lastUpdateTime" : {
            "description" : "Time when the Message text was last updated in microseconds.",
            "format" : "int64",
            "type" : "string"
          },
          "localId" : {
            "description" : "A unique id specified on the client side.",
            "type" : "string"
          },
          "messageIntegrationPayload" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedMessageIntegrationPayload"
          },
          "messageOrigin" : {
            "description" : "Where the message was posted from",
            "enum" : [ "ORIGIN_NOT_SET", "ORIGIN_DYNAMITE", "ORIGIN_BABEL_INTEROP_LIVE", "ORIGIN_BABEL_INTEROP_RETRY", "ORIGIN_BABEL", "ORIGIN_BABEL_DUAL_WRITE", "ORIGIN_BABEL_DUAL_WRITE_RETRY", "ORIGIN_BACKFILL_FROM_PAPYRUS", "ORIGIN_BACKFILL_FROM_GMAIL_ARCHIVE" ],
            "type" : "string"
          },
          "messageState" : {
            "description" : "State of the message, indicating whether the message is visible to all members in the group or is only visible to the sender only, or the private_message_viewer if it is set.",
            "enum" : [ "PUBLIC", "PRIVATE" ],
            "type" : "string"
          },
          "originAppSuggestions" : {
            "description" : "Indicates if this message contains any suggestions that were provided by any Apps.",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteSharedOriginAppSuggestion"
            },
            "type" : "array"
          },
          "personalLabels" : {
            "description" : "Personal labels associated with a message for the viewing user. Order of entries is arbitrary and will not list duplicates of the same label_id. See go/chat-labels-design for details. NOTE: This will be unpopulated in the case of SpaceChangelog events.",
            "items" : {
              "$ref" : "#/components/schemas/PersonalLabelTag"
            },
            "type" : "array"
          },
          "privateMessageInfos" : {
            "description" : "A list of per-user private information. This is deprecated, because we no longer plan to support partially private messages or private messages for multiple users. The message_state and private_message_viewer fields should be sufficient for this infrastructure.",
            "items" : {
              "$ref" : "#/components/schemas/PrivateMessageInfo"
            },
            "type" : "array"
          },
          "privateMessageViewer" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "props" : {
            "$ref" : "#/components/schemas/MessageProps"
          },
          "quotedByState" : {
            "description" : "Output only. Whether this message has been quoted by another message or not. Used by clients to handle message edit flows for messages that have been quoted.",
            "enum" : [ "QUOTED_BY_STATE_UNSPECIFIED", "QUOTED_BY_STATE_HAS_BEEN_QUOTED", "QUOTED_BY_STATE_HAS_NOT_BEEN_QUOTED" ],
            "readOnly" : true,
            "type" : "string"
          },
          "quotedMessageMetadata" : {
            "$ref" : "#/components/schemas/QuotedMessageMetadata"
          },
          "reactions" : {
            "description" : "A list of user reactions to this message. Ordered by the timestamp of the first reaction, ascending (oldest to newest).",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteSharedReaction"
            },
            "type" : "array"
          },
          "reports" : {
            "description" : "Output only. Details of content reports. Set only when the request asks for it.",
            "items" : {
              "$ref" : "#/components/schemas/ContentReport"
            },
            "readOnly" : true,
            "type" : "array"
          },
          "retentionSettings" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedRetentionSettings"
          },
          "richTextFormattingType" : {
            "description" : "Used by clients to correctly log format type for message creation due to complexity with client side optimistic update (see go/content-metric-post-send-logging for details). Currently, only set by server in the message or topic creation path.",
            "enum" : [ "NONE", "MARKDOWN", "FORMAT_ANNOTATIONS", "FORMAT_ANNOTATIONS_IGNORED", "FORMAT_ANNOTATIONS_IGNORED_WITH_MARKDOWN" ],
            "type" : "string"
          },
          "secondaryMessageKey" : {
            "description" : "A client-specified string that can be used to uniquely identify a message in a space, in lieu of `id.message_id`.",
            "type" : "string"
          },
          "textBody" : {
            "description" : "Plaintext body of the Message.",
            "type" : "string"
          },
          "tombstoneMetadata" : {
            "$ref" : "#/components/schemas/TombstoneMetadata"
          },
          "updaterId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "uploadMetadata" : {
            "description" : "UploadMetadata b/36864213 is an ongoing effort to move UploadMetadata out of annotations field and save it to upload_metadata field only. After the migration, UploadMetadata will only be saved in this field.",
            "items" : {
              "$ref" : "#/components/schemas/UploadMetadata"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "MessageAdded" : {
        "description" : "A message was added. Specifying id and initial labels.",
        "properties" : {
          "attributeIds" : {
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "labelIds" : {
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "messageKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "syncIds" : {
            "description" : "Note that there can be fewer sync ids than label ids.",
            "items" : {
              "format" : "uint32",
              "type" : "integer"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "MessageAttributes" : {
        "description" : "Stores tombstone message attributes: go/tombstone-message-attributes-overview",
        "properties" : {
          "isTombstone" : {
            "description" : "If true: message is a tombstone in the client. Default false.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "MessageDeleted" : {
        "description" : "Some (subset of the) messages in this thread were deleted.",
        "properties" : {
          "imapSyncMappings" : {
            "description" : "Value of coproc's message delete history record extension that exports /imapsync/folder attribute of deleted messages which have ^is label.",
            "items" : {
              "$ref" : "#/components/schemas/ImapSyncDelete"
            },
            "type" : "array"
          },
          "messageKeys" : {
            "items" : {
              "$ref" : "#/components/schemas/MultiKey"
            },
            "type" : "array"
          },
          "wonderCardMappings" : {
            "description" : "Value of coproc's message delete history record extension that exports /wonder/message_mapping/{vertical} attribute of deleted messages which have smartmail label (eg. ^cob_sm_invoice, etc).",
            "items" : {
              "$ref" : "#/components/schemas/WonderCardDelete"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "MessageId" : {
        "description" : "Primary key for Message resource.",
        "properties" : {
          "messageId" : {
            "description" : "Opaque, server-assigned ID of the Message. While this ID is guaranteed to be unique within the Space, it's not guaranteed to be globally unique.",
            "type" : "string"
          },
          "parentId" : {
            "$ref" : "#/components/schemas/MessageParentId"
          }
        },
        "type" : "object"
      },
      "MessageInfo" : {
        "properties" : {
          "authorUserType" : {
            "description" : "Message author’s user type (human/bot).",
            "enum" : [ "HUMAN", "BOT" ],
            "type" : "string"
          },
          "message" : {
            "$ref" : "#/components/schemas/Message"
          },
          "searcherMembershipState" : {
            "description" : "Searcher's membership state in the space where the message is posted.",
            "enum" : [ "MEMBER_UNKNOWN", "MEMBER_INVITED", "MEMBER_JOINED", "MEMBER_NOT_A_MEMBER", "MEMBER_FAILED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "MessageParentId" : {
        "description" : "Primary key identifying Message resource's immediate parent. For top-level Messages, either topic_id or chat_id is populated. For replies, message_id is populated with the topic Message's ID.",
        "properties" : {
          "topicId" : {
            "$ref" : "#/components/schemas/TopicId"
          }
        },
        "type" : "object"
      },
      "MessageProps" : {
        "description" : "Container for storing properties applicable to messages. For now (until storage consolidation is complete), it will only be used for babel props. In the future it could be used to house Dynamite properties for experimenting/rapid prototyping.",
        "properties" : {
          "babelProps" : {
            "$ref" : "#/components/schemas/BabelMessageProps"
          }
        },
        "type" : "object"
      },
      "MessageSet" : {
        "description" : "This is proto2's version of MessageSet.",
        "type" : "object"
      },
      "Metadata" : {
        "description" : "Metadata of a matched search result.",
        "properties" : {
          "createTime" : {
            "description" : "The creation time for this document or object in the search result.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "displayOptions" : {
            "$ref" : "#/components/schemas/ResultDisplayMetadata"
          },
          "fields" : {
            "description" : "Indexed fields in structured data, returned as a generic named property.",
            "items" : {
              "$ref" : "#/components/schemas/NamedProperty"
            },
            "type" : "array"
          },
          "mimeType" : {
            "description" : "Mime type of the search result.",
            "type" : "string"
          },
          "objectType" : {
            "description" : "Object type of the search result.",
            "type" : "string"
          },
          "owner" : {
            "$ref" : "#/components/schemas/Person"
          },
          "source" : {
            "$ref" : "#/components/schemas/Source"
          },
          "thumbnailUrl" : {
            "description" : "The thumbnail URL of the result.",
            "type" : "string"
          },
          "updateTime" : {
            "description" : "The last modified date for the object in the search result. If not set in the item, the value returned here is empty. When `updateTime` is used for calculating freshness and is not set, this value defaults to 2 years from the current time.",
            "format" : "google-datetime",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Metaline" : {
        "description" : "A metaline is a list of properties that are displayed along with the search result to provide context.",
        "properties" : {
          "properties" : {
            "description" : "The list of displayed properties for the metaline. The maximum number of properties is 5.",
            "items" : {
              "$ref" : "#/components/schemas/DisplayedProperty"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "MultiKey" : {
        "description" : "A union-like type for identifiying an object in storage. MultiKeys contain multiple key fields, each in a separate key space. At least one key field must be set. More than one key field may be set as long as all key values refer to the same object. All objects in storage have unique server_id keys. All MultiKeys returned from storage to storage clients will always have the server_id field set. When creating an object, if a MultiKey without a server_id is supplied to storage, the storage system will auto-assign a server ID to the new object. For all other storage requests (i.e. those not creating new objects), clients may omit server_id (as long as they supply another key). Instead of server ids, clients can specify string based client_assigned_perm_id keys. Mail message drafts are a prime example of these kinds of objects. Each time a user saves a new version of a draft, the storage system needs to create a new object with the updated draft content and needs to delete the object containing the old content. The new object gets a new SERVER_ID but should get the same CLIENT_ASSIGNED_PERM_ID as the now-deleted object containing the old content. Carrying forward the perm ID allows it to be used to consistently refer to the same logical object across revisions. These perm IDs save sync clients from having to deal with changing object IDs. For example, assume there's a mail message in storage with SERVER_ID = 123 and CLIENT_ASSIGNED_PERM_ID = \"foo\". The following are all valid ways of addressing the object using MultiKeys: 1) MultiKey { server_id = 123 } 2) MultiKey { server_id = 123, client_assigned_perm_id = \"foo\" } 3) MultiKey { client_assigned_perm_id = \"foo\" } Multikeys are never serialized in the storage. The individual keys are extracted and processed separately. Both the integer ids as well as string ids are indexed for efficient retrieval using the same fields in the backend. See go/tingle-multikeys for more information on background and motivation.",
        "properties" : {
          "clientAssignedPermId" : {
            "description" : "A client-assigned string based key.",
            "type" : "string"
          },
          "serverId" : {
            "description" : "A server-assigned ID. This ID must be used only by Gmail and is constructed using millesecond ts << 20 + randomness. The ID affects the sort order of the index.",
            "format" : "uint64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Name" : {
        "description" : "A person's name.",
        "properties" : {
          "displayName" : {
            "description" : "The read-only display name formatted according to the locale specified by the viewer's account or the `Accept-Language` HTTP header.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "NamedProperty" : {
        "description" : "A typed name-value pair for structured data. The type of the value should be the same as the registered type for the `name` property in the object definition of `objectType`.",
        "properties" : {
          "booleanValue" : {
            "type" : "boolean"
          },
          "dateValues" : {
            "$ref" : "#/components/schemas/DateValues"
          },
          "doubleValues" : {
            "$ref" : "#/components/schemas/DoubleValues"
          },
          "enumValues" : {
            "$ref" : "#/components/schemas/EnumValues"
          },
          "htmlValues" : {
            "$ref" : "#/components/schemas/HtmlValues"
          },
          "integerValues" : {
            "$ref" : "#/components/schemas/IntegerValues"
          },
          "name" : {
            "description" : "The name of the property. This name should correspond to the name of the property that was registered for object definition in the schema. The maximum allowable length for this property is 256 characters.",
            "type" : "string"
          },
          "objectValues" : {
            "$ref" : "#/components/schemas/ObjectValues"
          },
          "textValues" : {
            "$ref" : "#/components/schemas/TextValues"
          },
          "timestampValues" : {
            "$ref" : "#/components/schemas/TimestampValues"
          }
        },
        "type" : "object"
      },
      "OAuthConsumerProto" : {
        "description" : "Represents an OAuth consumer, a/k/a AuthSub target. These principals are identified by domain name (e.g., example.com). Historically, Dasher domain GAIA group IDs have been used instead, but that doesn't work: http://go/tricky-gaia-ids",
        "properties" : {
          "domain" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ObjectDefinition" : {
        "description" : "The definition for an object within a data source.",
        "properties" : {
          "name" : {
            "description" : "The name for the object, which then defines its type. Item indexing requests should set the objectType field equal to this value. For example, if *name* is *Document*, then indexing requests for items of type Document should set objectType equal to *Document*. Each object definition must be uniquely named within a schema. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The maximum length is 256 characters.",
            "type" : "string"
          },
          "options" : {
            "$ref" : "#/components/schemas/ObjectOptions"
          },
          "propertyDefinitions" : {
            "description" : "The property definitions for the object. The maximum number of elements is 1000.",
            "items" : {
              "$ref" : "#/components/schemas/PropertyDefinition"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ObjectDisplayOptions" : {
        "description" : "The display options for an object.",
        "properties" : {
          "metalines" : {
            "description" : "Defines the properties that are displayed in the metalines of the search results. The property values are displayed in the order given here. If a property holds multiple values, all of the values are displayed before the next properties. For this reason, it is a good practice to specify singular properties before repeated properties in this list. All of the properties must set is_returnable to true. The maximum number of metalines is 3.",
            "items" : {
              "$ref" : "#/components/schemas/Metaline"
            },
            "type" : "array"
          },
          "objectDisplayLabel" : {
            "description" : "The user friendly label to display in the search result to indicate the type of the item. This is OPTIONAL; if not provided, an object label isn't displayed on the context line of the search results. The maximum length is 64 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ObjectOptions" : {
        "description" : "The options for an object.",
        "properties" : {
          "displayOptions" : {
            "$ref" : "#/components/schemas/ObjectDisplayOptions"
          },
          "freshnessOptions" : {
            "$ref" : "#/components/schemas/FreshnessOptions"
          },
          "suggestionFilteringOperators" : {
            "description" : "Operators that can be used to filter suggestions. For Suggest API, only operators mentioned here will be honored in the FilterOptions. Only TEXT and ENUM operators are supported. NOTE: \"objecttype\", \"type\" and \"mimetype\" are already supported. This property is to configure schema specific operators. Even though this is an array, only one operator can be specified. This is an array for future extensibility. Operators mapping to multiple properties within the same object are not supported. If the operator spans across different object types, this option has to be set once for each object definition.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ObjectPropertyOptions" : {
        "description" : "The options for object properties.",
        "properties" : {
          "subobjectProperties" : {
            "description" : "The properties of the sub-object. These properties represent a nested object. For example, if this property represents a postal address, the subobjectProperties might be named *street*, *city*, and *state*. The maximum number of elements is 1000.",
            "items" : {
              "$ref" : "#/components/schemas/PropertyDefinition"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ObjectValues" : {
        "description" : "List of object values.",
        "properties" : {
          "values" : {
            "items" : {
              "$ref" : "#/components/schemas/StructuredDataObject"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "OnClick" : {
        "properties" : {
          "action" : {
            "$ref" : "#/components/schemas/FormAction"
          },
          "link" : {
            "description" : "This can be used as a short form for OpenLink with the default OpenAs and OnClose. It may be undeprecated if this proves to be handy for developers.",
            "type" : "string"
          },
          "openLink" : {
            "$ref" : "#/components/schemas/OpenLink"
          },
          "openLinkAction" : {
            "$ref" : "#/components/schemas/FormAction"
          }
        },
        "type" : "object"
      },
      "OpenCreatedDraftActionMarkup" : {
        "properties" : {
          "draftId" : {
            "description" : "The ID of the newly created draft in the form \"r123\".",
            "type" : "string"
          },
          "draftStorageId" : {
            "description" : "The server storage ID in hex format, for example,\"15e9fa622ce1029d\".",
            "type" : "string"
          },
          "draftThreadId" : {
            "description" : "The ID of the thread containing the newly created draft, for example, \"15e9fa622ce1029d\".",
            "type" : "string"
          },
          "draftThreadServerPermId" : {
            "description" : "The server permanent ID for the draft's thread. This field isn't set anywhere, and it's ignored when processing OpenCreatedDraftActionMarkup. Supply and use draftThreadStorageId instead.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "OpenLink" : {
        "properties" : {
          "loadIndicator" : {
            "description" : "Next available ID: 5",
            "enum" : [ "NONE", "SPINNER" ],
            "type" : "string"
          },
          "onClose" : {
            "enum" : [ "NOTHING", "RELOAD_ADD_ON" ],
            "type" : "string"
          },
          "openAs" : {
            "enum" : [ "FULL_SIZE", "OVERLAY" ],
            "type" : "string"
          },
          "url" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Operation" : {
        "description" : "This resource represents a long-running operation that is the result of a network API call.",
        "properties" : {
          "done" : {
            "description" : "If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            "type" : "boolean"
          },
          "error" : {
            "$ref" : "#/components/schemas/Status"
          },
          "metadata" : {
            "additionalProperties" : {
              "description" : "Properties of the object. Contains field @type with type URL."
            },
            "description" : "Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "type" : "object"
          },
          "name" : {
            "description" : "The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "type" : "string"
          },
          "response" : {
            "additionalProperties" : {
              "description" : "Properties of the object. Contains field @type with type URL."
            },
            "description" : "The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.",
            "type" : "object"
          }
        },
        "type" : "object"
      },
      "OsVersion" : {
        "properties" : {
          "majorVersion" : {
            "format" : "int32",
            "type" : "integer"
          },
          "minorVersion" : {
            "format" : "int32",
            "type" : "integer"
          },
          "tertiaryVersion" : {
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "OtrChatMessageEvent" : {
        "properties" : {
          "expirationTimestampUsec" : {
            "format" : "int64",
            "type" : "string"
          },
          "kansasRowId" : {
            "type" : "string"
          },
          "kansasVersionInfo" : {
            "type" : "string"
          },
          "messageOtrStatus" : {
            "enum" : [ "OFF_THE_RECORD", "ON_THE_RECORD" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "OtrModificationEvent" : {
        "properties" : {
          "newOtrStatus" : {
            "enum" : [ "OFF_THE_RECORD", "ON_THE_RECORD" ],
            "type" : "string"
          },
          "newOtrToggle" : {
            "enum" : [ "ENABLED", "DISABLED" ],
            "type" : "string"
          },
          "oldOtrStatus" : {
            "enum" : [ "OFF_THE_RECORD", "ON_THE_RECORD" ],
            "type" : "string"
          },
          "oldOtrToggle" : {
            "enum" : [ "ENABLED", "DISABLED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PackagingServiceClient" : {
        "description" : "Developers register a client in Google API Console to get the deep-linking feature on Google+ posts or frames about their apps. The client data is stored in this proto.",
        "properties" : {
          "androidPackageName" : {
            "description" : "Android app's package name to generate the deep-link URI.",
            "type" : "string"
          },
          "iosAppStoreId" : {
            "description" : "iOS app's App Store ID to generate the App Store URL when app is not installed on device.",
            "type" : "string"
          },
          "iosBundleId" : {
            "description" : "iOS app's bundle ID to generate the deep-link URI.",
            "type" : "string"
          },
          "type" : {
            "description" : "Type of Google API Console client.",
            "enum" : [ "ANDROID", "IOS" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PaygateInfo" : {
        "description" : "Information provided to clients so that they can show upgrade promos and warnings on call ending early (for non-paying users).",
        "properties" : {
          "callEndingSoonWarningTime" : {
            "description" : "Time when client should show message that the call is ending soon.",
            "format" : "google-datetime",
            "type" : "string"
          },
          "callEndingTime" : {
            "description" : "Time when the call will end if the user does not upgrade (after in-call upgrade support check has been implemented).",
            "format" : "google-datetime",
            "type" : "string"
          },
          "showUpgradePromos" : {
            "description" : "This boolean is used by clients to decide whether the user should be shown promos to upgrade.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "PeopleSuggestion" : {
        "description" : "This field contains information about the person being suggested.",
        "properties" : {
          "person" : {
            "$ref" : "#/components/schemas/Person"
          }
        },
        "type" : "object"
      },
      "Person" : {
        "description" : "Object to represent a person.",
        "properties" : {
          "emailAddresses" : {
            "description" : "The person's email addresses",
            "items" : {
              "$ref" : "#/components/schemas/EmailAddress"
            },
            "type" : "array"
          },
          "name" : {
            "description" : "The resource name of the person to provide information about. See [`People.get`](https://developers.google.com/people/api/rest/v1/people/get) from the Google People API.",
            "type" : "string"
          },
          "obfuscatedId" : {
            "description" : "Obfuscated ID of a person.",
            "type" : "string"
          },
          "personNames" : {
            "description" : "The person's name",
            "items" : {
              "$ref" : "#/components/schemas/Name"
            },
            "type" : "array"
          },
          "phoneNumbers" : {
            "description" : "The person's phone numbers",
            "items" : {
              "$ref" : "#/components/schemas/PhoneNumber"
            },
            "type" : "array"
          },
          "photos" : {
            "description" : "A person's read-only photo. A picture shown next to the person's name to help others recognize the person in search results.",
            "items" : {
              "$ref" : "#/components/schemas/Photo"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "PersonalLabelTag" : {
        "description" : "An individual instance (or \"tag\") of a label configured as a personal type that's associated with a message.",
        "properties" : {
          "labelId" : {
            "description" : "A string ID representing the label. Possible ID values are documented at go/chat-labels-howto:ids. Examples: \"^t\" for \"Starred\", \"^nu\" for \"Nudged\".",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PhoneAccess" : {
        "description" : "Phone access contains information required to dial into a conference using a regional phone number and a PIN that is specific to that phone number.",
        "properties" : {
          "formattedPhoneNumber" : {
            "description" : "The phone number to dial for this meeting space in INTERNATIONAL format. Full phone number with a leading '+' character and whitespace separations.",
            "type" : "string"
          },
          "languageCode" : {
            "description" : "The BCP 47/LDML language code for the language associated with this phone access. To be parsed by the i18n LanguageCode utility. Examples: \"es-419\" for Latin American Spanish, \"fr-CA\" for Canadian French.",
            "type" : "string"
          },
          "phoneNumber" : {
            "description" : "The phone number to dial for this meeting space in E.164 format. Full phone number with a leading '+' character.",
            "type" : "string"
          },
          "pin" : {
            "description" : "The PIN that users must enter after dialing the given number. The PIN consists of only decimal digits and the length may vary.",
            "type" : "string"
          },
          "regionCode" : {
            "description" : "The CLDR/ISO 3166 region code for the country associated with this phone access. To be parsed by the i18n RegionCode utility. Example: \"SE\" for Sweden.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PhoneNumber" : {
        "description" : "A person's Phone Number",
        "properties" : {
          "phoneNumber" : {
            "description" : "The phone number of the person.",
            "type" : "string"
          },
          "type" : {
            "enum" : [ "OTHER", "MOBILE", "OFFICE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Photo" : {
        "description" : "A person's photo.",
        "properties" : {
          "url" : {
            "description" : "The URL of the photo.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PinnedItemId" : {
        "properties" : {
          "driveId" : {
            "description" : "Identifier for a Drive file (e.g. Docs, Sheets, Slides).",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PollItemsRequest" : {
        "properties" : {
          "connectorName" : {
            "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
            "type" : "string"
          },
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "limit" : {
            "description" : "Maximum number of items to return. The maximum value is 100 and the default value is 20.",
            "format" : "int32",
            "type" : "integer"
          },
          "queue" : {
            "description" : "Queue name to fetch items from. If unspecified, PollItems will fetch from 'default' queue. The maximum length is 100 characters.",
            "type" : "string"
          },
          "statusCodes" : {
            "description" : "Limit the items polled to the ones with these statuses.",
            "items" : {
              "enum" : [ "CODE_UNSPECIFIED", "ERROR", "MODIFIED", "NEW_ITEM", "ACCEPTED" ],
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "PollItemsResponse" : {
        "properties" : {
          "items" : {
            "description" : "Set of items from the queue available for connector to process. These items have the following subset of fields populated: version metadata.hash structured_data.hash content.hash payload status queue",
            "items" : {
              "$ref" : "#/components/schemas/Item"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "PossiblyTrimmedModel" : {
        "description" : "This message contains either the device model, or a prefix of the device model (AKA a trimmed device model). The \"is_trimmed\" field indicates which one it is.",
        "properties" : {
          "isTrimmed" : {
            "type" : "boolean"
          },
          "model" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PostiniUserProto" : {
        "description" : "See http://s/?fileprint=//depot/google3/security/authentication/postini/auth_token.proto",
        "properties" : {
          "postiniUserId" : {
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PreState" : {
        "description" : "State of the thread previous to the update. This really just describes the label state of all messages before the update.",
        "properties" : {
          "labelIds" : {
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "messageKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "syncIds" : {
            "description" : "Note that there can be fewer sync ids than label ids.",
            "items" : {
              "format" : "uint32",
              "type" : "integer"
            },
            "type" : "array"
          },
          "threadKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          }
        },
        "type" : "object"
      },
      "PrefDeleted" : {
        "description" : "PREF_DELETED",
        "type" : "object"
      },
      "PrefUpdate" : {
        "description" : "HistoryRecord for changes associated with prefs, namely: PREF_WRITTEN PREF_DELETED",
        "properties" : {
          "name" : {
            "description" : "Name of the affected preference.",
            "type" : "string"
          },
          "preState" : {
            "$ref" : "#/components/schemas/FuseboxPrefUpdatePreState"
          },
          "prefDeleted" : {
            "$ref" : "#/components/schemas/PrefDeleted"
          },
          "prefWritten" : {
            "$ref" : "#/components/schemas/PrefWritten"
          }
        },
        "type" : "object"
      },
      "PrefWritten" : {
        "description" : "PREF_WRITTEN",
        "properties" : {
          "value" : {
            "format" : "byte",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Presenter" : {
        "description" : "Presenter contains information about which device is currently presenting as well as which device requested the presenter to be set.",
        "properties" : {
          "byDeviceId" : {
            "description" : "The device resource name of the device which requested the current presenter to be set. This field can not be modified by clients.",
            "type" : "string"
          },
          "copresenterDeviceIds" : {
            "description" : "The device resource names of other devices which can control the current presentation.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "presenterDeviceId" : {
            "description" : "The device resource name of the currently presenting device.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Principal" : {
        "description" : "Reference to a user, group, or domain.",
        "properties" : {
          "groupResourceName" : {
            "description" : "This principal is a group identified using an external identity. The name field must specify the group resource name with this format: identitysources/{source_id}/groups/{ID}",
            "type" : "string"
          },
          "gsuitePrincipal" : {
            "$ref" : "#/components/schemas/GSuitePrincipal"
          },
          "userResourceName" : {
            "description" : "This principal is a user identified using an external identity. The name field must specify the user resource name with this format: identitysources/{source_id}/users/{ID}",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PrincipalProto" : {
        "description" : "A Principal represents something to which permissions are assigned, often but not always a user or group of some kind. It is most appropriate for use in ACLs and authorization checks. Callers should prefer to use the wrapper classes in google3/security/credentials/public/principal.h google3/java/com/google/security/credentials/Principal.java google3/security/credentials/go/principal.go unless direct proto access is essential. If you update this protocol buffer, please update the wrapper classes as well. LINT.IfChange",
        "properties" : {
          "allAuthenticatedUsers" : {
            "$ref" : "#/components/schemas/AllAuthenticatedUsersProto"
          },
          "capTokenHolder" : {
            "$ref" : "#/components/schemas/CapTokenHolderProto"
          },
          "chat" : {
            "$ref" : "#/components/schemas/ChatProto"
          },
          "circle" : {
            "$ref" : "#/components/schemas/CircleProto"
          },
          "cloudPrincipal" : {
            "$ref" : "#/components/schemas/CloudPrincipalProto"
          },
          "contactGroup" : {
            "$ref" : "#/components/schemas/ContactGroupProto"
          },
          "emailOwner" : {
            "$ref" : "#/components/schemas/EmailOwnerProto"
          },
          "event" : {
            "$ref" : "#/components/schemas/EventProto"
          },
          "gaiaGroup" : {
            "$ref" : "#/components/schemas/GaiaGroupProto"
          },
          "gaiaUser" : {
            "$ref" : "#/components/schemas/GaiaUserProto"
          },
          "host" : {
            "$ref" : "#/components/schemas/HostProto"
          },
          "ldapGroup" : {
            "$ref" : "#/components/schemas/LdapGroupProto"
          },
          "ldapUser" : {
            "$ref" : "#/components/schemas/LdapUserProto"
          },
          "mdbGroup" : {
            "$ref" : "#/components/schemas/MdbGroupProto"
          },
          "mdbUser" : {
            "$ref" : "#/components/schemas/MdbUserProto"
          },
          "oauthConsumer" : {
            "$ref" : "#/components/schemas/OAuthConsumerProto"
          },
          "postiniUser" : {
            "$ref" : "#/components/schemas/PostiniUserProto"
          },
          "rbacRole" : {
            "$ref" : "#/components/schemas/RbacRoleProto"
          },
          "rbacSubject" : {
            "$ref" : "#/components/schemas/RbacSubjectProto"
          },
          "resourceRole" : {
            "$ref" : "#/components/schemas/ResourceRoleProto"
          },
          "scope" : {
            "description" : "This is only optional because required enums cannot be extended. Currently required.",
            "enum" : [ "INVALID", "GAIA_USER", "GAIA_GROUP", "LDAP_USER", "LDAP_GROUP", "MDB_USER", "MDB_GROUP", "POSTINI_USER", "CONTACT_GROUP", "SIMPLE_SECRET_HOLDER", "SIGNING_KEY_POSSESSOR", "ALL_AUTHENTICATED_USERS", "OAUTH_CONSUMER", "HOST", "SOCIAL_GRAPH_NODE", "EMAIL_OWNER", "CAP_TOKEN_HOLDER", "CIRCLE", "SQUARE", "EVENT", "RESOURCE_ROLE", "CHAT", "YOUTUBE_USER", "UNUSED_ZWIEBACK_SESSION", "ZWIEBACK_SESSION", "RBAC_ROLE", "RBAC_SUBJECT", "CLOUD_PRINCIPAL" ],
            "type" : "string"
          },
          "signingKeyPossessor" : {
            "$ref" : "#/components/schemas/SigningKeyPossessorProto"
          },
          "simpleSecretHolder" : {
            "$ref" : "#/components/schemas/SimpleSecretHolderProto"
          },
          "socialGraphNode" : {
            "$ref" : "#/components/schemas/SocialGraphNodeProto"
          },
          "square" : {
            "$ref" : "#/components/schemas/SquareProto"
          },
          "youtubeUser" : {
            "$ref" : "#/components/schemas/YoutubeUserProto"
          },
          "zwiebackSession" : {
            "$ref" : "#/components/schemas/ZwiebackSessionProto"
          }
        },
        "type" : "object"
      },
      "PrivateMessageInfo" : {
        "description" : "Private message information specific to a given user. DEPRECATED: Use the privateMessageViewer field in CreateMessageInfo instead.",
        "properties" : {
          "annotations" : {
            "description" : "Annotations private to {@code userId}.",
            "items" : {
              "$ref" : "#/components/schemas/Annotation"
            },
            "type" : "array"
          },
          "attachments" : {
            "description" : "Attachments private to {@code userId}.",
            "items" : {
              "$ref" : "#/components/schemas/Attachment"
            },
            "type" : "array"
          },
          "contextualAddOnMarkup" : {
            "items" : {
              "$ref" : "#/components/schemas/GoogleChatV1ContextualAddOnMarkup"
            },
            "type" : "array"
          },
          "gsuiteIntegrationMetadata" : {
            "items" : {
              "$ref" : "#/components/schemas/GsuiteIntegrationMetadata"
            },
            "type" : "array"
          },
          "text" : {
            "description" : "Text private to {@code user_id}. Initial restriction: Only one of public text or private text is rendered on the client. So if public text is set, private text is ignored.",
            "type" : "string"
          },
          "userId" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "ProcessingError" : {
        "properties" : {
          "code" : {
            "description" : "Error code indicating the nature of the error.",
            "enum" : [ "PROCESSING_ERROR_CODE_UNSPECIFIED", "MALFORMED_REQUEST", "UNSUPPORTED_CONTENT_FORMAT", "INDIRECT_BROKEN_ACL", "ACL_CYCLE" ],
            "type" : "string"
          },
          "errorMessage" : {
            "description" : "The description of the error.",
            "type" : "string"
          },
          "fieldViolations" : {
            "description" : "In case the item fields are invalid, this field contains the details about the validation errors.",
            "items" : {
              "$ref" : "#/components/schemas/FieldViolation"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "PropertyDefinition" : {
        "description" : "The definition of a property within an object.",
        "properties" : {
          "booleanPropertyOptions" : {
            "$ref" : "#/components/schemas/BooleanPropertyOptions"
          },
          "datePropertyOptions" : {
            "$ref" : "#/components/schemas/DatePropertyOptions"
          },
          "displayOptions" : {
            "$ref" : "#/components/schemas/PropertyDisplayOptions"
          },
          "doublePropertyOptions" : {
            "$ref" : "#/components/schemas/DoublePropertyOptions"
          },
          "enumPropertyOptions" : {
            "$ref" : "#/components/schemas/EnumPropertyOptions"
          },
          "htmlPropertyOptions" : {
            "$ref" : "#/components/schemas/HtmlPropertyOptions"
          },
          "integerPropertyOptions" : {
            "$ref" : "#/components/schemas/IntegerPropertyOptions"
          },
          "isFacetable" : {
            "description" : "Indicates that the property can be used for generating facets. Cannot be true for properties whose type is object. IsReturnable must be true to set this option. Only supported for boolean, enum, integer, and text properties.",
            "type" : "boolean"
          },
          "isRepeatable" : {
            "description" : "Indicates that multiple values are allowed for the property. For example, a document only has one description but can have multiple comments. Cannot be true for properties whose type is a boolean. If set to false, properties that contain more than one value cause the indexing request for that item to be rejected.",
            "type" : "boolean"
          },
          "isReturnable" : {
            "description" : "Indicates that the property identifies data that should be returned in search results via the Query API. If set to *true*, indicates that Query API users can use matching property fields in results. However, storing fields requires more space allocation and uses more bandwidth for search queries, which impacts performance over large datasets. Set to *true* here only if the field is needed for search results. Cannot be true for properties whose type is an object.",
            "type" : "boolean"
          },
          "isSortable" : {
            "description" : "Indicates that the property can be used for sorting. Cannot be true for properties that are repeatable. Cannot be true for properties whose type is object. IsReturnable must be true to set this option. Only supported for boolean, date, double, integer, and timestamp properties.",
            "type" : "boolean"
          },
          "isSuggestable" : {
            "description" : "Indicates that the property can be used for generating query suggestions.",
            "type" : "boolean"
          },
          "isWildcardSearchable" : {
            "description" : "Indicates that users can perform wildcard search for this property. Only supported for Text properties. IsReturnable must be true to set this option. In a given datasource maximum of 5 properties can be marked as is_wildcard_searchable. For more details, see [Define object properties](https://developers.google.com/cloud-search/docs/guides/schema-guide#properties)",
            "type" : "boolean"
          },
          "name" : {
            "description" : "The name of the property. Item indexing requests sent to the Indexing API should set the property name equal to this value. For example, if name is *subject_line*, then indexing requests for document items with subject fields should set the name for that field equal to *subject_line*. Use the name as the identifier for the object property. Once registered as a property for an object, you cannot re-use this name for another property within that object. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The maximum length is 256 characters.",
            "type" : "string"
          },
          "objectPropertyOptions" : {
            "$ref" : "#/components/schemas/ObjectPropertyOptions"
          },
          "textPropertyOptions" : {
            "$ref" : "#/components/schemas/TextPropertyOptions"
          },
          "timestampPropertyOptions" : {
            "$ref" : "#/components/schemas/TimestampPropertyOptions"
          }
        },
        "type" : "object"
      },
      "PropertyDisplayOptions" : {
        "description" : "The display options for a property.",
        "properties" : {
          "displayLabel" : {
            "description" : "The user friendly label for the property that is used if the property is specified to be displayed in ObjectDisplayOptions. If provided, the display label is shown in front of the property values when the property is part of the object display options. For example, if the property value is '1', the value by itself may not be useful context for the user. If the display name given was 'priority', then the user sees 'priority : 1' in the search results which provides clear context to search users. This is OPTIONAL; if not given, only the property values are displayed. The maximum length is 64 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Provenance" : {
        "description" : "This field records where the ItemScope was retrieved, if it was created via a web fetch.",
        "properties" : {
          "annotationBlob" : {
            "description" : "Annotation blob from Annotation Service.",
            "format" : "byte",
            "type" : "string"
          },
          "canonicalUrl" : {
            "description" : "Canonical url of the retrieved_url, if one was resolved during retrieval, for example, if a rel=\"canonical\" link tag was provided in the retrieved web page.",
            "type" : "string"
          },
          "inputUrl" : {
            "description" : "The url originally passed in the PRS request, which should be used to re-discover the content. Note that this URL may be a forwarding service or link shortener (bit.ly), so it should not be assumed to be canonical, but should be used for navigation back to the original source of the itemscope.",
            "type" : "string"
          },
          "itemtype" : {
            "description" : "Contains exact types as parsed, whether or not we recognized that type at parse time. If an itemscope is created by merging SchemaOrg markup and open graph markup then the first itemtype would be schemaorg type, the second would be open graph and so on. example: http://schema.org/VideoObject, og:video.movie Plain text; usually a URL",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "retrievedTimestampMsec" : {
            "description" : "The server retrieved timestamp (in msec).",
            "format" : "uint64",
            "type" : "string"
          },
          "retrievedUrl" : {
            "description" : "The final URL that was the actual source of the itemscope, after any redirects.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PushItem" : {
        "description" : "Represents an item to be pushed to the indexing queue.",
        "properties" : {
          "contentHash" : {
            "description" : "Content hash of the item according to the repository. If specified, this is used to determine how to modify this item's status. Setting this field and the type field results in argument error. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "metadataHash" : {
            "description" : "The metadata hash of the item according to the repository. If specified, this is used to determine how to modify this item's status. Setting this field and the type field results in argument error. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "payload" : {
            "description" : "Provides additional document state information for the connector, such as an alternate repository ID and other metadata. The maximum length is 8192 bytes.",
            "format" : "byte",
            "type" : "string"
          },
          "queue" : {
            "description" : "Queue to which this item belongs. The `default` queue is chosen if this field is not specified. The maximum length is 512 characters.",
            "type" : "string"
          },
          "repositoryError" : {
            "$ref" : "#/components/schemas/RepositoryError"
          },
          "structuredDataHash" : {
            "description" : "Structured data hash of the item according to the repository. If specified, this is used to determine how to modify this item's status. Setting this field and the type field results in argument error. The maximum length is 2048 characters.",
            "type" : "string"
          },
          "type" : {
            "description" : "The type of the push operation that defines the push behavior.",
            "enum" : [ "UNSPECIFIED", "MODIFIED", "NOT_MODIFIED", "REPOSITORY_ERROR", "REQUEUE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "PushItemRequest" : {
        "properties" : {
          "connectorName" : {
            "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
            "type" : "string"
          },
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "item" : {
            "$ref" : "#/components/schemas/PushItem"
          }
        },
        "type" : "object"
      },
      "QueryCountByStatus" : {
        "properties" : {
          "count" : {
            "format" : "int64",
            "type" : "string"
          },
          "statusCode" : {
            "description" : "This represents the http status code.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "QueryInterpretation" : {
        "properties" : {
          "interpretationType" : {
            "enum" : [ "NONE", "BLEND", "REPLACE" ],
            "type" : "string"
          },
          "interpretedQuery" : {
            "description" : "The interpretation of the query used in search. For example, queries with natural language intent like \"email from john\" will be interpreted as \"from:john source:mail\". This field will not be filled when the reason is NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY.",
            "type" : "string"
          },
          "reason" : {
            "description" : "The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.",
            "enum" : [ "UNSPECIFIED", "QUERY_HAS_NATURAL_LANGUAGE_INTENT", "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "QueryInterpretationConfig" : {
        "description" : "Default options to interpret user query.",
        "properties" : {
          "forceDisableSupplementalResults" : {
            "description" : "Set this flag to disable supplemental results retrieval, setting a flag here will not retrieve supplemental results for queries associated with a given search application. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for supplemental results.",
            "type" : "boolean"
          },
          "forceVerbatimMode" : {
            "description" : "Enable this flag to turn off all internal optimizations like natural language (NL) interpretation of queries, supplemental results retrieval, and usage of synonyms including custom ones. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for verbatim mode.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "QueryInterpretationOptions" : {
        "description" : "Options to interpret user query.",
        "properties" : {
          "disableNlInterpretation" : {
            "description" : "Flag to disable natural language (NL) interpretation of queries. Default is false, Set to true to disable natural language interpretation. NL interpretation only applies to predefined datasources.",
            "type" : "boolean"
          },
          "disableSupplementalResults" : {
            "description" : "Use this flag to disable supplemental results for a query. Supplemental results setting chosen at SearchApplication level will take precedence if set to True.",
            "type" : "boolean"
          },
          "enableVerbatimMode" : {
            "description" : "Enable this flag to turn off all internal optimizations like natural language (NL) interpretation of queries, supplemental result retrieval, and usage of synonyms including custom ones. Nl interpretation will be disabled if either one of the two flags is true.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "QueryItem" : {
        "description" : "Information relevant only to a query entry.",
        "properties" : {
          "isSynthetic" : {
            "description" : "True if the text was generated by means other than a previous user search.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "QueryOperator" : {
        "description" : "The definition of a operator that can be used in a Search/Suggest request.",
        "properties" : {
          "displayName" : {
            "description" : "Display name of the operator",
            "type" : "string"
          },
          "enumValues" : {
            "description" : "Potential list of values for the opeatror field. This field is only filled when we can safely enumerate all the possible values of this operator.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          },
          "greaterThanOperatorName" : {
            "description" : "Indicates the operator name that can be used to isolate the property using the greater-than operator.",
            "type" : "string"
          },
          "isFacetable" : {
            "description" : "Can this operator be used to get facets.",
            "type" : "boolean"
          },
          "isRepeatable" : {
            "description" : "Indicates if multiple values can be set for this property.",
            "type" : "boolean"
          },
          "isReturnable" : {
            "description" : "Will the property associated with this facet be returned as part of search results.",
            "type" : "boolean"
          },
          "isSortable" : {
            "description" : "Can this operator be used to sort results.",
            "type" : "boolean"
          },
          "isSuggestable" : {
            "description" : "Can get suggestions for this field.",
            "type" : "boolean"
          },
          "lessThanOperatorName" : {
            "description" : "Indicates the operator name that can be used to isolate the property using the less-than operator.",
            "type" : "string"
          },
          "objectType" : {
            "description" : "The name of the object corresponding to the operator. This field is only filled for schema-specific operators, and is unset for common operators.",
            "type" : "string"
          },
          "operatorName" : {
            "description" : "The name of the operator.",
            "type" : "string"
          },
          "type" : {
            "description" : "The type of the operator.",
            "enum" : [ "UNKNOWN", "INTEGER", "DOUBLE", "TIMESTAMP", "BOOLEAN", "ENUM", "DATE", "TEXT", "HTML" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "QuerySource" : {
        "description" : "List of sources that the user can search using the query API.",
        "properties" : {
          "displayName" : {
            "description" : "Display name of the data source.",
            "type" : "string"
          },
          "operators" : {
            "description" : "List of all operators applicable for this source.",
            "items" : {
              "$ref" : "#/components/schemas/QueryOperator"
            },
            "type" : "array"
          },
          "shortName" : {
            "description" : "A short name or alias for the source. This value can be used with the 'source' operator.",
            "type" : "string"
          },
          "source" : {
            "$ref" : "#/components/schemas/Source"
          }
        },
        "type" : "object"
      },
      "QuerySuggestion" : {
        "description" : "This field does not contain anything as of now and is just used as an indicator that the suggest result was a phrase completion.",
        "type" : "object"
      },
      "QuotedMessageMetadata" : {
        "description" : "Quote metadata: go/message-quoting-be-dd-v2. This proto is only used on the read path. For the request proto, refer to `QuotedMessagePayload`. Fields are either derived from storage directly from the Item this metadata belongs to, or is hydrated at read time from another Item read. Note: QuotedMessageMetadata proto is similar to Message proto with less field. Reasons to differtiate QuotedMessageMetadata from Message are: 1. Not all fields for original message is applicable for quoted message. (E.g. reactions, is_inline_reply, etc.), thus separting out for confusion. 2. We don't support nested message quoting. For more detailed discussion, please see http://shortn/_VsSXQb2C7P. For future reference: if your new feature/field will be supported in message quoting feature (go/chat-quoting-prd), you will need to add that field within QuotedMessageMetadata",
        "properties" : {
          "annotations" : {
            "description" : "Output only. Snapshot of the annotations of the quoted message.",
            "items" : {
              "$ref" : "#/components/schemas/Annotation"
            },
            "readOnly" : true,
            "type" : "array"
          },
          "appProfile" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedAppProfile"
          },
          "botAttachmentState" : {
            "description" : "Output only. The bot attachment state of the quoted message. Used by clients to display a bot attachment indicator in the UI.",
            "enum" : [ "BOT_ATTACHMENT_STATE_UNSPECIFIED", "BOT_ATTACHMENT_STATE_HAS_BOT_ATTACHMENT", "BOT_ATTACHMENT_STATE_NO_BOT_ATTACHMENT" ],
            "readOnly" : true,
            "type" : "string"
          },
          "createTimeMicros" : {
            "description" : "Output only. Time when the quoted message was posted in microseconds.",
            "format" : "int64",
            "readOnly" : true,
            "type" : "string"
          },
          "creatorId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "lastEditTimeMicros" : {
            "description" : "Output only. Time when the quoted message was last edited by a user at the time when quoting action happens. Time is in microseconds.",
            "format" : "int64",
            "readOnly" : true,
            "type" : "string"
          },
          "lastUpdateTimeWhenQuotedMicros" : {
            "description" : "The `last_update_time` of the original message when the client initiated the quote creation. This is derived from the request payload passed from clients. Used to fetch the quoted message contents at a specific time on the read path. This field is populated from storage directly.",
            "format" : "int64",
            "type" : "string"
          },
          "messageId" : {
            "$ref" : "#/components/schemas/MessageId"
          },
          "messageState" : {
            "description" : "Output only. The state of the quoted message. Used by clients to display tombstones for quotes that reference a deleted message.",
            "enum" : [ "MESSAGE_STATE_UNSPECIFIED", "MESSAGE_STATE_ACTIVE", "MESSAGE_STATE_DELETED", "MESSAGE_STATE_OTR_EDITED" ],
            "readOnly" : true,
            "type" : "string"
          },
          "retentionSettings" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedRetentionSettings"
          },
          "textBody" : {
            "description" : "Output only. Snapshot of the text body of the quoted message.",
            "readOnly" : true,
            "type" : "string"
          },
          "updaterId" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "uploadMetadata" : {
            "description" : "Output only. Upload metadata of the quoted message.",
            "items" : {
              "$ref" : "#/components/schemas/UploadMetadata"
            },
            "readOnly" : true,
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "Rank" : {
        "description" : "The rank contains a tuple of numbers which may be used as a general sort order. The rank should be treated as an ordered set of numbers, where the ordering is done in descending order of the most significant rank member. For example, given the following ranks described as (primary, secondary): (1,1), (1,2), (2,2) (2,1) The descending rank-order is: (2,2) > (2,1) > (1,2) > (1,1)",
        "properties" : {
          "primary" : {
            "description" : "The primary rank is the most significant rank member. This rank element should always be present. Items with higher primary rank are always considered of higher rank than those of lower primary rank.",
            "format" : "int64",
            "type" : "string"
          },
          "secondary" : {
            "description" : "The secondary rank may be used to rank items of identical primary rank. This rank element should always be present.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RbacRoleProto" : {
        "description" : "Principal associated with a given RBAC role. This principal is used by Sphinx Provisioning Service for RBAC provisionable (go/sphinx-rbacz).",
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "objectId" : {
            "type" : "string"
          },
          "rbacNamespace" : {
            "description" : "DEPRECATED as of 01.11.2019",
            "type" : "string"
          },
          "rbacRoleName" : {
            "description" : "Format: \"role/z?\" - \"role\" is the Sphinx globally unique name of the Sphinx role that provisions the RBAC role. - \"/z?\" suffix indicates which Zanzibar environment stores the role membership data (\"/zd\": dev, \"/zs\": staging, \"/zp\": prod, \"/zt\": local test instance). Example: \"mysystem_myrole/zp\"",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RbacSubjectProto" : {
        "description" : "Principal associated with a given RBAC subject. This principal is used by Sphinx Provisioning Service for RBAC provisionable (go/sphinx-rbacz).",
        "properties" : {
          "username" : {
            "description" : "Format \"username\" without \"@domain\", e.g., \"bogdand\".",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ReactionInfo" : {
        "description" : "Contains information about an emoji reaction.",
        "properties" : {
          "emoji" : {
            "description" : "Unicode string representing a single emoji.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ReadReceiptsSettingsUpdatedMetadata" : {
        "properties" : {
          "readReceiptsEnabled" : {
            "description" : "The new read receipts state.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "Recipient" : {
        "properties" : {
          "email" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RecordingEvent" : {
        "description" : "A recording event is something that happens to the recording in a conference.",
        "properties" : {
          "deviceId" : {
            "description" : "The initiator of the latest event of the recording. It will be set for all user events (`type` is 100-199) and unset for all server events (`type` is 200-299).",
            "type" : "string"
          },
          "type" : {
            "description" : "The type of event.",
            "enum" : [ "RECORDING_EVENT_UNSPECIFIED", "USER_ACTION", "STARTED_BY_USER", "STOPPED_BY_USER", "CANCELLED_BY_USER", "CANCELLED_INITIALIZATION_FAILED", "CANCELLED_INITIATOR_LEFT", "ACTIVE_ABOUT_TO_STOP_TOO_LONG", "STOPPED_TOO_LONG", "STOPPED_ALL_DEVICES_LEFT", "STOPPED_INTERNAL_FAILURES" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RecordingInfo" : {
        "description" : "This message is deprecated, please use RecordingSessionInfo instead. Information about recording in the current conference.",
        "properties" : {
          "latestRecordingEvent" : {
            "$ref" : "#/components/schemas/RecordingEvent"
          },
          "ownerDisplayName" : {
            "description" : "The display name of the owner of the recording output. Email notifications about uploaded recordings will also be sent to this owner.",
            "type" : "string"
          },
          "producerDeviceId" : {
            "description" : "The device resource name of the producer device for the currently active recording. Note that, after the producer drops/leaves the conference, this field will be cleaned up by the server after a delay.",
            "type" : "string"
          },
          "recordingApplicationType" : {
            "description" : "The application type of the current active recording. `RECORDING_APPLICATION_TYPE_UNSPECIFIED` if `recording_status` is inactive.",
            "enum" : [ "RECORDING_APPLICATION_TYPE_UNSPECIFIED", "RECORDING", "GLIVE_STREAM", "BROADCAST" ],
            "type" : "string"
          },
          "recordingId" : {
            "description" : "An identifier for the current recording, if any. This is returned whenever recording_status is either `RECORDING_STARTING` or `RECORDING_STARTED`.",
            "type" : "string"
          },
          "recordingStatus" : {
            "description" : "The current status of the recording. This can be used by clients to show a recording dot or similar to indicated to the user that a recording is taking place.",
            "enum" : [ "RECORDING_UNSPECIFIED", "RECORDING_INACTIVE", "RECORDING_STARTING", "RECORDING_STARTED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RecordingSessionInfo" : {
        "description" : "Information about a recording session.",
        "properties" : {
          "ownerEmail" : {
            "description" : "Input only. Deprecated field, should not be used.",
            "type" : "string"
          },
          "recordingSessionId" : {
            "description" : "A unique server-generated ID for the recording session.",
            "type" : "string"
          },
          "sessionStateInfo" : {
            "$ref" : "#/components/schemas/SessionStateInfo"
          }
        },
        "type" : "object"
      },
      "Reference" : {
        "description" : "All fields in this proto are now columns in spanner see google3/storage/slice/production/gmail/user_data_tables.pi for documentation.",
        "properties" : {
          "blobId" : {
            "type" : "string"
          },
          "contentType" : {
            "type" : "string"
          },
          "hash" : {
            "type" : "string"
          },
          "key" : {
            "description" : "LINT.IfChange",
            "type" : "string"
          },
          "name" : {
            "description" : "LINT.ThenChange(//depot/google3/storage/slice/production/gmail/ user_data_tables.pi)",
            "type" : "string"
          },
          "size" : {
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "References" : {
        "properties" : {
          "references" : {
            "items" : {
              "$ref" : "#/components/schemas/Reference"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "RenameEvent" : {
        "properties" : {
          "newName" : {
            "type" : "string"
          },
          "originalName" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RepositoryError" : {
        "description" : "Errors when the connector is communicating to the source repository.",
        "properties" : {
          "errorMessage" : {
            "description" : "Message that describes the error. The maximum allowable length of the message is 8192 characters.",
            "type" : "string"
          },
          "httpStatusCode" : {
            "description" : "Error codes. Matches the definition of HTTP status codes.",
            "format" : "int32",
            "type" : "integer"
          },
          "type" : {
            "description" : "The type of error.",
            "enum" : [ "UNKNOWN", "NETWORK_ERROR", "DNS_ERROR", "CONNECTION_ERROR", "AUTHENTICATION_ERROR", "AUTHORIZATION_ERROR", "SERVER_ERROR", "QUOTA_EXCEEDED", "SERVICE_UNAVAILABLE", "CLIENT_ERROR" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RequestFileScope" : {
        "properties" : {
          "itemId" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RequestFileScopeForActiveDocument" : {
        "type" : "object"
      },
      "RequestOptions" : {
        "description" : "Shared request options for all RPC methods.",
        "properties" : {
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "languageCode" : {
            "description" : "The BCP-47 language code, such as \"en-US\" or \"sr-Latn\". For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. For translations. Set this field using the language set in browser or for the page. In the event that the user's language preference is known, set this field to the known user language. When specified, the documents in search results are biased towards the specified language. From Suggest API perspective, for 3p suggest this is used as a hint while making predictions to add language boosting.",
            "type" : "string"
          },
          "searchApplicationId" : {
            "description" : "The ID generated when you create a search application using the [admin console](https://support.google.com/a/answer/9043922).",
            "type" : "string"
          },
          "timeZone" : {
            "description" : "Current user's time zone id, such as \"America/Los_Angeles\" or \"Australia/Sydney\". These IDs are defined by [Unicode Common Locale Data Repository (CLDR)](http://cldr.unicode.org/) project, and currently available in the file [timezone.xml](http://unicode.org/repos/cldr/trunk/common/bcp47/timezone.xml). This field is used to correctly interpret date and time queries. If this field is not specified, the default time zone (UTC) is used.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RequiredMessageFeaturesMetadata" : {
        "description" : "A list of capabilities that are used in this message.",
        "properties" : {
          "requiredFeatures" : {
            "items" : {
              "enum" : [ "REQUIRED_FEATURE_UNSPECIFIED", "REQUIRED_FEATURE_MESSAGE_QUOTING", "REQUIRED_FEATURE_TOMBSTONES_IN_DMS_AND_UFRS", "REQUIRED_FEATURE_CUSTOM_HYPERLINK", "REQUIRED_FEATURE_SMART_CHIP" ],
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ResetSearchApplicationRequest" : {
        "properties" : {
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          }
        },
        "type" : "object"
      },
      "ResourceRoleProto" : {
        "description" : "A type of sharing target that points to some resource's ACL. Used to refer to the set of Principals that have the given privilege ('role_id') for the given resource ('application_id', 'object_id', 'object_part'). The meaning of 'role_id' is interpreted only by implementations of AclRpcService and is usually dependent on 'application_id' All fields except object_part are required. If present, object_part must be non-empty.",
        "properties" : {
          "applicationId" : {
            "type" : "string"
          },
          "objectId" : {
            "type" : "string"
          },
          "objectPart" : {
            "type" : "string"
          },
          "roleId" : {
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "ResponseDebugInfo" : {
        "description" : "Debugging information about the response.",
        "properties" : {
          "formattedDebugInfo" : {
            "description" : "General debug info formatted for display.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RestrictItem" : {
        "description" : "Information relevant only to a restrict entry. NextId: 12",
        "properties" : {
          "driveFollowUpRestrict" : {
            "$ref" : "#/components/schemas/DriveFollowUpRestrict"
          },
          "driveLocationRestrict" : {
            "$ref" : "#/components/schemas/DriveLocationRestrict"
          },
          "driveMimeTypeRestrict" : {
            "$ref" : "#/components/schemas/DriveMimeTypeRestrict"
          },
          "driveTimeSpanRestrict" : {
            "$ref" : "#/components/schemas/DriveTimeSpanRestrict"
          },
          "searchOperator" : {
            "description" : "The search restrict (e.g. \"after:2017-09-11 before:2017-09-12\").",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ResultCounts" : {
        "description" : "Result count information",
        "properties" : {
          "sourceResultCounts" : {
            "description" : "Result count information for each source with results.",
            "items" : {
              "$ref" : "#/components/schemas/SourceResultCount"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ResultDebugInfo" : {
        "description" : "Debugging information about the result.",
        "properties" : {
          "formattedDebugInfo" : {
            "description" : "General debug info formatted for display.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ResultDisplayField" : {
        "description" : "Display Fields for Search Results",
        "properties" : {
          "label" : {
            "description" : "The display label for the property.",
            "type" : "string"
          },
          "operatorName" : {
            "description" : "The operator name of the property.",
            "type" : "string"
          },
          "property" : {
            "$ref" : "#/components/schemas/NamedProperty"
          }
        },
        "type" : "object"
      },
      "ResultDisplayLine" : {
        "description" : "The collection of fields that make up a displayed line",
        "properties" : {
          "fields" : {
            "items" : {
              "$ref" : "#/components/schemas/ResultDisplayField"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ResultDisplayMetadata" : {
        "properties" : {
          "metalines" : {
            "description" : "The metalines content to be displayed with the result.",
            "items" : {
              "$ref" : "#/components/schemas/ResultDisplayLine"
            },
            "type" : "array"
          },
          "objectTypeLabel" : {
            "description" : "The display label for the object.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RetrievalImportance" : {
        "properties" : {
          "importance" : {
            "description" : "Indicates the ranking importance given to property when it is matched during retrieval. Once set, the token importance of a property cannot be changed.",
            "enum" : [ "DEFAULT", "HIGHEST", "HIGH", "LOW", "NONE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RoomRenameMetadata" : {
        "properties" : {
          "newName" : {
            "type" : "string"
          },
          "prevName" : {
            "description" : "NEXT_TAG: 3",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RoomUpdatedMetadata" : {
        "properties" : {
          "groupDetailsMetadata" : {
            "$ref" : "#/components/schemas/GroupDetailsUpdatedMetadata"
          },
          "groupLinkSharingEnabled" : {
            "type" : "boolean"
          },
          "initiator" : {
            "$ref" : "#/components/schemas/User"
          },
          "initiatorType" : {
            "description" : "The type of the user who initiated this room update.",
            "enum" : [ "INITIATOR_TYPE_UNSPECIFIED", "INITIATOR_TYPE_END_USER", "INITIATOR_TYPE_ADMIN" ],
            "type" : "string"
          },
          "name" : {
            "description" : "What was updated in the room.",
            "type" : "string"
          },
          "renameMetadata" : {
            "$ref" : "#/components/schemas/RoomRenameMetadata"
          },
          "visibility" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedGroupVisibility"
          }
        },
        "type" : "object"
      },
      "Roster" : {
        "description" : "Roster profile information.",
        "properties" : {
          "avatarUrl" : {
            "type" : "string"
          },
          "id" : {
            "$ref" : "#/components/schemas/RosterId"
          },
          "isMembershipVisibleToCaller" : {
            "description" : "Whether caller has visibility into members of the roster.",
            "type" : "boolean"
          },
          "membershipCount" : {
            "format" : "int32",
            "type" : "integer"
          },
          "name" : {
            "type" : "string"
          },
          "rosterGaiaKey" : {
            "description" : "Roster gaia key, usually an email address. Set in looking up rosters response.",
            "type" : "string"
          },
          "rosterState" : {
            "description" : "Roster deletion state - considered active unless set to deleted",
            "enum" : [ "ROSTER_STATE_UNKNOWN", "ROSTER_ACTIVE", "ROSTER_DELETED" ],
            "type" : "string"
          },
          "segmentedMembershipCounts" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedSegmentedMembershipCounts"
          }
        },
        "type" : "object"
      },
      "RosterId" : {
        "description" : "Primary key for Roster resource.",
        "properties" : {
          "id" : {
            "description" : "Opaque, server-assigned ID of the Roster.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "RpcOptions" : {
        "description" : "Options for Triggers dispatched via RPC.",
        "properties" : {
          "requestExtensions" : {
            "$ref" : "#/components/schemas/MessageSet"
          }
        },
        "type" : "object"
      },
      "SafeUrlProto" : {
        "description" : "Message containing a string that is safe to use in URL contexts in DOM APIs and HTML documents, where the URL context does not refer to a resource that loads code.",
        "properties" : {
          "privateDoNotAccessOrElseSafeUrlWrappedValue" : {
            "description" : "IMPORTANT: Never set or read this field, even from tests, it is private. See documentation at the top of .proto file for programming language packages with which to create or read this message.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Schema" : {
        "description" : "The schema definition for a data source.",
        "properties" : {
          "objectDefinitions" : {
            "description" : "The list of top-level objects for the data source. The maximum number of elements is 10.",
            "items" : {
              "$ref" : "#/components/schemas/ObjectDefinition"
            },
            "type" : "array"
          },
          "operationIds" : {
            "description" : "IDs of the Long Running Operations (LROs) currently running for this schema. After modifying the schema, wait for operations to complete before indexing additional content.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ScoringConfig" : {
        "description" : "Scoring configurations for a source while processing a Search or Suggest request.",
        "properties" : {
          "disableFreshness" : {
            "description" : "Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI.",
            "type" : "boolean"
          },
          "disablePersonalization" : {
            "description" : "Whether to personalize the results. By default, personal signals will be used to boost results.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "SearchApplication" : {
        "description" : "SearchApplication",
        "properties" : {
          "dataSourceRestrictions" : {
            "description" : "Retrictions applied to the configurations. The maximum number of elements is 10.",
            "items" : {
              "$ref" : "#/components/schemas/DataSourceRestriction"
            },
            "type" : "array"
          },
          "defaultFacetOptions" : {
            "description" : "The default fields for returning facet results. The sources specified here also have been included in data_source_restrictions above.",
            "items" : {
              "$ref" : "#/components/schemas/FacetOptions"
            },
            "type" : "array"
          },
          "defaultSortOptions" : {
            "$ref" : "#/components/schemas/SortOptions"
          },
          "displayName" : {
            "description" : "Display name of the Search Application. The maximum length is 300 characters.",
            "type" : "string"
          },
          "enableAuditLog" : {
            "description" : "Indicates whether audit logging is on/off for requests made for the search application in query APIs.",
            "type" : "boolean"
          },
          "name" : {
            "description" : "The name of the Search Application. Format: searchapplications/{application_id}.",
            "type" : "string"
          },
          "operationIds" : {
            "description" : "Output only. IDs of the Long Running Operations (LROs) currently running for this schema. Output only field.",
            "items" : {
              "type" : "string"
            },
            "readOnly" : true,
            "type" : "array"
          },
          "queryInterpretationConfig" : {
            "$ref" : "#/components/schemas/QueryInterpretationConfig"
          },
          "returnResultThumbnailUrls" : {
            "description" : "With each result we should return the URI for its thumbnail (when applicable)",
            "type" : "boolean"
          },
          "scoringConfig" : {
            "$ref" : "#/components/schemas/ScoringConfig"
          },
          "sourceConfig" : {
            "description" : "Configuration for a sources specified in data_source_restrictions.",
            "items" : {
              "$ref" : "#/components/schemas/SourceConfig"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "SearchApplicationQueryStats" : {
        "description" : "Search application level query stats per date",
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "queryCountByStatus" : {
            "items" : {
              "$ref" : "#/components/schemas/QueryCountByStatus"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "SearchApplicationSessionStats" : {
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "searchSessionsCount" : {
            "description" : "The count of search sessions on the day",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SearchApplicationUserStats" : {
        "properties" : {
          "date" : {
            "$ref" : "#/components/schemas/Date"
          },
          "oneDayActiveUsersCount" : {
            "description" : "The count of unique active users in the past one day",
            "format" : "int64",
            "type" : "string"
          },
          "sevenDaysActiveUsersCount" : {
            "description" : "The count of unique active users in the past seven days",
            "format" : "int64",
            "type" : "string"
          },
          "thirtyDaysActiveUsersCount" : {
            "description" : "The count of unique active users in the past thirty days",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SearchItemsByViewUrlRequest" : {
        "properties" : {
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "pageToken" : {
            "description" : "The next_page_token value returned from a previous request, if any.",
            "type" : "string"
          },
          "viewUrl" : {
            "description" : "Specify the full view URL to find the corresponding item. The maximum length is 2048 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SearchItemsByViewUrlResponse" : {
        "properties" : {
          "items" : {
            "items" : {
              "$ref" : "#/components/schemas/Item"
            },
            "type" : "array"
          },
          "nextPageToken" : {
            "description" : "Token to retrieve the next page of results, or empty if there are no more results in the list.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SearchQualityMetadata" : {
        "description" : "Additional search quality metadata of the item.",
        "properties" : {
          "quality" : {
            "description" : "An indication of the quality of the item, used to influence search quality. Value should be between 0.0 (lowest quality) and 1.0 (highest quality). The default value is 0.0.",
            "format" : "double",
            "type" : "number"
          }
        },
        "type" : "object"
      },
      "SearchRequest" : {
        "description" : "The search API request.",
        "properties" : {
          "contextAttributes" : {
            "description" : "Context attributes for the request which will be used to adjust ranking of search results. The maximum number of elements is 10.",
            "items" : {
              "$ref" : "#/components/schemas/ContextAttribute"
            },
            "type" : "array"
          },
          "dataSourceRestrictions" : {
            "description" : "The sources to use for querying. If not specified, all data sources from the current search application are used.",
            "items" : {
              "$ref" : "#/components/schemas/DataSourceRestriction"
            },
            "type" : "array"
          },
          "facetOptions" : {
            "items" : {
              "$ref" : "#/components/schemas/FacetOptions"
            },
            "type" : "array"
          },
          "pageSize" : {
            "description" : "Maximum number of search results to return in one page. Valid values are between 1 and 100, inclusive. Default value is 10. Minimum value is 50 when results beyond 2000 are requested.",
            "format" : "int32",
            "type" : "integer"
          },
          "query" : {
            "description" : "The raw query string. See supported search operators in the [Narrow your search with operators](https://support.google.com/cloudsearch/answer/6172299)",
            "type" : "string"
          },
          "queryInterpretationOptions" : {
            "$ref" : "#/components/schemas/QueryInterpretationOptions"
          },
          "requestOptions" : {
            "$ref" : "#/components/schemas/RequestOptions"
          },
          "sortOptions" : {
            "$ref" : "#/components/schemas/SortOptions"
          },
          "start" : {
            "description" : "Starting index of the results.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "SearchResponse" : {
        "description" : "The search API response.",
        "properties" : {
          "debugInfo" : {
            "$ref" : "#/components/schemas/ResponseDebugInfo"
          },
          "errorInfo" : {
            "$ref" : "#/components/schemas/ErrorInfo"
          },
          "facetResults" : {
            "description" : "Repeated facet results.",
            "items" : {
              "$ref" : "#/components/schemas/FacetResult"
            },
            "type" : "array"
          },
          "hasMoreResults" : {
            "description" : "Whether there are more search results matching the query.",
            "type" : "boolean"
          },
          "queryInterpretation" : {
            "$ref" : "#/components/schemas/QueryInterpretation"
          },
          "resultCountEstimate" : {
            "description" : "The estimated result count for this query.",
            "format" : "int64",
            "type" : "string"
          },
          "resultCountExact" : {
            "description" : "The exact result count for this query.",
            "format" : "int64",
            "type" : "string"
          },
          "resultCounts" : {
            "$ref" : "#/components/schemas/ResultCounts"
          },
          "results" : {
            "description" : "Results from a search query.",
            "items" : {
              "$ref" : "#/components/schemas/SearchResult"
            },
            "type" : "array"
          },
          "spellResults" : {
            "description" : "Suggested spelling for the query.",
            "items" : {
              "$ref" : "#/components/schemas/SpellResult"
            },
            "type" : "array"
          },
          "structuredResults" : {
            "description" : "Structured results for the user query. These results are not counted against the page_size.",
            "items" : {
              "$ref" : "#/components/schemas/StructuredResult"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "SearchResult" : {
        "description" : "Results containing indexed information for a document.",
        "properties" : {
          "clusteredResults" : {
            "description" : "If source is clustered, provide list of clustered results. There will only be one level of clustered results. If current source is not enabled for clustering, this field will be empty.",
            "items" : {
              "$ref" : "#/components/schemas/SearchResult"
            },
            "type" : "array"
          },
          "debugInfo" : {
            "$ref" : "#/components/schemas/ResultDebugInfo"
          },
          "metadata" : {
            "$ref" : "#/components/schemas/Metadata"
          },
          "snippet" : {
            "$ref" : "#/components/schemas/Snippet"
          },
          "title" : {
            "description" : "Title of the search result.",
            "type" : "string"
          },
          "url" : {
            "description" : "The URL of the search result. The URL contains a Google redirect to the actual item. This URL is signed and shouldn't be changed.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Section" : {
        "description" : "Sections are separated by a line divider. They contain a collection of widgets that are rendered (vertically) in the order that they are specified. Across all platforms, AddOns have a narrow fixed width, so there is currently no need for layout properties (e.g. float).",
        "properties" : {
          "collapsable" : {
            "description" : "Indicating whether this section is collapsable. If a section is collapsable, the description must be given.",
            "type" : "boolean"
          },
          "description" : {
            "description" : "The header of the section, text formatted supported.",
            "type" : "string"
          },
          "numUncollapsableWidgets" : {
            "description" : "The number of uncollapsable widgets. For example, when a section contains 5 widgets and the num_uncollapsable_widget are set to be 2, The first 2 widgets will always shown and the last 3 is collapsed as default. Only when collapsable is set to be true, the num_uncollapsable_widget will be taken into account.",
            "format" : "int32",
            "type" : "integer"
          },
          "widgets" : {
            "description" : "A section must contain at least 1 widget.",
            "items" : {
              "$ref" : "#/components/schemas/WidgetMarkup"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "Segment" : {
        "properties" : {
          "formatting" : {
            "$ref" : "#/components/schemas/Formatting"
          },
          "hashtagData" : {
            "$ref" : "#/components/schemas/HashtagData"
          },
          "linkData" : {
            "$ref" : "#/components/schemas/LinkData"
          },
          "text" : {
            "description" : "Text content of the Segment. As a general rule, this field should contain the actual text that should be rendered in the UI. Thus, for a hashtag, it should be \"#Foo\", and for a link, it should be the display text. Clients that do not understand a particular segment type may use this text, along with the Formatting info below, as a fallback for display. The field is not required -- if all relevant information is carried in other metadata fields and there is no need for a fallback, or it is not practical for a fallback to be provided for any other reason, the field may be left blank. A standard example would be a user reference being transmitted between server layers, where a gaia-ID representation may be sufficient and there is no need for a textual fallback. In such a case, it would be valid and useful - though not required - for servers to compute and populate a fallback on the serving path.",
            "type" : "string"
          },
          "type" : {
            "description" : "Type of Segment.",
            "enum" : [ "TEXT", "LINE_BREAK", "LINK", "USER_MENTION", "ALL_USER_MENTION", "HASHTAG" ],
            "type" : "string"
          },
          "userMentionData" : {
            "$ref" : "#/components/schemas/UserMentionData"
          }
        },
        "type" : "object"
      },
      "SelectionControl" : {
        "properties" : {
          "items" : {
            "description" : "For radio button, at most one of the items will be selected.",
            "items" : {
              "$ref" : "#/components/schemas/SelectionItem"
            },
            "type" : "array"
          },
          "label" : {
            "description" : "Label used to be displayed ahead of the selection control. It is optional.",
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the text field which is will be used in FormInput.",
            "type" : "string"
          },
          "onChange" : {
            "$ref" : "#/components/schemas/FormAction"
          },
          "type" : {
            "enum" : [ "CHECK_BOX", "RADIO_BUTTON", "SWITCH", "DROPDOWN" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SelectionItem" : {
        "properties" : {
          "selected" : {
            "description" : "If more than one items are selected for RADIO_BUTTON and DROPDOWN, the first selected item is treated as sElected and the after ones are all ignored.",
            "type" : "boolean"
          },
          "text" : {
            "description" : "The text to be displayed.",
            "type" : "string"
          },
          "value" : {
            "description" : "The value associated with this item which will be sent back to app scripts. Client should use as a form input value.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SessionContext" : {
        "properties" : {
          "authTime" : {
            "description" : "Time at which this activity's session was authenticated, in seconds since the epoch.",
            "format" : "int64",
            "type" : "string"
          },
          "delegateUserId" : {
            "description" : "Gaia ID of the authenticated user when delegate access is active. In such sessions the main gaia ID is that of the delegator, i.e. the account being accessed.",
            "format" : "int64",
            "type" : "string"
          },
          "dusi" : {
            "description" : "Device User Session ID, see go/dusi.",
            "type" : "string"
          },
          "imapSessionContext" : {
            "$ref" : "#/components/schemas/ImapSessionContext"
          },
          "oauthLoginId" : {
            "description" : "OAuth login ID.",
            "format" : "int32",
            "type" : "integer"
          },
          "oauthProjectId" : {
            "description" : "The devconsole project ID of the developer who authenticated with OAuth.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SessionEvent" : {
        "description" : "A session event is something that happens to the streaming session in a conference.",
        "properties" : {
          "deviceId" : {
            "description" : "The initiator of the latest event of the streaming session. It will be set for all user events (`type` is 100-199) and unset for all server events(`type` is 200-299).",
            "type" : "string"
          },
          "type" : {
            "description" : "The type of event.",
            "enum" : [ "EVENT_UNSPECIFIED", "STARTED_BY_USER", "STOPPED_BY_USER", "CANCELLED_BY_USER", "CANCELLED_INITIALIZATION_FAILED", "CANCELLED_INITIATOR_LEFT", "ACTIVE_ABOUT_TO_STOP_TOO_LONG", "STOPPED_TOO_LONG", "STOPPED_ALL_DEVICES_LEFT", "STOPPED_INTERNAL_FAILURES" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SessionStateInfo" : {
        "description" : "Information about the state of a (recording, broadcast, transcription...) session in a conference.",
        "properties" : {
          "ackInfo" : {
            "$ref" : "#/components/schemas/AckInfo"
          },
          "languageConfig" : {
            "$ref" : "#/components/schemas/LanguageConfig"
          },
          "lastActorDeviceId" : {
            "description" : "Output only. The device id of the actor is set if the current state is a result of a user action, is empty otherwise.",
            "readOnly" : true,
            "type" : "string"
          },
          "maxEndTime" : {
            "description" : "Output only. The max end time of the session, at this time the session will be force stopped/terminated. Clients are expected to use this timestamp to warn users about the force stop.",
            "format" : "google-datetime",
            "readOnly" : true,
            "type" : "string"
          },
          "sessionState" : {
            "description" : "State of the session.",
            "enum" : [ "SESSION_STATE_UNSPECIFIED", "STARTING", "ACTIVE", "STOPPED" ],
            "type" : "string"
          },
          "sessionStopReason" : {
            "description" : "Output only. The reason the session was transitioned to STOPPED state.",
            "enum" : [ "SESSION_STOP_REASON_UNSPECIFIED", "USER_ACTION", "STOPPED_INITIALIZATION_FAILED", "STOPPED_TOO_LONG", "STOPPED_ALL_DEVICES_LEFT", "STOPPED_INTERNAL_FAILURES", "STOPPED_YOU_TUBE_LIVE_EVENT_ENDED" ],
            "readOnly" : true,
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Settings" : {
        "description" : "Settings of a meeting space that can be edited by users with corresponding manage privilege. These settings are always populated in responses.",
        "properties" : {
          "accessLock" : {
            "description" : "The access lock of the meeting space that lets hosts control who can join the meeting.",
            "type" : "boolean"
          },
          "accessType" : {
            "description" : "The access type of the meeting space.",
            "enum" : [ "ACCESS_TYPE_UNSPECIFIED", "ACCESS_TYPE_OPEN", "ACCESS_TYPE_TRUSTED", "ACCESS_TYPE_RESTRICTED", "ACCESS_TYPE_CLOSED" ],
            "type" : "string"
          },
          "allowJoiningBeforeHost" : {
            "description" : "Whether users can join before host in the conferences of this meeting space.",
            "type" : "boolean"
          },
          "attendanceReportEnabled" : {
            "description" : "Whether attendance report is enabled for the meeting space.",
            "type" : "boolean"
          },
          "chatLock" : {
            "description" : "The chat lock of the meeting space that lets owner control whether the participants can send chat messages.",
            "type" : "boolean"
          },
          "cohostArtifactSharingEnabled" : {
            "description" : "Whether meeting artifacts will be shared with cohosts.",
            "type" : "boolean"
          },
          "cseEnabled" : {
            "description" : "Whether Client-side Encryption is enabled for the meeting space.",
            "type" : "boolean"
          },
          "defaultAsViewer" : {
            "description" : "Whether the default role is viewer or not.",
            "type" : "boolean"
          },
          "moderationEnabled" : {
            "description" : "Indicates whether the meeting space is moderated.",
            "type" : "boolean"
          },
          "presentLock" : {
            "description" : "The present lock of the meeting space that lets owner control whether the participants can present their screen.",
            "type" : "boolean"
          },
          "reactionsLock" : {
            "description" : "The reactions lock of the meeting space that lets owner control whether the participants can send reactions.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "ShareScope" : {
        "properties" : {
          "domain" : {
            "description" : "If scope is DOMAIN, this field contains the dasher domain, for example \"google.com\".",
            "type" : "string"
          },
          "scope" : {
            "description" : "The scope to which the content was shared.",
            "enum" : [ "UNKNOWN", "PRIVATE", "LIMITED", "EXTENDED", "DASHER_DOMAIN", "PUBLIC" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SheetsClientActionMarkup" : {
        "properties" : {
          "customFunctionReturnValueMarkup" : {
            "$ref" : "#/components/schemas/CustomFunctionReturnValueMarkup"
          }
        },
        "type" : "object"
      },
      "SigningKeyPossessorProto" : {
        "description" : "Represents a principal who possesses a signing key corresponding to the verification key or keyset described here.",
        "properties" : {
          "keymasterKeyType" : {
            "description" : "This value must be from the KeyMetadata.Type enum in keymaster.proto.",
            "format" : "int32",
            "type" : "integer"
          },
          "serializedVerificationKey" : {
            "description" : "The actual verification key bytes corresponding to the above type.",
            "format" : "byte",
            "type" : "string"
          },
          "serializedVerificationKeyset" : {
            "description" : "The binary serialized Keymaster SerializedReader of a public keyset. The keyset must contain exactly one key. N.B.: If this field is populated, serialized_verification_key should be set to the empty string and keymaster_key_type should be set to zero.",
            "format" : "byte",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SimpleSecretHolderProto" : {
        "description" : "Represents a principal which possesses a particular, presumably secret, string. Useful for things like \"auth keys,\" used for anonymous sharing. Since representing this principal with the actual secret included reveals the secret, it's best if the requisite condition is enforced in some other way, for example via Keystore wrapping attributes (Keystore will unwrap only if the specified secret, aka \"attribute\", is presented). All that's stored here is an identifying label.",
        "properties" : {
          "label" : {
            "$ref" : "#/components/schemas/SimpleSecretLabelProto"
          }
        },
        "type" : "object"
      },
      "SimpleSecretLabelProto" : {
        "description" : "SimpleSecretProto (in authenticator.proto) and SimpleSecretHolderProto (below) share the notion of a \"label\", which identifies a particular secret without (hopefully) revealing the secret. Note that a SimpleSecretLabel only disambiguates between secrets used to get access to some particular object. Two different secrets that apply to two different objects could have the same label. For example, in the common sharing model, each object has no more than one \"auth key\". Therefore, the label for an auth key simply has type = AUTH_KEY with no additional information. In theory, we could add some sort of resource ID to SimpleSecretLabel to make it more explicit. However, in practice, this is never really needed. A SimpleSecret for one object is never used to authorize a request on some other object, so there is no ambiguity. Also, since SimpleSecrets must obviously be unguessable, there is no risk that a SimpleSecret intended for one object will accidentally grant access to another.",
        "properties" : {
          "capabilityId" : {
            "description" : "***DEPRECATED (3-Oct-2011) *** This field should be deleted when code stops using CAP_TOKEN labels. Used when type = CAP_TOKEN. When a CAP_TOKEN label appears in a SimpleSecretHolder Principal, |capability_id| must be filled in to identify one of the capabilities on the ACL. When a CAP_TOKEN label appears in a SimpleSecret Authenticator, it is NOT necessary to fill in |capability_id| -- ACL Service will find the ID by searching all capabilities on the ACL for one associated with the token given by the SimpleSecret's secret data. If |capability_id| is specified, though, then the Authenticator will only be accepted if it actually matches that particular token ID.",
            "format" : "int32",
            "type" : "integer"
          },
          "genericLabel" : {
            "description" : "Used when type = GENERIC_SECRET",
            "format" : "byte",
            "type" : "string"
          },
          "inviteId" : {
            "description" : "Used when type == INVITE.",
            "format" : "int64",
            "type" : "string"
          },
          "type" : {
            "description" : "This is optional because required enums cannot be extended.",
            "enum" : [ "INVALID", "AUTH_KEY", "INVITE", "GENERIC_SECRET", "CAP_TOKEN", "REKE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SlashCommandMetadata" : {
        "description" : "Annotation metadata for slash commands (/).",
        "properties" : {
          "argumentsHint" : {
            "description" : "Hint string for the arguments expected by the slash command.",
            "type" : "string"
          },
          "commandId" : {
            "description" : "Unique id for the slash command.",
            "format" : "int64",
            "type" : "string"
          },
          "commandName" : {
            "description" : "Name of the slash command.",
            "type" : "string"
          },
          "id" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "triggersDialog" : {
            "description" : "Whether or not this slash command should trigger a dialog.",
            "type" : "boolean"
          },
          "type" : {
            "enum" : [ "TYPE_UNSPECIFIED", "ADD", "INVOKE", "FAILED_TO_ADD" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Snippet" : {
        "description" : "Snippet of the search result, which summarizes the content of the resulting page.",
        "properties" : {
          "matchRanges" : {
            "description" : "The matched ranges in the snippet.",
            "items" : {
              "$ref" : "#/components/schemas/MatchRange"
            },
            "type" : "array"
          },
          "snippet" : {
            "description" : "The snippet of the document. The snippet of the document. May contain escaped HTML character that should be unescaped prior to rendering.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SocialCommonAttachmentAttachment" : {
        "description" : "An Attachment represents a linked entity associated with a piece of social content. This may be a 1st-party or 3rd-party entity. In the Papyrus context, an Attachment is part of a Cent, and sits alongside the main content of the cent, which is represented as a sequence of Segments. Right now an Attachment is just a wrapper around an Embed, but we provide the extra layer of abstraction since, as Embeds move to separate storage in Briefcase, we may want to add additional fields that are not part of the Embed proper, but that (for example) relate to the usage of the linked content within the particular post/cent.",
        "properties" : {
          "embedItem" : {
            "$ref" : "#/components/schemas/EmbedClientItem"
          },
          "id" : {
            "description" : "An id to uniquely identify an attachment when several attachments are in a collection.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SocialGraphNodeProto" : {
        "description" : "Represents a user pseudonym. Pseudonyms are linked accounts on Google and third-party services (e.g. YouTube or Twitter) and are described by a Social Graph Node.",
        "properties" : {
          "sgnDomain" : {
            "description" : "The fields from ccc/socialgraph/socialgraphnode.proto:SgnNode that uniquely identify a social graph node. The 'ident' field is not included here because its value can be changed.",
            "type" : "string"
          },
          "sgnPk" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SortOptions" : {
        "properties" : {
          "operatorName" : {
            "description" : "The name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable.",
            "type" : "string"
          },
          "sortOrder" : {
            "description" : "Ascending is the default sort order",
            "enum" : [ "ASCENDING", "DESCENDING" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Source" : {
        "description" : "Defines sources for the suggest/search APIs.",
        "properties" : {
          "name" : {
            "description" : "Source name for content indexed by the Indexing API.",
            "type" : "string"
          },
          "predefinedSource" : {
            "description" : "Predefined content source for Google Apps.",
            "enum" : [ "NONE", "QUERY_HISTORY", "PERSON", "GOOGLE_DRIVE", "GOOGLE_GMAIL", "GOOGLE_SITES", "GOOGLE_GROUPS", "GOOGLE_CALENDAR", "GOOGLE_KEEP" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SourceConfig" : {
        "description" : "Configurations for a source while processing a Search or Suggest request.",
        "properties" : {
          "crowdingConfig" : {
            "$ref" : "#/components/schemas/SourceCrowdingConfig"
          },
          "scoringConfig" : {
            "$ref" : "#/components/schemas/SourceScoringConfig"
          },
          "source" : {
            "$ref" : "#/components/schemas/Source"
          }
        },
        "type" : "object"
      },
      "SourceCrowdingConfig" : {
        "description" : "Set search results crowding limits. Crowding is a situation in which multiple results from the same source or host \"crowd out\" other results, diminishing the quality of search for users. To foster better search quality and source diversity in search results, you can set a condition to reduce repetitive results by source.",
        "properties" : {
          "numResults" : {
            "description" : "Maximum number of results allowed from a datasource in a result page as long as results from other sources are not exhausted. Value specified must not be negative. A default value is used if this value is equal to 0. To disable crowding, set the value greater than 100.",
            "format" : "int32",
            "type" : "integer"
          },
          "numSuggestions" : {
            "description" : "Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "SourceResultCount" : {
        "description" : "Per source result count information.",
        "properties" : {
          "hasMoreResults" : {
            "description" : "Whether there are more search results for this source.",
            "type" : "boolean"
          },
          "resultCountEstimate" : {
            "description" : "The estimated result count for this source.",
            "format" : "int64",
            "type" : "string"
          },
          "resultCountExact" : {
            "description" : "The exact result count for this source.",
            "format" : "int64",
            "type" : "string"
          },
          "source" : {
            "$ref" : "#/components/schemas/Source"
          }
        },
        "type" : "object"
      },
      "SourceScoringConfig" : {
        "description" : "Set the scoring configuration. This allows modifying the ranking of results for a source.",
        "properties" : {
          "sourceImportance" : {
            "description" : "Importance of the source.",
            "enum" : [ "DEFAULT", "LOW", "HIGH" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SpaceId" : {
        "description" : "Primary key for Space resource.",
        "properties" : {
          "spaceId" : {
            "description" : "Unique, immutable ID of the Space",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SpellResult" : {
        "properties" : {
          "suggestedQuery" : {
            "description" : "The suggested spelling of the query.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SquareProto" : {
        "description" : "Represents the set of members (of a given type) in a Google+ Square (see http://go/squares). A Square with default member_type is currently (1/2012) identical to the GaiaGroup with the same ID, but that is expected to change soon (see http://go/superglue). Support for this principal type is currently (1/2012) incomplete -- e.g., Keystore does not support it yet (see b/5703421).",
        "properties" : {
          "memberType" : {
            "description" : "The type of Square members to consider, e.g. \"all members\" vs. \"owners\" vs. \"admins\". These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See square.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with square. Currently required.",
            "format" : "int32",
            "type" : "integer"
          },
          "squareId" : {
            "description" : "Currently required.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "StartUploadItemRequest" : {
        "description" : "Start upload file request.",
        "properties" : {
          "connectorName" : {
            "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
            "type" : "string"
          },
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          }
        },
        "type" : "object"
      },
      "Status" : {
        "description" : "The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
        "properties" : {
          "code" : {
            "description" : "The status code, which should be an enum value of google.rpc.Code.",
            "format" : "int32",
            "type" : "integer"
          },
          "details" : {
            "description" : "A list of messages that carry the error details. There is a common set of message types for APIs to use.",
            "items" : {
              "additionalProperties" : {
                "description" : "Properties of the object. Contains field @type with type URL."
              },
              "type" : "object"
            },
            "type" : "array"
          },
          "message" : {
            "description" : "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "StoredParticipantId" : {
        "properties" : {
          "gaiaId" : {
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "StreamViewerStats" : {
        "description" : "Information about viewers of the stream.",
        "properties" : {
          "estimatedViewerCount" : {
            "description" : "The estimate of the current viewer count.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "StreamingSessionInfo" : {
        "description" : "Information about a streaming session in conference.",
        "properties" : {
          "applicationType" : {
            "description" : "The application type of the current streaming session.",
            "enum" : [ "RECORDING_APPLICATION_TYPE_UNSPECIFIED", "RECORDING", "GLIVE_STREAM", "BROADCAST" ],
            "type" : "string"
          },
          "latestSessionEvent" : {
            "$ref" : "#/components/schemas/SessionEvent"
          },
          "ownerDisplayName" : {
            "description" : "The display name of the owner of the recording output. It's only set when there will be uploaded recordings. Currently, it's only set when application type is RECORDING or GLIVE_STREAM.",
            "type" : "string"
          },
          "sessionId" : {
            "description" : "This is the REST name and unique identifier of this streaming session and has the form `spaces//recordings/` This is returned whenever status is either `STARTING` or `STARTED`.",
            "type" : "string"
          },
          "status" : {
            "description" : "The current status of this streaming session. This can be used by clients to show session status indicator and/or notification.",
            "enum" : [ "STATUS_UNSPECIFIED", "INACTIVE", "STARTING", "LIVE" ],
            "type" : "string"
          },
          "trainingEnabled" : {
            "description" : "When true, this recording may be used for training new transcription models.",
            "type" : "boolean"
          },
          "viewerAccessPolicy" : {
            "description" : "The policy that controls who can view the broadcast. This setting applies for broadcast session.",
            "enum" : [ "BROADCASTING_ACCESS_POLICY_UNSPECIFIED", "ORGANIZATION", "PUBLIC" ],
            "type" : "string"
          },
          "viewerStats" : {
            "$ref" : "#/components/schemas/StreamViewerStats"
          }
        },
        "type" : "object"
      },
      "StructuredDataObject" : {
        "description" : "A structured data object consisting of named properties.",
        "properties" : {
          "properties" : {
            "description" : "The properties for the object. The maximum number of elements is 1000.",
            "items" : {
              "$ref" : "#/components/schemas/NamedProperty"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "StructuredResult" : {
        "description" : "Structured results that are returned as part of search request.",
        "properties" : {
          "person" : {
            "$ref" : "#/components/schemas/Person"
          }
        },
        "type" : "object"
      },
      "SuggestRequest" : {
        "description" : "Request of suggest API.",
        "properties" : {
          "dataSourceRestrictions" : {
            "description" : "The sources to use for suggestions. If not specified, the data sources are taken from the current search application. NOTE: Suggestions are only supported for the following sources: * Third-party data sources * PredefinedSource.PERSON * PredefinedSource.GOOGLE_DRIVE",
            "items" : {
              "$ref" : "#/components/schemas/DataSourceRestriction"
            },
            "type" : "array"
          },
          "query" : {
            "description" : "Partial query for which autocomplete suggestions will be shown. For example, if the query is \"sea\", then the server might return \"season\", \"search\", \"seagull\" and so on.",
            "type" : "string"
          },
          "requestOptions" : {
            "$ref" : "#/components/schemas/RequestOptions"
          }
        },
        "type" : "object"
      },
      "SuggestResponse" : {
        "description" : "Response of the suggest API.",
        "properties" : {
          "suggestResults" : {
            "description" : "List of suggestions.",
            "items" : {
              "$ref" : "#/components/schemas/SuggestResult"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "SuggestResult" : {
        "description" : "One suggestion result.",
        "properties" : {
          "peopleSuggestion" : {
            "$ref" : "#/components/schemas/PeopleSuggestion"
          },
          "querySuggestion" : {
            "$ref" : "#/components/schemas/QuerySuggestion"
          },
          "source" : {
            "$ref" : "#/components/schemas/Source"
          },
          "suggestedQuery" : {
            "description" : "The suggested query that will be used for search, when the user clicks on the suggestion",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SupportUrls" : {
        "description" : "Urls with additional bot related information.",
        "properties" : {
          "adminConfigUrl" : {
            "description" : "Link to the admin configuration webpage for the bot. Configured by Pantheon, may be empty.",
            "type" : "string"
          },
          "deletionPolicyUrl" : {
            "description" : "Link to the deletion policy webpage for the bot. Configured by Pantheon, may be empty.",
            "type" : "string"
          },
          "gwmUrl" : {
            "description" : "Link to GWM page of the app. May be empty.",
            "type" : "string"
          },
          "privacyPolicyUrl" : {
            "description" : "Link to the privacy policy webpage for the bot. May be empty.",
            "type" : "string"
          },
          "setupUrl" : {
            "description" : "Link to the setup webpage for the bot. Configured by Pantheon, may be empty.",
            "type" : "string"
          },
          "supportUrl" : {
            "description" : "Link to the support webpage for the developer of the bot. May be empty.",
            "type" : "string"
          },
          "tosUrl" : {
            "description" : "Link to the terms of service webpage for the bot. May be empty.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "SwitchWidget" : {
        "properties" : {
          "controlType" : {
            "enum" : [ "UNSPECIFIED", "SWITCH", "CHECKBOX" ],
            "type" : "string"
          },
          "name" : {
            "description" : "The name of the switch widget which is will be used in FormInput.",
            "type" : "string"
          },
          "onChange" : {
            "$ref" : "#/components/schemas/FormAction"
          },
          "selected" : {
            "type" : "boolean"
          },
          "value" : {
            "description" : "The value is what is passed back in apps script callback.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TaskActionMarkup" : {
        "properties" : {
          "reloadTasks" : {
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "TextButton" : {
        "properties" : {
          "altText" : {
            "description" : "The alternative text used for accessibility Next field number: 7.",
            "type" : "string"
          },
          "backgroundColor" : {
            "description" : "Optional color of the button's background in RAISE mode. The default is the secondary color from addon's manifest.",
            "type" : "string"
          },
          "disabled" : {
            "type" : "boolean"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          },
          "style" : {
            "enum" : [ "UNSPECIFIED", "TEXT", "FILLED" ],
            "type" : "string"
          },
          "text" : {
            "description" : "Text color can be set via HTML markup.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TextField" : {
        "properties" : {
          "autoComplete" : {
            "$ref" : "#/components/schemas/AutoComplete"
          },
          "autoCompleteCallback" : {
            "$ref" : "#/components/schemas/FormAction"
          },
          "autoCompleteMultipleSelections" : {
            "description" : "When set to true, a user can input multiple auto-complet items.",
            "type" : "boolean"
          },
          "hintText" : {
            "type" : "string"
          },
          "label" : {
            "description" : "One of label or hint_text is required to be specified by the developers.",
            "type" : "string"
          },
          "maxLines" : {
            "format" : "int32",
            "type" : "integer"
          },
          "name" : {
            "description" : "The name of the text field which is will be used in FormInput.",
            "type" : "string"
          },
          "onChange" : {
            "$ref" : "#/components/schemas/FormAction"
          },
          "type" : {
            "enum" : [ "SINGLE_LINE", "MULTIPLE_LINE" ],
            "type" : "string"
          },
          "value" : {
            "description" : "The default value when no input from user.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TextKeyValue" : {
        "description" : "This is deprecated and please use KeyValue.",
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "onClick" : {
            "$ref" : "#/components/schemas/OnClick"
          },
          "text" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TextOperatorOptions" : {
        "description" : "Used to provide a search operator for text properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.",
        "properties" : {
          "exactMatchWithOperator" : {
            "description" : "If true, the text value is tokenized as one atomic value in operator searches and facet matches. For example, if the operator name is \"genre\" and the value is \"science-fiction\" the query restrictions \"genre:science\" and \"genre:fiction\" doesn't match the item; \"genre:science-fiction\" does. Text value matching is case-sensitive and does not remove special characters. If false, the text is tokenized. For example, if the value is \"science-fiction\" the queries \"genre:science\" and \"genre:fiction\" matches the item.",
            "type" : "boolean"
          },
          "operatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the text property. For example, if operatorName is *subject* and the property's name is *subjectLine*, then queries like *subject:<value>* show results only where the value of the property named *subjectLine* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any text properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TextParagraph" : {
        "properties" : {
          "text" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TextPropertyOptions" : {
        "description" : "The options for text properties.",
        "properties" : {
          "operatorOptions" : {
            "$ref" : "#/components/schemas/TextOperatorOptions"
          },
          "retrievalImportance" : {
            "$ref" : "#/components/schemas/RetrievalImportance"
          }
        },
        "type" : "object"
      },
      "TextValues" : {
        "description" : "List of text values.",
        "properties" : {
          "values" : {
            "description" : "The maximum allowable length for text values is 2048 characters.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "ThreadKeySet" : {
        "description" : "The ThreadKey was set on some (subset of the) messages in this thread.",
        "properties" : {
          "messageKeys" : {
            "description" : "Messages on which the thread_key was changed.",
            "items" : {
              "$ref" : "#/components/schemas/MultiKey"
            },
            "type" : "array"
          },
          "newThreadKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          }
        },
        "type" : "object"
      },
      "ThreadUpdate" : {
        "description" : "HistoryRecord for changes associated with a thread, namely: MESSAGE_ADDED MESSAGE_DELETED LABEL_ADDED LABEL_REMOVED ATTRIBUTE_SET ATTRIBUTE_REMOVED THREAD_KEY_SET All label_ids refer to the (unchanging) value as defined by the Label.id field in labels.proto. In particular, it is *not* the canonical_name.",
        "properties" : {
          "attributeRemoved" : {
            "$ref" : "#/components/schemas/AttributeRemoved"
          },
          "attributeSet" : {
            "$ref" : "#/components/schemas/AttributeSet"
          },
          "labelAdded" : {
            "$ref" : "#/components/schemas/LabelAdded"
          },
          "labelRemoved" : {
            "$ref" : "#/components/schemas/LabelRemoved"
          },
          "lastHistoryRecordId" : {
            "description" : "Indicates the record id of the last operation that modified this thread.",
            "format" : "uint64",
            "type" : "string"
          },
          "messageAdded" : {
            "$ref" : "#/components/schemas/MessageAdded"
          },
          "messageDeleted" : {
            "$ref" : "#/components/schemas/MessageDeleted"
          },
          "originalThreadKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "preState" : {
            "description" : "The PreStates of all messages before the transaction. These are suppressed if the client requested that prestates not be included in the output of the GetHistoryRequest.",
            "items" : {
              "$ref" : "#/components/schemas/PreState"
            },
            "type" : "array"
          },
          "threadKey" : {
            "$ref" : "#/components/schemas/MultiKey"
          },
          "threadKeySet" : {
            "$ref" : "#/components/schemas/ThreadKeySet"
          },
          "threadLocator" : {
            "description" : "Thread PLID",
            "type" : "string"
          },
          "topicStateUpdate" : {
            "$ref" : "#/components/schemas/TopicStateUpdate"
          }
        },
        "type" : "object"
      },
      "TimestampOperatorOptions" : {
        "description" : "Used to provide a search operator for timestamp properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.",
        "properties" : {
          "greaterThanOperatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the timestamp property using the greater-than operator. For example, if greaterThanOperatorName is *closedafter* and the property's name is *closeDate*, then queries like *closedafter:<value>* show results only where the value of the property named *closeDate* is later than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          },
          "lessThanOperatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the timestamp property using the less-than operator. For example, if lessThanOperatorName is *closedbefore* and the property's name is *closeDate*, then queries like *closedbefore:<value>* show results only where the value of the property named *closeDate* is earlier than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          },
          "operatorName" : {
            "description" : "Indicates the operator name required in the query in order to isolate the timestamp property. For example, if operatorName is *closedon* and the property's name is *closeDate*, then queries like *closedon:<value>* show results only where the value of the property named *closeDate* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TimestampPropertyOptions" : {
        "description" : "The options for timestamp properties.",
        "properties" : {
          "operatorOptions" : {
            "$ref" : "#/components/schemas/TimestampOperatorOptions"
          }
        },
        "type" : "object"
      },
      "TimestampValues" : {
        "description" : "List of timestamp values.",
        "properties" : {
          "values" : {
            "items" : {
              "format" : "google-datetime",
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "TombstoneMetadata" : {
        "description" : "Tombstoning is the act of leaving a contextual trace when deleting a message. See more: go/tombstone-prd, go/hub-dynamite-tombstones-server-design-v2.",
        "properties" : {
          "tombstoneType" : {
            "description" : "Indicates the type of Tombstone.",
            "enum" : [ "TOMBSTONE_UNSPECIFIED", "CREATOR", "ROOM_OWNER", "ADMIN", "APP_MESSAGE_EXPIRY", "CREATOR_VIA_APP", "ROOM_OWNER_VIA_APP" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Toolbar" : {
        "description" : "The Toolbar markup has been deprecated. The information is now specified in the manifest.",
        "properties" : {
          "color" : {
            "description" : "Background color of the toolbar in RBG hex representation.",
            "type" : "string"
          },
          "iconUrl" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TopicId" : {
        "properties" : {
          "groupId" : {
            "$ref" : "#/components/schemas/GroupId"
          },
          "topicId" : {
            "description" : "Opaque, server-assigned ID of the Topic. While this ID is guaranteed to be unique within the Space, it's not guaranteed to be globally unique. Internal usage: this field can be empty in the following cases: 1. To create the first message in a topic. 2. To list last N messages of a Space (regardless of topic).",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TopicState" : {
        "description" : "State of an topic thread as maintained within Tingle.",
        "properties" : {
          "labelIdMessageCount" : {
            "additionalProperties" : {
              "format" : "int32",
              "type" : "integer"
            },
            "description" : "Map of label => count of topic constituent messages with label These only contain counts of labels that are relevant for topic normalization/denormalization. Eg. If a topic thread has 5 constituents, 4 of which are in inbox, this will contain ^i => 4. Some labels of interest are archive, inbox, trash, spam, etc.",
            "type" : "object"
          },
          "numConstituents" : {
            "description" : "Number of constituents for this entity.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "TopicStateUpdate" : {
        "properties" : {
          "topicState" : {
            "$ref" : "#/components/schemas/TopicState"
          }
        },
        "type" : "object"
      },
      "TransactionContext" : {
        "description" : "Storage information pertaining to the transaction with which a HistoryRecord is associated.",
        "properties" : {
          "endingRecordId" : {
            "description" : "The last HistoryRecord of the transaction. Note that this may correspond to a record that is filtered by Tingle (and thus not returned to the client). See http://b/9513464.",
            "format" : "uint64",
            "type" : "string"
          },
          "startingRecordId" : {
            "description" : "The first HistoryRecord of the transaction. Note that this may be a record of type INTERNAL.",
            "format" : "uint64",
            "type" : "string"
          },
          "writeTimestampUs" : {
            "description" : "The microsecond timestamp of the transaction.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TransactionDebugInfo" : {
        "description" : "HistoryRecord for debug info associated with the transaction, namely: TXN_DEBUG_INFO TODO(b/143845917) This is a short-term workaround for unblocking fusebox writes migration. Clean up the code or land a long-term solution after the rollout. go/diff-to-historyrecord",
        "type" : "object"
      },
      "TranscriptionSessionInfo" : {
        "description" : "Information about a transcription session.",
        "properties" : {
          "sessionStateInfo" : {
            "$ref" : "#/components/schemas/SessionStateInfo"
          },
          "transcriptionSessionId" : {
            "description" : "A unique server-generated ID for the transcription session.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TransientData" : {
        "description" : "Transient generic data that will not be saved on the server.",
        "type" : "object"
      },
      "Trigger" : {
        "properties" : {
          "actionType" : {
            "description" : "Each dispatcher should use an enum to for the actions that it supports. If a dispatcher has only one action, this does not need to be set. (It can be expanded later, defining the default behaviour as type 0.) For purposes such as batching, the type of a trigger is (dispatcher, action_type).",
            "format" : "uint32",
            "type" : "integer"
          },
          "batchTimeUs" : {
            "description" : "Maximum possible delay in micros that can be tolerated so triggers can be batched, which makes processing more efficient compared to firing triggers individually. Note that the actual fire time will be somewhere in the timerange interval [fire_time_us, fire_time_us + batch_time_us).",
            "format" : "int64",
            "type" : "string"
          },
          "dispatchId" : {
            "description" : "Must be set for DISPATCHER_STUBBY_DISPATCHER.",
            "format" : "uint32",
            "type" : "integer"
          },
          "dispatcher" : {
            "description" : "Which server should interpret action_type.",
            "enum" : [ "DISPATCHER_COPROC", "DISPATCHER_JOBSETTED_PRIMARY", "DISPATCHER_STRATUS", "DISPATCHER_TASKS_SERVER", "DISPATCHER_STUBBY_DISPATCHER", "DISPATCHER_CS" ],
            "type" : "string"
          },
          "fireTimeUs" : {
            "description" : "Earliest time to fire at in microseconds. The actual time that the trigger will fire will be in the timerange: [fire_time_us, fire_time_us + batch_time_us).",
            "format" : "int64",
            "type" : "string"
          },
          "jobsettedServerSpec" : {
            "$ref" : "#/components/schemas/JobsettedServerSpec"
          },
          "key" : {
            "description" : "The trigger key, if applicable.",
            "type" : "string"
          },
          "rpcOptions" : {
            "$ref" : "#/components/schemas/RpcOptions"
          },
          "sliceFireTimeUs" : {
            "description" : "The slice_fire_time_us is automatically computed and stored as part of the trigger write. It represents the exact fire time at which the trigger will be queued to fire and will satisfy fire_time_us < slice_fire_time_us <= fire_time_us + batch_time_us Triggers have an index row in the slice trigger index with the row prefix matching this time. Note that this field is internal to gmail_cp and is ignored if set by external clients when adding / updating triggers.",
            "format" : "int64",
            "type" : "string"
          },
          "triggerAction" : {
            "$ref" : "#/components/schemas/TriggerAction"
          },
          "triggerKey" : {
            "$ref" : "#/components/schemas/TriggerKey"
          }
        },
        "type" : "object"
      },
      "TriggerAction" : {
        "properties" : {
          "action" : {
            "enum" : [ "ACTION_NONE", "ACTION_DELETE", "ACTION_CREATE_NEW_TRIGGER", "ACTION_MESSAGE_EXPUNGE", "ACTION_RETENTION_POLICY_UPDATE", "ACTION_UPDATE_ICEBOX_MODEL", "ACTION_INVOKE_CS", "ACTION_INVOKE_STRATUS", "ACTION_PDH_EXPUNGE", "ACTION_QUERY_RETENTION", "ACTION_INVOKE_JOBSETTED_PRIMARY", "ACTION_INVOKE_TASKS_SERVER", "ACTION_INVOKE_PUBLISHER", "ACTION_INVOKE_OBSERVER", "ACTION_PUSH_HISTORY_TO_PDH", "ACTION_INVOKE_STUBBY_DISPATCHER", "ACTION_PDH_BACKFILL", "ACTION_MESSAGE_UNDELETE", "ACTION_VAULT_END_USER_ACCESS", "ACTION_INVOKE_GROUPS", "ACTION_ACCOUNT_INITIALIZATION", "ACTION_INVOKE_OBSERVER_WIPEOUT", "ACTION_SERVICE_REMOVED_MESSAGE_EXPUNGE", "ACTION_EVERCLEAR_EXPUNGE", "ACTION_INVOKE_SMIME_CERTIFICATE_ISSUER", "ACTION_GROUPS_QUERY_RETENTION", "ACTION_INVOKE_SATELLITE_BACKUP", "ACTION_INVOKE_DEBUG_LOG", "ACTION_PREFERENCE_CLEANUP", "ACTION_CARIBOU_DATA_RETENTION", "ACTION_HISTORY_CLEANUP", "ACTION_ITEM_BULK_RELABEL", "ACTION_INVOKE_SATELLITE_IMAGE_PROCESSING", "ACTION_CARIBOU_DATA_RETENTION_DIFF", "ACTION_RELEVANCY_SCORE_BACKFILL", "ACTION_PDH_PUSH_NOTIFICATION_BACKFILL", "ACTION_AUTO_SAVE_DRAFT_EXPUNGE" ],
            "type" : "string"
          },
          "data" : {
            "description" : "Clients should use extensions on the Trigger message instead.",
            "format" : "byte",
            "type" : "string"
          },
          "dataInt" : {
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TriggerKey" : {
        "description" : "A TriggerKey (type + instance_id) uniquely identifies a trigger within a message for a message-trigger and within an account for an account-trigger.",
        "properties" : {
          "instanceId" : {
            "description" : "Identifier to distinguish multiple Triggers of the same type (per message or per account).",
            "type" : "string"
          },
          "type" : {
            "description" : "A non-empty string that identifies the type of Trigger. Triggers of the same type may be batched together. The universe of values for the type field should be finite as it is used as a stats key.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Triggers" : {
        "properties" : {
          "triggers" : {
            "description" : "A list of triggers.",
            "items" : {
              "$ref" : "#/components/schemas/Trigger"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "TrustedResourceUrlProto" : {
        "description" : "Message containing a string that is safe to use in all URL contexts in DOM APIs and HTML documents; even where the referred-to resource is interpreted as code, e.g., as the src of a script element.",
        "properties" : {
          "privateDoNotAccessOrElseTrustedResourceUrlWrappedValue" : {
            "description" : "IMPORTANT: Never set or read this field, even from tests, it is private. See documentation at the top of .proto file for programming language packages with which to create or read this message.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "TypeInfo" : {
        "description" : "Next tag: 2",
        "properties" : {
          "videoInfo" : {
            "$ref" : "#/components/schemas/VideoInfo"
          }
        },
        "type" : "object"
      },
      "UniversalPhoneAccess" : {
        "description" : "Universal phone access contains information required to dial into a conference using one of a static list of phone numbers and a universal PIN. The phone number list is distributed separately.",
        "properties" : {
          "pin" : {
            "description" : "The PIN that users must enter after dialing a universal number. The pin consists of only decimal digits and the length may vary, though it generally is longer than a PhoneAccess.pin.",
            "type" : "string"
          },
          "pstnInfoUrl" : {
            "description" : "This field has the same contents as the MeetingSpace.more_join_url field, and is included for compatibility reasons. Clients should use the other field instead. This field is deprecated and will be removed.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UnmappedIdentity" : {
        "properties" : {
          "externalIdentity" : {
            "$ref" : "#/components/schemas/Principal"
          },
          "resolutionStatusCode" : {
            "description" : "The resolution status for the external identity.",
            "enum" : [ "CODE_UNSPECIFIED", "NOT_FOUND", "IDENTITY_SOURCE_NOT_FOUND", "IDENTITY_SOURCE_MISCONFIGURED", "TOO_MANY_MAPPINGS_FOUND", "INTERNAL_ERROR" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UnreserveItemsRequest" : {
        "properties" : {
          "connectorName" : {
            "description" : "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}",
            "type" : "string"
          },
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "queue" : {
            "description" : "The name of a queue to unreserve items from.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UpdateBccRecipients" : {
        "properties" : {
          "bccRecipients" : {
            "items" : {
              "$ref" : "#/components/schemas/Recipient"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "UpdateBody" : {
        "properties" : {
          "insertContents" : {
            "description" : "A repeated field that contains a series of content to insert into the draft that the user is currently editing. The content can contain HTML content or plain text content.",
            "items" : {
              "$ref" : "#/components/schemas/InsertContent"
            },
            "type" : "array"
          },
          "type" : {
            "enum" : [ "UNSPECIFIED_ACTION_TYPE", "IN_PLACE_INSERT", "INSERT_AT_START", "INSERT_AT_END", "REPLACE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UpdateCcRecipients" : {
        "properties" : {
          "ccRecipients" : {
            "items" : {
              "$ref" : "#/components/schemas/Recipient"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "UpdateDataSourceRequest" : {
        "properties" : {
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "source" : {
            "$ref" : "#/components/schemas/DataSource"
          },
          "updateMask" : {
            "description" : "Only applies to [`settings.datasources.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.datasources/patch). Update mask to control which fields to update. Example field paths: `name`, `displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don't specify its value in the source, that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated.",
            "format" : "google-fieldmask",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UpdateDraftActionMarkup" : {
        "properties" : {
          "updateBccRecipients" : {
            "$ref" : "#/components/schemas/UpdateBccRecipients"
          },
          "updateBody" : {
            "$ref" : "#/components/schemas/UpdateBody"
          },
          "updateCcRecipients" : {
            "$ref" : "#/components/schemas/UpdateCcRecipients"
          },
          "updateSubject" : {
            "$ref" : "#/components/schemas/UpdateSubject"
          },
          "updateToRecipients" : {
            "$ref" : "#/components/schemas/UpdateToRecipients"
          }
        },
        "type" : "object"
      },
      "UpdateSchemaRequest" : {
        "properties" : {
          "debugOptions" : {
            "$ref" : "#/components/schemas/DebugOptions"
          },
          "schema" : {
            "$ref" : "#/components/schemas/Schema"
          },
          "validateOnly" : {
            "description" : "If true, the schema will be checked for validity, but will not be registered with the data source, even if valid.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "UpdateSubject" : {
        "properties" : {
          "subject" : {
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UpdateToRecipients" : {
        "properties" : {
          "toRecipients" : {
            "items" : {
              "$ref" : "#/components/schemas/Recipient"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "UploadItemRef" : {
        "description" : "Represents an upload session reference. This reference is created via upload method. This reference is valid for 30 days after its creation. Updating of item content may refer to this uploaded content via contentDataRef.",
        "properties" : {
          "name" : {
            "description" : "The name of the content reference. The maximum length is 2048 characters.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UploadMetadata" : {
        "description" : "Annotation metadata for user Upload artifacts.",
        "properties" : {
          "attachmentToken" : {
            "description" : "Opaque token. Clients shall simply pass it back to the Backend. There is no guarantee the attachment_token returned on subsequent reads is the same even if nothing has changed. This field will NOT be saved into storage.",
            "type" : "string"
          },
          "backendUploadMetadata" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedBackendUploadMetadata"
          },
          "clonedAuthorizedItemId" : {
            "$ref" : "#/components/schemas/AuthorizedItemId"
          },
          "clonedDriveAction" : {
            "description" : "DriveAction for organizing the cloned version of this upload in Drive, if the file has been added to Drive. This field is not set if the file has not been added to Drive. Additionally, this field is only set when part of a FileResult in a ListFilesResponse.",
            "enum" : [ "DRIVE_ACTION_UNSPECIFIED", "ADD_TO_DRIVE", "ORGANIZE", "ADD_SHORTCUT", "ADD_ANOTHER_SHORTCUT" ],
            "type" : "string"
          },
          "clonedDriveId" : {
            "description" : "Reference to a Drive ID, if this upload file has been previously cloned to Drive. Note: this is deprecated in favor of the AuthorizedItemId below.",
            "type" : "string"
          },
          "contentName" : {
            "description" : "The original file name for the content, not the full path.",
            "type" : "string"
          },
          "contentType" : {
            "description" : "Type is from Scotty's best_guess by default: http://google3/uploader/agent/scotty_agent.proto?l=51&rcl=140889785",
            "type" : "string"
          },
          "dlpMetricsMetadata" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedDlpMetricsMetadata"
          },
          "latestVirusScanTimestamp" : {
            "description" : "The timestamp of the most recent virus scan completed (in microseconds).",
            "format" : "int64",
            "type" : "string"
          },
          "localId" : {
            "description" : "A copy of the LocalId in Annotation. This field is supposed to be filled by server only.",
            "type" : "string"
          },
          "originalDimension" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedDimension"
          },
          "videoReference" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedVideoReference"
          },
          "virusScanResult" : {
            "description" : "Result for a virus scan. It's duplicated in the above field apps.dynamite.shared.BackendUploadMetadata",
            "enum" : [ "UNKNOWN_VIRUS_SCAN_RESULT", "CLEAN", "INFECTED", "ERROR", "POLICY_VIOLATION" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UrlMetadata" : {
        "description" : "Annotation metadata for a Weblink. In case of pasted link it can qualify to be other types in addition to being a URL - like DRIVE_DOC/DRIVE_SHEET and so on. The URL metadata will also be present and it's up to the client to decide which metadata to render it with. These fields are filled in using page render service.",
        "properties" : {
          "domain" : {
            "description" : "Domain for this url. If it's an IP address the address is returned.",
            "type" : "string"
          },
          "gwsUrl" : {
            "$ref" : "#/components/schemas/SafeUrlProto"
          },
          "gwsUrlExpirationTimestamp" : {
            "description" : "The expiration timestamp for GWS URL, only set when gws_url is set.",
            "format" : "int64",
            "type" : "string"
          },
          "imageHeight" : {
            "description" : "Dimensions of the image: height. This field is string to match with page render service response. Deprecated. Use int_image_height instead.",
            "type" : "string"
          },
          "imageUrl" : {
            "description" : "Representative image of the website.",
            "type" : "string"
          },
          "imageWidth" : {
            "description" : "Dimensions of the image: width. This field is string to match with page render service response. Deprecated. Use int_image_height instead.",
            "type" : "string"
          },
          "intImageHeight" : {
            "description" : "Dimensions of the image: height.",
            "format" : "int32",
            "type" : "integer"
          },
          "intImageWidth" : {
            "description" : "Dimensions of the image: width.",
            "format" : "int32",
            "type" : "integer"
          },
          "mimeType" : {
            "description" : "Mime type of the content (Currently mapped from Page Render Service ItemType) Note that this is not necessarily the mime type of the http resource. For example a text/html from youtube or vimeo may actually be classified as a video type. Then we shall mark it as video/* since we don't know exactly what type of video it is.",
            "type" : "string"
          },
          "redirectUrl" : {
            "$ref" : "#/components/schemas/SafeUrlProto"
          },
          "shouldNotRender" : {
            "description" : "If the UrlMetadata is missing data for rendering a chip. Deprecated. Use Annotation.ChipRenderType instead.",
            "type" : "boolean"
          },
          "snippet" : {
            "description" : "Snippet/small description of the weblink.",
            "type" : "string"
          },
          "title" : {
            "description" : "Title of the Weblink.",
            "type" : "string"
          },
          "url" : {
            "$ref" : "#/components/schemas/SafeUrlProto"
          },
          "urlSource" : {
            "enum" : [ "URL_SOURCE_UNKNOWN", "SERVER_SUPPLIED_POLICY_VIOLATION", "AUTO_DETECTED_PLAIN_TEXT", "RICH_TEXT" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "User" : {
        "description" : "User profile information. This user is not necessarily member of a space.",
        "properties" : {
          "avatarUrl" : {
            "description" : "URL for the avatar picture of the User in dynamite",
            "type" : "string"
          },
          "blockRelationship" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedUserBlockRelationship"
          },
          "botInfo" : {
            "$ref" : "#/components/schemas/BotInfo"
          },
          "deleted" : {
            "description" : "Deleted flag, if true, means User has been soft-deleted/purged Deprecated. Use user_account_state field instead.",
            "type" : "boolean"
          },
          "email" : {
            "description" : "Email ID of the user",
            "type" : "string"
          },
          "firstName" : {
            "description" : "First or given name of the user",
            "type" : "string"
          },
          "gender" : {
            "description" : "Gender of the user",
            "type" : "string"
          },
          "id" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "isAnonymous" : {
            "description" : "Set to true if none of the depending services (Gaia, PeopleApi) returns any info for this user.",
            "type" : "boolean"
          },
          "lastName" : {
            "description" : "Last or family name of the user",
            "type" : "string"
          },
          "name" : {
            "description" : "Non-unique, user-defined display name of the User",
            "type" : "string"
          },
          "organizationInfo" : {
            "$ref" : "#/components/schemas/AppsDynamiteSharedOrganizationInfo"
          },
          "phoneNumber" : {
            "description" : "Phone number(s) of the user",
            "items" : {
              "$ref" : "#/components/schemas/AppsDynamiteSharedPhoneNumber"
            },
            "type" : "array"
          },
          "userAccountState" : {
            "description" : "State of user's Gaia Account",
            "enum" : [ "UNKNOWN_USER_ACCOUNT_STATE", "ENABLED", "DISABLED", "DELETED", "TEMPORARY_UNAVAILABLE" ],
            "type" : "string"
          },
          "userProfileVisibility" : {
            "description" : "Visibility of user's Profile",
            "enum" : [ "UNKNOWN_USER_PROFILE_VISIBILITY", "FULL_PROFILE", "PRIMARY_MAIL", "INVITEE_EMAIL", "DELETED_USER", "UNKNOWN_USER", "FAILURE" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UserDisplayInfo" : {
        "description" : "Resource for displaying user info",
        "properties" : {
          "avatarUrl" : {
            "description" : "The avatar to show for this user",
            "type" : "string"
          },
          "displayName" : {
            "description" : "The name to show for this user",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UserId" : {
        "description" : "Primary key for User resource.",
        "properties" : {
          "actingUserId" : {
            "description" : "Optional. Opaque, server-assigned ID of the user profile associated with App/user acting on behalf of the human user. This is currently only set when a 3P application is acting on the user's behalf.",
            "type" : "string"
          },
          "id" : {
            "description" : "Opaque, server-assigned ID of the User.",
            "type" : "string"
          },
          "originAppId" : {
            "$ref" : "#/components/schemas/AppId"
          },
          "type" : {
            "description" : "Clients do not need to send UserType to Backend, but Backend will always send this field to clients per the following rule: 1. For HUMAN Ids, the field is empty but by default .getType() will return HUMAN. 2. For BOT Ids, the field is ALWAYS set to BOT.",
            "enum" : [ "HUMAN", "BOT" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UserInfo" : {
        "description" : "Contains info regarding the updater of an Activity Feed item. Next Id: 8",
        "properties" : {
          "driveNotificationAvatarUrl" : {
            "description" : "Avatar url of the user who triggered the Drive Notification email. This field will be populated if we can extract such information from the Drive Notification email. This should only be used to fetch user avatars when updater_to_show_email is not populated. This field is not set for non-Drive Notification items.",
            "type" : "string"
          },
          "updaterCountDisplayType" : {
            "description" : "Describes how updater_count_to_show should be used.",
            "enum" : [ "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED", "NO_DISPLAY_COUNT", "EXACT_COUNT", "NONZERO_COUNT" ],
            "type" : "string"
          },
          "updaterCountToShow" : {
            "description" : "The number of updaters for clients to show depending on UpdaterCountDisplayType.",
            "format" : "int32",
            "type" : "integer"
          },
          "updaterToShowEmail" : {
            "description" : "The email of the updater for clients to show used for Gmail items. For Drive Notifications, this is the email of the user who triggered the Drive Notification email. This field will be populated if we can extract such information from the Drive Notification email. This is not the actual sender of the email, as the sender is always comments-noreply@docs.google.com.",
            "type" : "string"
          },
          "updaterToShowGaiaId" : {
            "description" : "The gaia id of the updater for clients to show used for Gmail items. If the updater is an external user, the email field below should be populated.",
            "format" : "int64",
            "type" : "string"
          },
          "updaterToShowName" : {
            "description" : "The display name of the updater for clients to show used for Gmail items. For non-Drive Notification items, this field will always be populated. If the display name cannot be found for the user, the fallback string will be the email address. For Drive Notification items, this is the name of the user who triggered the Drive notification email. This field will be populated if we can extract such information from the Drive Notification email. If the name cannot be extracted, then the email will be the fallback string, which is used as the display name text in the UI when needed. This is not the actual sender of the email, as the sender is always comments-noreply@docs.google.com.",
            "type" : "string"
          },
          "updaterToShowUserId" : {
            "$ref" : "#/components/schemas/UserId"
          }
        },
        "type" : "object"
      },
      "UserMentionData" : {
        "description" : "Person metadata, for USER_MENTION segments. Should always contain at least one of user_gaia_id, user_id, email or user. The exact set of populated fields may differ depending on the context and the level in the serving stack; for example, emails will be elided on the viewing path. But as a general rule, a proto having any one of the four is valid, subject to the standard constraints of the applied annotations -- that is, communication between servers and clients will ignore jspb.ignore fields, and communication between servers and other servers (or between servers and storage) will ignore client_only fields. For more on the annotations, see the comments in social/common/segment_annotations.proto",
        "properties" : {
          "email" : {
            "type" : "string"
          },
          "user" : {
            "$ref" : "#/components/schemas/PrincipalProto"
          },
          "userGaiaId" : {
            "description" : "An unobfuscated gaia ID:",
            "format" : "int64",
            "type" : "string"
          },
          "userId" : {
            "description" : "An obfuscated gaia ID:",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "UserMentionMetadata" : {
        "description" : "Annotation metadata for user mentions (+/@/-).",
        "properties" : {
          "displayName" : {
            "description" : "Display name of the mentioned user. This field should remain empty when clients resolve a UserMention annotation. It will be filled in when a UserMention is generated by the Integration Server.",
            "type" : "string"
          },
          "gender" : {
            "description" : "Gender of the mentioned user. One of \"female\", \"male\" or \"other\". Used for choosing accurate translations for strings that contain the UserMention, when these need to be constructed (e.g. task assignment update message). This field should remain empty when clients resolve a UserMention. It will be filled in when a UserMention is generated by the Integration Server.",
            "type" : "string"
          },
          "id" : {
            "$ref" : "#/components/schemas/UserId"
          },
          "inviteeInfo" : {
            "$ref" : "#/components/schemas/InviteeInfo"
          },
          "type" : {
            "enum" : [ "TYPE_UNSPECIFIED", "INVITE", "UNINVITE", "MENTION", "MENTION_ALL", "FAILED_TO_ADD" ],
            "type" : "string"
          },
          "userMentionError" : {
            "description" : "Specific reason for the user mention failing, for fine-grained processing by clients (i.e. specific error message for space limit exceeded case) IMPORTANT: Set this only for FAILED_TO_ADD case.",
            "enum" : [ "USER_MENTION_ERROR_UNSPECIFIED", "MEMBERSHIP_LIMIT_EXCEEDED" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "VPCSettings" : {
        "properties" : {
          "project" : {
            "description" : "The resource name of the GCP Project to be used for VPC SC policy check. VPC security settings on this project will be honored for Cloud Search APIs after project_name has been updated through CustomerService. Format: projects/{project_id}",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "Value" : {
        "description" : "Definition of a single value with generic type.",
        "properties" : {
          "booleanValue" : {
            "type" : "boolean"
          },
          "dateValue" : {
            "$ref" : "#/components/schemas/Date"
          },
          "doubleValue" : {
            "format" : "double",
            "type" : "number"
          },
          "integerValue" : {
            "format" : "int64",
            "type" : "string"
          },
          "stringValue" : {
            "type" : "string"
          },
          "timestampValue" : {
            "format" : "google-datetime",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ValueFilter" : {
        "properties" : {
          "operatorName" : {
            "description" : "The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.",
            "type" : "string"
          },
          "value" : {
            "$ref" : "#/components/schemas/Value"
          }
        },
        "type" : "object"
      },
      "VideoCallMetadata" : {
        "properties" : {
          "meetingSpace" : {
            "$ref" : "#/components/schemas/MeetingSpace"
          },
          "shouldNotRender" : {
            "description" : "If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip.",
            "type" : "boolean"
          },
          "wasCreatedInCurrentGroup" : {
            "description" : "Whether this meeting space was created via Dynamite in this Dynamite group.",
            "type" : "boolean"
          }
        },
        "type" : "object"
      },
      "VideoInfo" : {
        "description" : "Next tag: 2",
        "properties" : {
          "duration" : {
            "description" : "Duration of the video in milliseconds. This field can be absent for recently uploaded video or inaccurate sometimes.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "VoicePhoneNumber" : {
        "description" : "Represents both long and short phone number that can be called or texted. Short telephone numbers are used to reach local services. Short numbers and their purpose differ from country to country. These numbers in US are in the form of N11 which is a three-digit abbreviated dialing telephone number.",
        "properties" : {
          "e164" : {
            "description" : "E.164 formatted full phone number with leading +. This field also represents encoded form of short telephone numbers in E.164 format. e.g. \"911\" is encoded as \"+1911\".",
            "type" : "string"
          },
          "i18nData" : {
            "$ref" : "#/components/schemas/VoicePhoneNumberI18nData"
          }
        },
        "type" : "object"
      },
      "VoicePhoneNumberI18nData" : {
        "properties" : {
          "countryCode" : {
            "description" : "The country calling code for this number, as defined by the ITU. For example, this would be 1 for NANPA countries, and 33 for France (for more info see i18n.phonenumbers.PhoneNumber.country_code).",
            "format" : "int32",
            "type" : "integer"
          },
          "internationalNumber" : {
            "description" : "Display number formatted using the INTERNATIONAL format.",
            "type" : "string"
          },
          "isValid" : {
            "description" : "When present, indicates the number is valid according to the libphonenumber's isValidNumber API (see https://code.google.com/p/libphonenumber/).",
            "type" : "boolean"
          },
          "nationalNumber" : {
            "description" : "Display number formatted using the NATIONAL format.",
            "type" : "string"
          },
          "regionCode" : {
            "description" : "A region (country, territory, continent, etc), as defined by Unicode's \"CLDR\", itself based on ISO 3166 (UN country codes). For details, see https://www.corp.google.com/~engdocs/java/com/google/i18n/identifiers/RegionCode.html",
            "type" : "string"
          },
          "validationResult" : {
            "description" : "When set to a non-default value, indicates the validation reason that is set when phone number is invalid (is_valid is false).",
            "enum" : [ "UNKNOWN", "IS_POSSIBLE", "INVALID_COUNTRY_CODE", "TOO_SHORT", "TOO_LONG", "IS_POSSIBLE_LOCAL_ONLY", "INVALID_LENGTH" ],
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "WhiteboardInfo" : {
        "description" : "Information on a whiteboard attached to an active conference. A whiteboard is a Jam document.",
        "properties" : {
          "id" : {
            "description" : "The Cosmo Id of the whiteboard document (Jam).",
            "type" : "string"
          },
          "title" : {
            "description" : "Title of the whiteboard document.",
            "type" : "string"
          },
          "uri" : {
            "description" : "The uri for whiteboard document.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "WidgetMarkup" : {
        "properties" : {
          "buttons" : {
            "description" : "buttons is also oneof data and only one of these fields should be set.",
            "items" : {
              "$ref" : "#/components/schemas/Button"
            },
            "type" : "array"
          },
          "dateTimePicker" : {
            "$ref" : "#/components/schemas/DateTimePicker"
          },
          "divider" : {
            "$ref" : "#/components/schemas/Divider"
          },
          "grid" : {
            "$ref" : "#/components/schemas/Grid"
          },
          "horizontalAlignment" : {
            "description" : "The horizontal alignment of this widget.",
            "enum" : [ "HORIZONTAL_ALIGNMENT_UNSPECIFIED", "START", "CENTER", "END" ],
            "type" : "string"
          },
          "image" : {
            "$ref" : "#/components/schemas/Image"
          },
          "imageKeyValue" : {
            "$ref" : "#/components/schemas/ImageKeyValue"
          },
          "keyValue" : {
            "$ref" : "#/components/schemas/KeyValue"
          },
          "menu" : {
            "$ref" : "#/components/schemas/Menu"
          },
          "selectionControl" : {
            "$ref" : "#/components/schemas/SelectionControl"
          },
          "textField" : {
            "$ref" : "#/components/schemas/TextField"
          },
          "textKeyValue" : {
            "$ref" : "#/components/schemas/TextKeyValue"
          },
          "textParagraph" : {
            "$ref" : "#/components/schemas/TextParagraph"
          }
        },
        "type" : "object"
      },
      "WonderCardDelete" : {
        "description" : "Message delete history record extension that exports /wonder/message_mapping/{vertical} attribute of deleted messages which have any smartmail label (eg. ^cob_sm_invoice). go/how-dd-card-deletion",
        "properties" : {
          "messageMappings" : {
            "additionalProperties" : {
              "$ref" : "#/components/schemas/WonderMessageMapping"
            },
            "description" : "Contains <{@code WonderCardType} enum value, value of /wonder/message_mapping/{vertical} attribute of deleted message> pairs.",
            "type" : "object"
          },
          "msgId" : {
            "description" : "Message ID of the original deleted message",
            "format" : "uint64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "WonderMessageMapping" : {
        "description" : "Card mapping attached to original message as an attribute stored at /wonder/message_mapping/{vertical} Next ID: 2",
        "properties" : {
          "wonderCardMessageId" : {
            "description" : "List of wonder card (client-generated) message IDs generated based on the original message.",
            "items" : {
              "type" : "string"
            },
            "type" : "array"
          }
        },
        "type" : "object"
      },
      "WrappedResourceKey" : {
        "description" : "A wrapper around a raw resource key. The secret should never be logged, and this proto annotates those secret fields to ensure that they are not. Clients are encouraged to use this proto rather than defining their own, to ensure that secrets are correctly annotated.",
        "properties" : {
          "resourceKey" : {
            "description" : "Resource key of the Drive item. This field should be unset if, depending on the context, the item does not have a resource key, or if none was specified. This must never be logged.",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "YouTubeBroadcastSessionInfo" : {
        "description" : "Information about a YouTube broadcast session.",
        "properties" : {
          "broadcastStats" : {
            "$ref" : "#/components/schemas/YouTubeBroadcastStats"
          },
          "sessionStateInfo" : {
            "$ref" : "#/components/schemas/SessionStateInfo"
          },
          "youTubeBroadcastSessionId" : {
            "description" : "A unique server-generated ID for the broadcast session.",
            "type" : "string"
          },
          "youTubeLiveBroadcastEvent" : {
            "$ref" : "#/components/schemas/YouTubeLiveBroadcastEvent"
          }
        },
        "type" : "object"
      },
      "YouTubeBroadcastStats" : {
        "description" : "Statistics of the YouTube broadcast session.",
        "properties" : {
          "estimatedViewerCount" : {
            "description" : "Estimated concurrent viewer count.",
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "YouTubeLiveBroadcastEvent" : {
        "description" : "Information about the broadcast to YouTube.",
        "properties" : {
          "brandAccountGaiaId" : {
            "description" : "Input only. If the channel_id is for a YouTube Channel owned by a Brand Account, client is required to populate this field with the obfuscated gaia id of the Brand account when starting the broadcast.",
            "type" : "string"
          },
          "broadcastId" : {
            "description" : "Input only. The broadcast id, used to control the lifecycle of the event on YouTube",
            "type" : "string"
          },
          "channelId" : {
            "description" : "YouTube Channel associated with the broadcast.",
            "type" : "string"
          },
          "viewUrl" : {
            "description" : "Output only. A URL that can be used to watch the meeting broadcast. Will be populated by the backend.",
            "readOnly" : true,
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "YoutubeMetadata" : {
        "description" : "Annotation metadata for YouTube artifact.",
        "properties" : {
          "id" : {
            "description" : "YouTube resource ID of the artifact.",
            "type" : "string"
          },
          "shouldNotRender" : {
            "description" : "If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip.",
            "type" : "boolean"
          },
          "startTime" : {
            "description" : "YouTube query parameter for timestamp. YouTube specific flag that allows users to embed time token when sharing a link. This property contains parsed time token in seconds.",
            "format" : "int32",
            "type" : "integer"
          }
        },
        "type" : "object"
      },
      "YoutubeUserProto" : {
        "properties" : {
          "youtubeUserId" : {
            "format" : "int64",
            "type" : "string"
          }
        },
        "type" : "object"
      },
      "ZwiebackSessionProto" : {
        "description" : "See go/zwieback. New uses of Zwieback sessions must be approved via go/zwieback-request.",
        "properties" : {
          "zwiebackSessionId" : {
            "format" : "uint64",
            "type" : "string"
          }
        },
        "type" : "object"
      }
    },
    "securitySchemes" : {
      "Oauth2" : {
        "description" : "Oauth 2.0 implicit authentication",
        "type" : "oauth2"
      },
      "Oauth2c" : {
        "description" : "Oauth 2.0 authorizationCode authentication",
        "type" : "oauth2"
      }
    }
  }
}